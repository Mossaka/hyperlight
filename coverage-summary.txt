/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/function_call.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use alloc::string::{String, ToString};
   18|       |use alloc::vec::Vec;
   19|       |
   20|       |use anyhow::{Error, Result, bail};
   21|       |use flatbuffers::{FlatBufferBuilder, WIPOffset, size_prefixed_root};
   22|       |#[cfg(feature = "tracing")]
   23|       |use tracing::{Span, instrument};
   24|       |
   25|       |use super::function_types::{ParameterValue, ReturnType};
   26|       |use crate::flatbuffers::hyperlight::generated::{
   27|       |    FunctionCall as FbFunctionCall, FunctionCallArgs as FbFunctionCallArgs,
   28|       |    FunctionCallType as FbFunctionCallType, Parameter, ParameterArgs,
   29|       |    ParameterValue as FbParameterValue, hlbool, hlboolArgs, hldouble, hldoubleArgs, hlfloat,
   30|       |    hlfloatArgs, hlint, hlintArgs, hllong, hllongArgs, hlstring, hlstringArgs, hluint, hluintArgs,
   31|       |    hlulong, hlulongArgs, hlvecbytes, hlvecbytesArgs,
   32|       |};
   33|       |
   34|       |/// The type of function call.
   35|       |#[derive(Debug, Clone, PartialEq, Eq)]
   36|       |pub enum FunctionCallType {
   37|       |    /// The function call is to a guest function.
   38|       |    Guest,
   39|       |    /// The function call is to a host function.
   40|       |    Host,
   41|       |}
   42|       |
   43|       |/// `Functioncall` represents a call to a function in the guest or host.
   44|       |#[derive(Clone)]
   45|       |pub struct FunctionCall {
   46|       |    /// The function name
   47|       |    pub function_name: String,
   48|       |    /// The parameters for the function call.
   49|       |    pub parameters: Option<Vec<ParameterValue>>,
   50|       |    function_call_type: FunctionCallType,
   51|       |    /// The return type of the function call
   52|       |    pub expected_return_type: ReturnType,
   53|       |}
   54|       |
   55|       |impl FunctionCall {
   56|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
   57|      0|    pub fn new(
   58|      0|        function_name: String,
   59|      0|        parameters: Option<Vec<ParameterValue>>,
   60|      0|        function_call_type: FunctionCallType,
   61|      0|        expected_return_type: ReturnType,
   62|      0|    ) -> Self {
   63|      0|        Self {
   64|      0|            function_name,
   65|      0|            parameters,
   66|      0|            function_call_type,
   67|      0|            expected_return_type,
   68|      0|        }
   69|      0|    }
   70|       |
   71|       |    /// The type of the function call.
   72|      0|    pub fn function_call_type(&self) -> FunctionCallType {
   73|      0|        self.function_call_type.clone()
   74|      0|    }
   75|       |
   76|       |    /// Encodes self into the given builder and returns the encoded data.
   77|       |    ///
   78|       |    /// # Notes
   79|       |    ///
   80|       |    /// The builder should not be reused after a call to encode, since this function
   81|       |    /// does not reset the state of the builder. If you want to reuse the builder,
   82|       |    /// you'll need to reset it first.
   83|      0|    pub fn encode<'a>(&self, builder: &'a mut FlatBufferBuilder) -> &'a [u8] {
   84|      0|        let function_name = builder.create_string(&self.function_name);
   85|       |
   86|      0|        let function_call_type = match self.function_call_type {
   87|      0|            FunctionCallType::Guest => FbFunctionCallType::guest,
   88|      0|            FunctionCallType::Host => FbFunctionCallType::host,
   89|       |        };
   90|       |
   91|      0|        let expected_return_type = self.expected_return_type.into();
   92|       |
   93|      0|        let parameters = match &self.parameters {
   94|      0|            Some(p) if !p.is_empty() => {
   95|      0|                let parameter_offsets: Vec<WIPOffset<Parameter>> = p
   96|      0|                    .iter()
   97|      0|                    .map(|param| match param {
   98|      0|                        ParameterValue::Int(i) => {
   99|      0|                            let hlint = hlint::create(builder, &hlintArgs { value: *i });
  100|      0|                            Parameter::create(
  101|      0|                                builder,
  102|      0|                                &ParameterArgs {
  103|      0|                                    value_type: FbParameterValue::hlint,
  104|      0|                                    value: Some(hlint.as_union_value()),
  105|      0|                                },
  106|      0|                            )
  107|       |                        }
  108|      0|                        ParameterValue::UInt(ui) => {
  109|      0|                            let hluint = hluint::create(builder, &hluintArgs { value: *ui });
  110|      0|                            Parameter::create(
  111|      0|                                builder,
  112|      0|                                &ParameterArgs {
  113|      0|                                    value_type: FbParameterValue::hluint,
  114|      0|                                    value: Some(hluint.as_union_value()),
  115|      0|                                },
  116|      0|                            )
  117|       |                        }
  118|      0|                        ParameterValue::Long(l) => {
  119|      0|                            let hllong = hllong::create(builder, &hllongArgs { value: *l });
  120|      0|                            Parameter::create(
  121|      0|                                builder,
  122|      0|                                &ParameterArgs {
  123|      0|                                    value_type: FbParameterValue::hllong,
  124|      0|                                    value: Some(hllong.as_union_value()),
  125|      0|                                },
  126|      0|                            )
  127|       |                        }
  128|      0|                        ParameterValue::ULong(ul) => {
  129|      0|                            let hlulong = hlulong::create(builder, &hlulongArgs { value: *ul });
  130|      0|                            Parameter::create(
  131|      0|                                builder,
  132|      0|                                &ParameterArgs {
  133|      0|                                    value_type: FbParameterValue::hlulong,
  134|      0|                                    value: Some(hlulong.as_union_value()),
  135|      0|                                },
  136|      0|                            )
  137|       |                        }
  138|      0|                        ParameterValue::Float(f) => {
  139|      0|                            let hlfloat = hlfloat::create(builder, &hlfloatArgs { value: *f });
  140|      0|                            Parameter::create(
  141|      0|                                builder,
  142|      0|                                &ParameterArgs {
  143|      0|                                    value_type: FbParameterValue::hlfloat,
  144|      0|                                    value: Some(hlfloat.as_union_value()),
  145|      0|                                },
  146|      0|                            )
  147|       |                        }
  148|      0|                        ParameterValue::Double(d) => {
  149|      0|                            let hldouble = hldouble::create(builder, &hldoubleArgs { value: *d });
  150|      0|                            Parameter::create(
  151|      0|                                builder,
  152|      0|                                &ParameterArgs {
  153|      0|                                    value_type: FbParameterValue::hldouble,
  154|      0|                                    value: Some(hldouble.as_union_value()),
  155|      0|                                },
  156|      0|                            )
  157|       |                        }
  158|      0|                        ParameterValue::Bool(b) => {
  159|      0|                            let hlbool = hlbool::create(builder, &hlboolArgs { value: *b });
  160|      0|                            Parameter::create(
  161|      0|                                builder,
  162|      0|                                &ParameterArgs {
  163|      0|                                    value_type: FbParameterValue::hlbool,
  164|      0|                                    value: Some(hlbool.as_union_value()),
  165|      0|                                },
  166|      0|                            )
  167|       |                        }
  168|      0|                        ParameterValue::String(s) => {
  169|      0|                            let val = builder.create_string(s.as_str());
  170|      0|                            let hlstring =
  171|      0|                                hlstring::create(builder, &hlstringArgs { value: Some(val) });
  172|      0|                            Parameter::create(
  173|      0|                                builder,
  174|      0|                                &ParameterArgs {
  175|      0|                                    value_type: FbParameterValue::hlstring,
  176|      0|                                    value: Some(hlstring.as_union_value()),
  177|      0|                                },
  178|      0|                            )
  179|       |                        }
  180|      0|                        ParameterValue::VecBytes(v) => {
  181|      0|                            let vec_bytes = builder.create_vector(v);
  182|      0|                            let hlvecbytes = hlvecbytes::create(
  183|      0|                                builder,
  184|      0|                                &hlvecbytesArgs {
  185|      0|                                    value: Some(vec_bytes),
  186|      0|                                },
  187|      0|                            );
  188|      0|                            Parameter::create(
  189|      0|                                builder,
  190|      0|                                &ParameterArgs {
  191|      0|                                    value_type: FbParameterValue::hlvecbytes,
  192|      0|                                    value: Some(hlvecbytes.as_union_value()),
  193|      0|                                },
  194|      0|                            )
  195|       |                        }
  196|      0|                    })
  197|      0|                    .collect();
  198|      0|                Some(builder.create_vector(&parameter_offsets))
  199|       |            }
  200|      0|            _ => None,
  201|       |        };
  202|       |
  203|      0|        let function_call = FbFunctionCall::create(
  204|      0|            builder,
  205|      0|            &FbFunctionCallArgs {
  206|      0|                function_name: Some(function_name),
  207|      0|                parameters,
  208|      0|                function_call_type,
  209|      0|                expected_return_type,
  210|      0|            },
  211|      0|        );
  212|      0|        builder.finish_size_prefixed(function_call, None);
  213|      0|        builder.finished_data()
  214|      0|    }
  215|       |}
  216|       |
  217|       |#[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  218|      0|pub fn validate_guest_function_call_buffer(function_call_buffer: &[u8]) -> Result<()> {
  219|       |    let guest_function_call_fb = size_prefixed_root::<FbFunctionCall>(function_call_buffer)
  220|      0|        .map_err(|e| anyhow::anyhow!("Error reading function call buffer: {:?}", e))?;
  221|       |    match guest_function_call_fb.function_call_type() {
  222|       |        FbFunctionCallType::guest => Ok(()),
  223|       |        other => {
  224|       |            bail!("Invalid function call type: {:?}", other);
  225|       |        }
  226|       |    }
  227|      0|}
  228|       |
  229|       |#[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  230|      0|pub fn validate_host_function_call_buffer(function_call_buffer: &[u8]) -> Result<()> {
  231|       |    let host_function_call_fb = size_prefixed_root::<FbFunctionCall>(function_call_buffer)
  232|      0|        .map_err(|e| anyhow::anyhow!("Error reading function call buffer: {:?}", e))?;
  233|       |    match host_function_call_fb.function_call_type() {
  234|       |        FbFunctionCallType::host => Ok(()),
  235|       |        other => {
  236|       |            bail!("Invalid function call type: {:?}", other);
  237|       |        }
  238|       |    }
  239|      0|}
  240|       |
  241|       |impl TryFrom<&[u8]> for FunctionCall {
  242|       |    type Error = Error;
  243|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  244|      0|    fn try_from(value: &[u8]) -> Result<Self> {
  245|       |        let function_call_fb = size_prefixed_root::<FbFunctionCall>(value)
  246|      0|            .map_err(|e| anyhow::anyhow!("Error reading function call buffer: {:?}", e))?;
  247|       |        let function_name = function_call_fb.function_name();
  248|       |        let function_call_type = match function_call_fb.function_call_type() {
  249|       |            FbFunctionCallType::guest => FunctionCallType::Guest,
  250|       |            FbFunctionCallType::host => FunctionCallType::Host,
  251|       |            other => {
  252|       |                bail!("Invalid function call type: {:?}", other);
  253|       |            }
  254|       |        };
  255|       |        let expected_return_type = function_call_fb.expected_return_type().try_into()?;
  256|       |
  257|       |        let parameters = function_call_fb
  258|       |            .parameters()
  259|      0|            .map(|v| {
  260|      0|                v.iter()
  261|      0|                    .map(|p| p.try_into())
  262|      0|                    .collect::<Result<Vec<ParameterValue>>>()
  263|      0|            })
  264|       |            .transpose()?;
  265|       |
  266|       |        Ok(Self {
  267|       |            function_name: function_name.to_string(),
  268|       |            parameters,
  269|       |            function_call_type,
  270|       |            expected_return_type,
  271|       |        })
  272|      0|    }
  273|       |}
  274|       |
  275|       |#[cfg(test)]
  276|       |mod tests {
  277|       |    use alloc::vec;
  278|       |
  279|       |    use super::*;
  280|       |    use crate::flatbuffer_wrappers::function_types::ReturnType;
  281|       |
  282|       |    #[test]
  283|       |    fn read_from_flatbuffer() -> Result<()> {
  284|       |        let mut builder = FlatBufferBuilder::new();
  285|       |        let test_data = FunctionCall::new(
  286|       |            "PrintTwelveArgs".to_string(),
  287|       |            Some(vec![
  288|       |                ParameterValue::String("1".to_string()),
  289|       |                ParameterValue::Int(2),
  290|       |                ParameterValue::Long(3),
  291|       |                ParameterValue::String("4".to_string()),
  292|       |                ParameterValue::String("5".to_string()),
  293|       |                ParameterValue::Bool(true),
  294|       |                ParameterValue::Bool(false),
  295|       |                ParameterValue::UInt(8),
  296|       |                ParameterValue::ULong(9),
  297|       |                ParameterValue::Int(10),
  298|       |                ParameterValue::Float(3.123),
  299|       |                ParameterValue::Double(0.01),
  300|       |            ]),
  301|       |            FunctionCallType::Guest,
  302|       |            ReturnType::Int,
  303|       |        )
  304|       |        .encode(&mut builder);
  305|       |
  306|       |        let function_call = FunctionCall::try_from(test_data)?;
  307|       |        assert_eq!(function_call.function_name, "PrintTwelveArgs");
  308|       |        assert!(function_call.parameters.is_some());
  309|       |        let parameters = function_call.parameters.unwrap();
  310|       |        assert_eq!(parameters.len(), 12);
  311|       |        let expected_parameters = vec![
  312|       |            ParameterValue::String("1".to_string()),
  313|       |            ParameterValue::Int(2),
  314|       |            ParameterValue::Long(3),
  315|       |            ParameterValue::String("4".to_string()),
  316|       |            ParameterValue::String("5".to_string()),
  317|       |            ParameterValue::Bool(true),
  318|       |            ParameterValue::Bool(false),
  319|       |            ParameterValue::UInt(8),
  320|       |            ParameterValue::ULong(9),
  321|       |            ParameterValue::Int(10),
  322|       |            ParameterValue::Float(3.123),
  323|       |            ParameterValue::Double(0.01),
  324|       |        ];
  325|       |        assert!(expected_parameters == parameters);
  326|       |        assert_eq!(function_call.function_call_type, FunctionCallType::Guest);
  327|       |
  328|       |        Ok(())
  329|       |    }
  330|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/function_types.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use alloc::string::{String, ToString};
   18|       |use alloc::vec::Vec;
   19|       |
   20|       |use anyhow::{Error, Result, anyhow, bail};
   21|       |use flatbuffers::size_prefixed_root;
   22|       |#[cfg(feature = "tracing")]
   23|       |use tracing::{Span, instrument};
   24|       |
   25|       |use crate::flatbuffers::hyperlight::generated::{
   26|       |    FunctionCallResult as FbFunctionCallResult, FunctionCallResultArgs as FbFunctionCallResultArgs,
   27|       |    Parameter, ParameterType as FbParameterType, ParameterValue as FbParameterValue,
   28|       |    ReturnType as FbReturnType, ReturnValue as FbReturnValue, hlbool, hlboolArgs, hldouble,
   29|       |    hldoubleArgs, hlfloat, hlfloatArgs, hlint, hlintArgs, hllong, hllongArgs, hlsizeprefixedbuffer,
   30|       |    hlsizeprefixedbufferArgs, hlstring, hlstringArgs, hluint, hluintArgs, hlulong, hlulongArgs,
   31|       |    hlvoid, hlvoidArgs,
   32|       |};
   33|       |
   34|       |/// Supported parameter types with values for function calling.
   35|       |#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
   36|       |#[derive(Debug, Clone, PartialEq)]
   37|       |pub enum ParameterValue {
   38|       |    /// i32
   39|       |    Int(i32),
   40|       |    /// u32
   41|       |    UInt(u32),
   42|       |    /// i64
   43|       |    Long(i64),
   44|       |    /// i64
   45|       |    ULong(u64),
   46|       |    /// f32
   47|       |    Float(f32),
   48|       |    /// f64
   49|       |    Double(f64),
   50|       |    /// String
   51|       |    String(String),
   52|       |    /// bool
   53|       |    Bool(bool),
   54|       |    /// `Vec<u8>`
   55|       |    VecBytes(Vec<u8>),
   56|       |}
   57|       |
   58|       |/// Supported parameter types for function calling.
   59|       |#[derive(Debug, Clone, PartialEq, Eq)]
   60|       |#[repr(C)]
   61|       |pub enum ParameterType {
   62|       |    /// i32
   63|       |    Int,
   64|       |    /// u32
   65|       |    UInt,
   66|       |    /// i64
   67|       |    Long,
   68|       |    /// u64
   69|       |    ULong,
   70|       |    /// f32
   71|       |    Float,
   72|       |    /// f64
   73|       |    Double,
   74|       |    /// String
   75|       |    String,
   76|       |    /// bool
   77|       |    Bool,
   78|       |    /// `Vec<u8>`
   79|       |    VecBytes,
   80|       |}
   81|       |
   82|       |/// Supported return types with values from function calling.
   83|       |#[derive(Debug, Clone, PartialEq)]
   84|       |pub enum ReturnValue {
   85|       |    /// i32
   86|       |    Int(i32),
   87|       |    /// u32
   88|       |    UInt(u32),
   89|       |    /// i64
   90|       |    Long(i64),
   91|       |    /// u64
   92|       |    ULong(u64),
   93|       |    /// f32
   94|       |    Float(f32),
   95|       |    /// f64
   96|       |    Double(f64),
   97|       |    /// String
   98|       |    String(String),
   99|       |    /// bool
  100|       |    Bool(bool),
  101|       |    /// ()
  102|       |    Void(()),
  103|       |    /// `Vec<u8>`
  104|       |    VecBytes(Vec<u8>),
  105|       |}
  106|       |
  107|       |/// Supported return types from function calling.
  108|       |#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
  109|       |#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]
  110|       |#[repr(C)]
  111|       |pub enum ReturnType {
  112|       |    /// i32
  113|       |    #[default]
  114|       |    Int,
  115|       |    /// u32
  116|       |    UInt,
  117|       |    /// i64
  118|       |    Long,
  119|       |    /// u64
  120|       |    ULong,
  121|       |    /// f32
  122|       |    Float,
  123|       |    /// f64
  124|       |    Double,
  125|       |    /// String
  126|       |    String,
  127|       |    /// bool
  128|       |    Bool,
  129|       |    /// ()
  130|       |    Void,
  131|       |    /// `Vec<u8>`
  132|       |    VecBytes,
  133|       |}
  134|       |
  135|       |impl From<&ParameterValue> for ParameterType {
  136|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
  137|      0|    fn from(value: &ParameterValue) -> Self {
  138|      0|        match *value {
  139|      0|            ParameterValue::Int(_) => ParameterType::Int,
  140|      0|            ParameterValue::UInt(_) => ParameterType::UInt,
  141|      0|            ParameterValue::Long(_) => ParameterType::Long,
  142|      0|            ParameterValue::ULong(_) => ParameterType::ULong,
  143|      0|            ParameterValue::Float(_) => ParameterType::Float,
  144|      0|            ParameterValue::Double(_) => ParameterType::Double,
  145|      0|            ParameterValue::String(_) => ParameterType::String,
  146|      0|            ParameterValue::Bool(_) => ParameterType::Bool,
  147|      0|            ParameterValue::VecBytes(_) => ParameterType::VecBytes,
  148|       |        }
  149|      0|    }
  150|       |}
  151|       |
  152|       |impl TryFrom<Parameter<'_>> for ParameterValue {
  153|       |    type Error = Error;
  154|       |
  155|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  156|      0|    fn try_from(param: Parameter<'_>) -> Result<Self> {
  157|       |        let value = param.value_type();
  158|       |        let result = match value {
  159|       |            FbParameterValue::hlint => param
  160|       |                .value_as_hlint()
  161|      0|                .map(|hlint| ParameterValue::Int(hlint.value())),
  162|       |            FbParameterValue::hluint => param
  163|       |                .value_as_hluint()
  164|      0|                .map(|hluint| ParameterValue::UInt(hluint.value())),
  165|       |            FbParameterValue::hllong => param
  166|       |                .value_as_hllong()
  167|      0|                .map(|hllong| ParameterValue::Long(hllong.value())),
  168|       |            FbParameterValue::hlulong => param
  169|       |                .value_as_hlulong()
  170|      0|                .map(|hlulong| ParameterValue::ULong(hlulong.value())),
  171|       |            FbParameterValue::hlfloat => param
  172|       |                .value_as_hlfloat()
  173|      0|                .map(|hlfloat| ParameterValue::Float(hlfloat.value())),
  174|       |            FbParameterValue::hldouble => param
  175|       |                .value_as_hldouble()
  176|      0|                .map(|hldouble| ParameterValue::Double(hldouble.value())),
  177|       |            FbParameterValue::hlbool => param
  178|       |                .value_as_hlbool()
  179|      0|                .map(|hlbool| ParameterValue::Bool(hlbool.value())),
  180|      0|            FbParameterValue::hlstring => param.value_as_hlstring().map(|hlstring| {
  181|      0|                ParameterValue::String(hlstring.value().unwrap_or_default().to_string())
  182|      0|            }),
  183|      0|            FbParameterValue::hlvecbytes => param.value_as_hlvecbytes().map(|hlvecbytes| {
  184|      0|                ParameterValue::VecBytes(hlvecbytes.value().unwrap_or_default().bytes().to_vec())
  185|      0|            }),
  186|       |            other => {
  187|       |                bail!("Unexpected flatbuffer parameter value type: {:?}", other);
  188|       |            }
  189|       |        };
  190|      0|        result.ok_or_else(|| anyhow!("Failed to get parameter value"))
  191|      0|    }
  192|       |}
  193|       |
  194|       |impl From<ParameterType> for FbParameterType {
  195|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
  196|    144|    fn from(value: ParameterType) -> Self {
  197|    144|        match value {
  198|      2|            ParameterType::Int => FbParameterType::hlint,
  199|      0|            ParameterType::UInt => FbParameterType::hluint,
  200|      0|            ParameterType::Long => FbParameterType::hllong,
  201|      0|            ParameterType::ULong => FbParameterType::hlulong,
  202|      0|            ParameterType::Float => FbParameterType::hlfloat,
  203|      0|            ParameterType::Double => FbParameterType::hldouble,
  204|    142|            ParameterType::String => FbParameterType::hlstring,
  205|      0|            ParameterType::Bool => FbParameterType::hlbool,
  206|      0|            ParameterType::VecBytes => FbParameterType::hlvecbytes,
  207|       |        }
  208|    144|    }
  209|       |}
  210|       |
  211|       |impl From<ReturnType> for FbReturnType {
  212|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
  213|    150|    fn from(value: ReturnType) -> Self {
  214|    150|        match value {
  215|    144|            ReturnType::Int => FbReturnType::hlint,
  216|      0|            ReturnType::UInt => FbReturnType::hluint,
  217|      2|            ReturnType::Long => FbReturnType::hllong,
  218|      0|            ReturnType::ULong => FbReturnType::hlulong,
  219|      0|            ReturnType::Float => FbReturnType::hlfloat,
  220|      0|            ReturnType::Double => FbReturnType::hldouble,
  221|      0|            ReturnType::String => FbReturnType::hlstring,
  222|      0|            ReturnType::Bool => FbReturnType::hlbool,
  223|      4|            ReturnType::Void => FbReturnType::hlvoid,
  224|      0|            ReturnType::VecBytes => FbReturnType::hlsizeprefixedbuffer,
  225|       |        }
  226|    150|    }
  227|       |}
  228|       |
  229|       |impl TryFrom<FbParameterType> for ParameterType {
  230|       |    type Error = Error;
  231|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  232|     72|    fn try_from(value: FbParameterType) -> Result<Self> {
  233|     72|        match value {
  234|       |            FbParameterType::hlint => Ok(ParameterType::Int),
  235|       |            FbParameterType::hluint => Ok(ParameterType::UInt),
  236|       |            FbParameterType::hllong => Ok(ParameterType::Long),
  237|       |            FbParameterType::hlulong => Ok(ParameterType::ULong),
  238|       |            FbParameterType::hlfloat => Ok(ParameterType::Float),
  239|       |            FbParameterType::hldouble => Ok(ParameterType::Double),
  240|       |            FbParameterType::hlstring => Ok(ParameterType::String),
  241|       |            FbParameterType::hlbool => Ok(ParameterType::Bool),
  242|       |            FbParameterType::hlvecbytes => Ok(ParameterType::VecBytes),
  243|       |            _ => {
  244|       |                bail!("Unexpected flatbuffer parameter type: {:?}", value)
  245|       |            }
  246|       |        }
  247|     72|    }
  248|       |}
  249|       |
  250|       |impl TryFrom<FbReturnType> for ReturnType {
  251|       |    type Error = Error;
  252|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  253|     75|    fn try_from(value: FbReturnType) -> Result<Self> {
  254|     75|        match value {
  255|       |            FbReturnType::hlint => Ok(ReturnType::Int),
  256|       |            FbReturnType::hluint => Ok(ReturnType::UInt),
  257|       |            FbReturnType::hllong => Ok(ReturnType::Long),
  258|       |            FbReturnType::hlulong => Ok(ReturnType::ULong),
  259|       |            FbReturnType::hlfloat => Ok(ReturnType::Float),
  260|       |            FbReturnType::hldouble => Ok(ReturnType::Double),
  261|       |            FbReturnType::hlstring => Ok(ReturnType::String),
  262|       |            FbReturnType::hlbool => Ok(ReturnType::Bool),
  263|       |            FbReturnType::hlvoid => Ok(ReturnType::Void),
  264|       |            FbReturnType::hlsizeprefixedbuffer => Ok(ReturnType::VecBytes),
  265|       |            _ => {
  266|       |                bail!("Unexpected flatbuffer return type: {:?}", value)
  267|       |            }
  268|       |        }
  269|     75|    }
  270|       |}
  271|       |
  272|       |impl TryFrom<ParameterValue> for i32 {
  273|       |    type Error = Error;
  274|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  275|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  276|      0|        match value {
  277|       |            ParameterValue::Int(v) => Ok(v),
  278|       |            _ => {
  279|       |                bail!("Unexpected parameter value type: {:?}", value)
  280|       |            }
  281|       |        }
  282|      0|    }
  283|       |}
  284|       |
  285|       |impl TryFrom<ParameterValue> for u32 {
  286|       |    type Error = Error;
  287|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  288|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  289|      0|        match value {
  290|       |            ParameterValue::UInt(v) => Ok(v),
  291|       |            _ => {
  292|       |                bail!("Unexpected parameter value type: {:?}", value)
  293|       |            }
  294|       |        }
  295|      0|    }
  296|       |}
  297|       |
  298|       |impl TryFrom<ParameterValue> for i64 {
  299|       |    type Error = Error;
  300|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  301|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  302|      0|        match value {
  303|       |            ParameterValue::Long(v) => Ok(v),
  304|       |            _ => {
  305|       |                bail!("Unexpected parameter value type: {:?}", value)
  306|       |            }
  307|       |        }
  308|      0|    }
  309|       |}
  310|       |
  311|       |impl TryFrom<ParameterValue> for u64 {
  312|       |    type Error = Error;
  313|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  314|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  315|      0|        match value {
  316|       |            ParameterValue::ULong(v) => Ok(v),
  317|       |            _ => {
  318|       |                bail!("Unexpected parameter value type: {:?}", value)
  319|       |            }
  320|       |        }
  321|      0|    }
  322|       |}
  323|       |
  324|       |impl TryFrom<ParameterValue> for f32 {
  325|       |    type Error = Error;
  326|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  327|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  328|      0|        match value {
  329|       |            ParameterValue::Float(v) => Ok(v),
  330|       |            _ => {
  331|       |                bail!("Unexpected parameter value type: {:?}", value)
  332|       |            }
  333|       |        }
  334|      0|    }
  335|       |}
  336|       |
  337|       |impl TryFrom<ParameterValue> for f64 {
  338|       |    type Error = Error;
  339|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  340|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  341|      0|        match value {
  342|       |            ParameterValue::Double(v) => Ok(v),
  343|       |            _ => {
  344|       |                bail!("Unexpected parameter value type: {:?}", value)
  345|       |            }
  346|       |        }
  347|      0|    }
  348|       |}
  349|       |
  350|       |impl TryFrom<ParameterValue> for String {
  351|       |    type Error = Error;
  352|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  353|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  354|      0|        match value {
  355|       |            ParameterValue::String(v) => Ok(v),
  356|       |            _ => {
  357|       |                bail!("Unexpected parameter value type: {:?}", value)
  358|       |            }
  359|       |        }
  360|      0|    }
  361|       |}
  362|       |
  363|       |impl TryFrom<ParameterValue> for bool {
  364|       |    type Error = Error;
  365|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  366|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  367|      0|        match value {
  368|       |            ParameterValue::Bool(v) => Ok(v),
  369|       |            _ => {
  370|       |                bail!("Unexpected parameter value type: {:?}", value)
  371|       |            }
  372|       |        }
  373|      0|    }
  374|       |}
  375|       |
  376|       |impl TryFrom<ParameterValue> for Vec<u8> {
  377|       |    type Error = Error;
  378|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  379|      0|    fn try_from(value: ParameterValue) -> Result<Self> {
  380|      0|        match value {
  381|       |            ParameterValue::VecBytes(v) => Ok(v),
  382|       |            _ => {
  383|       |                bail!("Unexpected parameter value type: {:?}", value)
  384|       |            }
  385|       |        }
  386|      0|    }
  387|       |}
  388|       |
  389|       |impl TryFrom<ReturnValue> for i32 {
  390|       |    type Error = Error;
  391|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  392|     23|    fn try_from(value: ReturnValue) -> Result<Self> {
  393|     23|        match value {
  394|       |            ReturnValue::Int(v) => Ok(v),
  395|       |            _ => {
  396|       |                bail!("Unexpected return value type: {:?}", value)
  397|       |            }
  398|       |        }
  399|     23|    }
  400|       |}
  401|       |
  402|       |impl TryFrom<ReturnValue> for u32 {
  403|       |    type Error = Error;
  404|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  405|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  406|      0|        match value {
  407|       |            ReturnValue::UInt(v) => Ok(v),
  408|       |            _ => {
  409|       |                bail!("Unexpected return value type: {:?}", value)
  410|       |            }
  411|       |        }
  412|      0|    }
  413|       |}
  414|       |
  415|       |impl TryFrom<ReturnValue> for i64 {
  416|       |    type Error = Error;
  417|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  418|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  419|      0|        match value {
  420|       |            ReturnValue::Long(v) => Ok(v),
  421|       |            _ => {
  422|       |                bail!("Unexpected return value type: {:?}", value)
  423|       |            }
  424|       |        }
  425|      0|    }
  426|       |}
  427|       |
  428|       |impl TryFrom<ReturnValue> for u64 {
  429|       |    type Error = Error;
  430|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  431|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  432|      0|        match value {
  433|       |            ReturnValue::ULong(v) => Ok(v),
  434|       |            _ => {
  435|       |                bail!("Unexpected return value type: {:?}", value)
  436|       |            }
  437|       |        }
  438|      0|    }
  439|       |}
  440|       |
  441|       |impl TryFrom<ReturnValue> for f32 {
  442|       |    type Error = Error;
  443|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  444|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  445|      0|        match value {
  446|       |            ReturnValue::Float(v) => Ok(v),
  447|       |            _ => {
  448|       |                bail!("Unexpected return value type: {:?}", value)
  449|       |            }
  450|       |        }
  451|      0|    }
  452|       |}
  453|       |
  454|       |impl TryFrom<ReturnValue> for f64 {
  455|       |    type Error = Error;
  456|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  457|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  458|      0|        match value {
  459|       |            ReturnValue::Double(v) => Ok(v),
  460|       |            _ => {
  461|       |                bail!("Unexpected return value type: {:?}", value)
  462|       |            }
  463|       |        }
  464|      0|    }
  465|       |}
  466|       |
  467|       |impl TryFrom<ReturnValue> for String {
  468|       |    type Error = Error;
  469|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  470|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  471|      0|        match value {
  472|       |            ReturnValue::String(v) => Ok(v),
  473|       |            _ => {
  474|       |                bail!("Unexpected return value type: {:?}", value)
  475|       |            }
  476|       |        }
  477|      0|    }
  478|       |}
  479|       |
  480|       |impl TryFrom<ReturnValue> for bool {
  481|       |    type Error = Error;
  482|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  483|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  484|      0|        match value {
  485|       |            ReturnValue::Bool(v) => Ok(v),
  486|       |            _ => {
  487|       |                bail!("Unexpected return value type: {:?}", value)
  488|       |            }
  489|       |        }
  490|      0|    }
  491|       |}
  492|       |
  493|       |impl TryFrom<ReturnValue> for Vec<u8> {
  494|       |    type Error = Error;
  495|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  496|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  497|      0|        match value {
  498|       |            ReturnValue::VecBytes(v) => Ok(v),
  499|       |            _ => {
  500|       |                bail!("Unexpected return value type: {:?}", value)
  501|       |            }
  502|       |        }
  503|      0|    }
  504|       |}
  505|       |
  506|       |impl TryFrom<ReturnValue> for () {
  507|       |    type Error = Error;
  508|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  509|      0|    fn try_from(value: ReturnValue) -> Result<Self> {
  510|      0|        match value {
  511|       |            ReturnValue::Void(()) => Ok(()),
  512|       |            _ => {
  513|       |                bail!("Unexpected return value type: {:?}", value)
  514|       |            }
  515|       |        }
  516|      0|    }
  517|       |}
  518|       |
  519|       |impl TryFrom<FbFunctionCallResult<'_>> for ReturnValue {
  520|       |    type Error = Error;
  521|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  522|      0|    fn try_from(function_call_result_fb: FbFunctionCallResult<'_>) -> Result<Self> {
  523|       |        match function_call_result_fb.return_value_type() {
  524|       |            FbReturnValue::hlint => {
  525|       |                let hlint = function_call_result_fb
  526|       |                    .return_value_as_hlint()
  527|      0|                    .ok_or_else(|| anyhow!("Failed to get hlint from return value"))?;
  528|       |                Ok(ReturnValue::Int(hlint.value()))
  529|       |            }
  530|       |            FbReturnValue::hluint => {
  531|       |                let hluint = function_call_result_fb
  532|       |                    .return_value_as_hluint()
  533|      0|                    .ok_or_else(|| anyhow!("Failed to get hluint from return value"))?;
  534|       |                Ok(ReturnValue::UInt(hluint.value()))
  535|       |            }
  536|       |            FbReturnValue::hllong => {
  537|       |                let hllong = function_call_result_fb
  538|       |                    .return_value_as_hllong()
  539|      0|                    .ok_or_else(|| anyhow!("Failed to get hllong from return value"))?;
  540|       |                Ok(ReturnValue::Long(hllong.value()))
  541|       |            }
  542|       |            FbReturnValue::hlulong => {
  543|       |                let hlulong = function_call_result_fb
  544|       |                    .return_value_as_hlulong()
  545|      0|                    .ok_or_else(|| anyhow!("Failed to get hlulong from return value"))?;
  546|       |                Ok(ReturnValue::ULong(hlulong.value()))
  547|       |            }
  548|       |            FbReturnValue::hlfloat => {
  549|       |                let hlfloat = function_call_result_fb
  550|       |                    .return_value_as_hlfloat()
  551|      0|                    .ok_or_else(|| anyhow!("Failed to get hlfloat from return value"))?;
  552|       |                Ok(ReturnValue::Float(hlfloat.value()))
  553|       |            }
  554|       |            FbReturnValue::hldouble => {
  555|       |                let hldouble = function_call_result_fb
  556|       |                    .return_value_as_hldouble()
  557|      0|                    .ok_or_else(|| anyhow!("Failed to get hldouble from return value"))?;
  558|       |                Ok(ReturnValue::Double(hldouble.value()))
  559|       |            }
  560|       |            FbReturnValue::hlbool => {
  561|       |                let hlbool = function_call_result_fb
  562|       |                    .return_value_as_hlbool()
  563|      0|                    .ok_or_else(|| anyhow!("Failed to get hlbool from return value"))?;
  564|       |                Ok(ReturnValue::Bool(hlbool.value()))
  565|       |            }
  566|       |            FbReturnValue::hlstring => {
  567|       |                let hlstring = match function_call_result_fb.return_value_as_hlstring() {
  568|      0|                    Some(hlstring) => hlstring.value().map(|v| v.to_string()),
  569|       |                    None => None,
  570|       |                };
  571|       |                Ok(ReturnValue::String(hlstring.unwrap_or("".to_string())))
  572|       |            }
  573|       |            FbReturnValue::hlvoid => Ok(ReturnValue::Void(())),
  574|       |            FbReturnValue::hlsizeprefixedbuffer => {
  575|       |                let hlvecbytes =
  576|       |                    match function_call_result_fb.return_value_as_hlsizeprefixedbuffer() {
  577|       |                        Some(hlvecbytes) => hlvecbytes
  578|       |                            .value()
  579|      0|                            .map(|val| val.iter().collect::<Vec<u8>>()),
  580|       |                        None => None,
  581|       |                    };
  582|       |                Ok(ReturnValue::VecBytes(hlvecbytes.unwrap_or(Vec::new())))
  583|       |            }
  584|       |            other => {
  585|       |                bail!("Unexpected flatbuffer return value type: {:?}", other)
  586|       |            }
  587|       |        }
  588|      0|    }
  589|       |}
  590|       |
  591|       |impl TryFrom<&[u8]> for ReturnValue {
  592|       |    type Error = Error;
  593|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  594|      0|    fn try_from(value: &[u8]) -> Result<Self> {
  595|       |        let function_call_result_fb = size_prefixed_root::<FbFunctionCallResult>(value)
  596|      0|            .map_err(|e| anyhow!("Failed to get ReturnValue from bytes: {:?}", e))?;
  597|       |        function_call_result_fb.try_into()
  598|      0|    }
  599|       |}
  600|       |
  601|       |impl TryFrom<&ReturnValue> for Vec<u8> {
  602|       |    type Error = Error;
  603|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  604|      0|    fn try_from(value: &ReturnValue) -> Result<Vec<u8>> {
  605|       |        let mut builder = flatbuffers::FlatBufferBuilder::new();
  606|      0|        let result = match value {
  607|       |            ReturnValue::Int(i) => {
  608|       |                let hlint = hlint::create(&mut builder, &hlintArgs { value: *i });
  609|       |                let function_call_result = FbFunctionCallResult::create(
  610|       |                    &mut builder,
  611|       |                    &FbFunctionCallResultArgs {
  612|       |                        return_value: Some(hlint.as_union_value()),
  613|       |                        return_value_type: FbReturnValue::hlint,
  614|       |                    },
  615|       |                );
  616|       |                builder.finish_size_prefixed(function_call_result, None);
  617|       |                builder.finished_data().to_vec()
  618|       |            }
  619|       |            ReturnValue::UInt(ui) => {
  620|       |                let hluint = hluint::create(&mut builder, &hluintArgs { value: *ui });
  621|       |                let function_call_result = FbFunctionCallResult::create(
  622|       |                    &mut builder,
  623|       |                    &FbFunctionCallResultArgs {
  624|       |                        return_value: Some(hluint.as_union_value()),
  625|       |                        return_value_type: FbReturnValue::hluint,
  626|       |                    },
  627|       |                );
  628|       |                builder.finish_size_prefixed(function_call_result, None);
  629|       |                builder.finished_data().to_vec()
  630|       |            }
  631|       |            ReturnValue::Long(l) => {
  632|       |                let hllong = hllong::create(&mut builder, &hllongArgs { value: *l });
  633|       |                let function_call_result = FbFunctionCallResult::create(
  634|       |                    &mut builder,
  635|       |                    &FbFunctionCallResultArgs {
  636|       |                        return_value: Some(hllong.as_union_value()),
  637|       |                        return_value_type: FbReturnValue::hllong,
  638|       |                    },
  639|       |                );
  640|       |                builder.finish_size_prefixed(function_call_result, None);
  641|       |                builder.finished_data().to_vec()
  642|       |            }
  643|       |            ReturnValue::ULong(ul) => {
  644|       |                let hlulong = hlulong::create(&mut builder, &hlulongArgs { value: *ul });
  645|       |                let function_call_result = FbFunctionCallResult::create(
  646|       |                    &mut builder,
  647|       |                    &FbFunctionCallResultArgs {
  648|       |                        return_value: Some(hlulong.as_union_value()),
  649|       |                        return_value_type: FbReturnValue::hlulong,
  650|       |                    },
  651|       |                );
  652|       |                builder.finish_size_prefixed(function_call_result, None);
  653|       |                builder.finished_data().to_vec()
  654|       |            }
  655|       |            ReturnValue::Float(f) => {
  656|       |                let hlfloat = hlfloat::create(&mut builder, &hlfloatArgs { value: *f });
  657|       |                let function_call_result = FbFunctionCallResult::create(
  658|       |                    &mut builder,
  659|       |                    &FbFunctionCallResultArgs {
  660|       |                        return_value: Some(hlfloat.as_union_value()),
  661|       |                        return_value_type: FbReturnValue::hlfloat,
  662|       |                    },
  663|       |                );
  664|       |                builder.finish_size_prefixed(function_call_result, None);
  665|       |                builder.finished_data().to_vec()
  666|       |            }
  667|       |            ReturnValue::Double(d) => {
  668|       |                let hldouble = hldouble::create(&mut builder, &hldoubleArgs { value: *d });
  669|       |                let function_call_result = FbFunctionCallResult::create(
  670|       |                    &mut builder,
  671|       |                    &FbFunctionCallResultArgs {
  672|       |                        return_value: Some(hldouble.as_union_value()),
  673|       |                        return_value_type: FbReturnValue::hldouble,
  674|       |                    },
  675|       |                );
  676|       |                builder.finish_size_prefixed(function_call_result, None);
  677|       |                builder.finished_data().to_vec()
  678|       |            }
  679|       |            ReturnValue::Bool(b) => {
  680|       |                let hlbool = hlbool::create(&mut builder, &hlboolArgs { value: *b });
  681|       |                let function_call_result = FbFunctionCallResult::create(
  682|       |                    &mut builder,
  683|       |                    &FbFunctionCallResultArgs {
  684|       |                        return_value: Some(hlbool.as_union_value()),
  685|       |                        return_value_type: FbReturnValue::hlbool,
  686|       |                    },
  687|       |                );
  688|       |                builder.finish_size_prefixed(function_call_result, None);
  689|       |                builder.finished_data().to_vec()
  690|       |            }
  691|       |            ReturnValue::String(s) => {
  692|       |                let hlstring = {
  693|       |                    let val = builder.create_string(s.as_str());
  694|       |                    hlstring::create(&mut builder, &hlstringArgs { value: Some(val) })
  695|       |                };
  696|       |                let function_call_result = FbFunctionCallResult::create(
  697|       |                    &mut builder,
  698|       |                    &FbFunctionCallResultArgs {
  699|       |                        return_value: Some(hlstring.as_union_value()),
  700|       |                        return_value_type: FbReturnValue::hlstring,
  701|       |                    },
  702|       |                );
  703|       |                builder.finish_size_prefixed(function_call_result, None);
  704|       |                builder.finished_data().to_vec()
  705|       |            }
  706|       |            ReturnValue::VecBytes(v) => {
  707|       |                let hlvecbytes = {
  708|       |                    let val = builder.create_vector(v.as_slice());
  709|       |                    hlsizeprefixedbuffer::create(
  710|       |                        &mut builder,
  711|       |                        &hlsizeprefixedbufferArgs {
  712|       |                            value: Some(val),
  713|       |                            size: v.len() as i32,
  714|       |                        },
  715|       |                    )
  716|       |                };
  717|       |                let function_call_result = FbFunctionCallResult::create(
  718|       |                    &mut builder,
  719|       |                    &FbFunctionCallResultArgs {
  720|       |                        return_value: Some(hlvecbytes.as_union_value()),
  721|       |                        return_value_type: FbReturnValue::hlsizeprefixedbuffer,
  722|       |                    },
  723|       |                );
  724|       |                builder.finish_size_prefixed(function_call_result, None);
  725|       |                builder.finished_data().to_vec()
  726|       |            }
  727|       |            ReturnValue::Void(()) => {
  728|       |                let hlvoid = hlvoid::create(&mut builder, &hlvoidArgs {});
  729|       |                let function_call_result = FbFunctionCallResult::create(
  730|       |                    &mut builder,
  731|       |                    &FbFunctionCallResultArgs {
  732|       |                        return_value: Some(hlvoid.as_union_value()),
  733|       |                        return_value_type: FbReturnValue::hlvoid,
  734|       |                    },
  735|       |                );
  736|       |                builder.finish_size_prefixed(function_call_result, None);
  737|       |                builder.finished_data().to_vec()
  738|       |            }
  739|       |        };
  740|       |
  741|       |        Ok(result)
  742|      0|    }
  743|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/guest_error.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |extern crate flatbuffers;
   18|       |
   19|       |use alloc::string::{String, ToString};
   20|       |use alloc::vec::Vec;
   21|       |
   22|       |use anyhow::{Error, Result};
   23|       |use flatbuffers::size_prefixed_root;
   24|       |#[cfg(feature = "tracing")]
   25|       |use tracing::{Span, instrument};
   26|       |
   27|       |use crate::flatbuffers::hyperlight::generated::{
   28|       |    ErrorCode as FbErrorCode, GuestError as FbGuestError, GuestErrorArgs,
   29|       |};
   30|       |
   31|       |#[derive(Debug, Clone, Copy, Eq, PartialEq)]
   32|       |#[repr(C)]
   33|       |/// `ErrorCode` represents an error that occurred in the Hyperlight Guest.
   34|       |pub enum ErrorCode {
   35|       |    NoError = 0,
   36|       |    UnsupportedParameterType = 2,
   37|       |    GuestFunctionNameNotProvided = 3,
   38|       |    GuestFunctionNotFound = 4,
   39|       |    GuestFunctionIncorrecNoOfParameters = 5,
   40|       |    GispatchFunctionPointerNotSet = 6,
   41|       |    OutbError = 7,
   42|       |    UnknownError = 8,
   43|       |    StackOverflow = 9,
   44|       |    GsCheckFailed = 10,
   45|       |    TooManyGuestFunctions = 11,
   46|       |    FailureInDlmalloc = 12,
   47|       |    MallocFailed = 13,
   48|       |    GuestFunctionParameterTypeMismatch = 14,
   49|       |    GuestError = 15,
   50|       |    ArrayLengthParamIsMissing = 16,
   51|       |}
   52|       |
   53|       |impl From<ErrorCode> for FbErrorCode {
   54|      0|    fn from(error_code: ErrorCode) -> Self {
   55|      0|        match error_code {
   56|      0|            ErrorCode::NoError => Self::NoError,
   57|      0|            ErrorCode::UnsupportedParameterType => Self::UnsupportedParameterType,
   58|      0|            ErrorCode::GuestFunctionNameNotProvided => Self::GuestFunctionNameNotProvided,
   59|      0|            ErrorCode::GuestFunctionNotFound => Self::GuestFunctionNotFound,
   60|       |            ErrorCode::GuestFunctionIncorrecNoOfParameters => {
   61|      0|                Self::GuestFunctionIncorrecNoOfParameters
   62|       |            }
   63|      0|            ErrorCode::GispatchFunctionPointerNotSet => Self::GispatchFunctionPointerNotSet,
   64|      0|            ErrorCode::OutbError => Self::OutbError,
   65|      0|            ErrorCode::UnknownError => Self::UnknownError,
   66|      0|            ErrorCode::StackOverflow => Self::StackOverflow,
   67|      0|            ErrorCode::GsCheckFailed => Self::GsCheckFailed,
   68|      0|            ErrorCode::TooManyGuestFunctions => Self::TooManyGuestFunctions,
   69|      0|            ErrorCode::FailureInDlmalloc => Self::FailureInDlmalloc,
   70|      0|            ErrorCode::MallocFailed => Self::MallocFailed,
   71|       |            ErrorCode::GuestFunctionParameterTypeMismatch => {
   72|      0|                Self::GuestFunctionParameterTypeMismatch
   73|       |            }
   74|      0|            ErrorCode::GuestError => Self::GuestError,
   75|      0|            ErrorCode::ArrayLengthParamIsMissing => Self::ArrayLengthParamIsMissing,
   76|       |        }
   77|      0|    }
   78|       |}
   79|       |
   80|       |impl From<FbErrorCode> for ErrorCode {
   81|      0|    fn from(error_code: FbErrorCode) -> Self {
   82|      0|        match error_code {
   83|      0|            FbErrorCode::NoError => Self::NoError,
   84|      0|            FbErrorCode::UnsupportedParameterType => Self::UnsupportedParameterType,
   85|      0|            FbErrorCode::GuestFunctionNameNotProvided => Self::GuestFunctionNameNotProvided,
   86|      0|            FbErrorCode::GuestFunctionNotFound => Self::GuestFunctionNotFound,
   87|       |            FbErrorCode::GuestFunctionIncorrecNoOfParameters => {
   88|      0|                Self::GuestFunctionIncorrecNoOfParameters
   89|       |            }
   90|      0|            FbErrorCode::GispatchFunctionPointerNotSet => Self::GispatchFunctionPointerNotSet,
   91|      0|            FbErrorCode::OutbError => Self::OutbError,
   92|      0|            FbErrorCode::StackOverflow => Self::StackOverflow,
   93|      0|            FbErrorCode::GsCheckFailed => Self::GsCheckFailed,
   94|      0|            FbErrorCode::TooManyGuestFunctions => Self::TooManyGuestFunctions,
   95|      0|            FbErrorCode::FailureInDlmalloc => Self::FailureInDlmalloc,
   96|      0|            FbErrorCode::MallocFailed => Self::MallocFailed,
   97|       |            FbErrorCode::GuestFunctionParameterTypeMismatch => {
   98|      0|                Self::GuestFunctionParameterTypeMismatch
   99|       |            }
  100|      0|            FbErrorCode::GuestError => Self::GuestError,
  101|      0|            FbErrorCode::ArrayLengthParamIsMissing => Self::ArrayLengthParamIsMissing,
  102|      0|            _ => Self::UnknownError,
  103|       |        }
  104|      0|    }
  105|       |}
  106|       |
  107|       |impl From<u64> for ErrorCode {
  108|      0|    fn from(error_code: u64) -> Self {
  109|      0|        match error_code {
  110|      0|            0 => Self::NoError,
  111|      0|            2 => Self::UnsupportedParameterType,
  112|      0|            3 => Self::GuestFunctionNameNotProvided,
  113|      0|            4 => Self::GuestFunctionNotFound,
  114|      0|            5 => Self::GuestFunctionIncorrecNoOfParameters,
  115|      0|            6 => Self::GispatchFunctionPointerNotSet,
  116|      0|            7 => Self::OutbError,
  117|      0|            8 => Self::UnknownError,
  118|      0|            9 => Self::StackOverflow,
  119|      0|            10 => Self::GsCheckFailed,
  120|      0|            11 => Self::TooManyGuestFunctions,
  121|      0|            12 => Self::FailureInDlmalloc,
  122|      0|            13 => Self::MallocFailed,
  123|      0|            14 => Self::GuestFunctionParameterTypeMismatch,
  124|      0|            15 => Self::GuestError,
  125|      0|            16 => Self::ArrayLengthParamIsMissing,
  126|      0|            _ => Self::UnknownError,
  127|       |        }
  128|      0|    }
  129|       |}
  130|       |
  131|       |impl From<ErrorCode> for u64 {
  132|      0|    fn from(error_code: ErrorCode) -> Self {
  133|      0|        match error_code {
  134|      0|            ErrorCode::NoError => 0,
  135|      0|            ErrorCode::UnsupportedParameterType => 2,
  136|      0|            ErrorCode::GuestFunctionNameNotProvided => 3,
  137|      0|            ErrorCode::GuestFunctionNotFound => 4,
  138|      0|            ErrorCode::GuestFunctionIncorrecNoOfParameters => 5,
  139|      0|            ErrorCode::GispatchFunctionPointerNotSet => 6,
  140|      0|            ErrorCode::OutbError => 7,
  141|      0|            ErrorCode::UnknownError => 8,
  142|      0|            ErrorCode::StackOverflow => 9,
  143|      0|            ErrorCode::GsCheckFailed => 10,
  144|      0|            ErrorCode::TooManyGuestFunctions => 11,
  145|      0|            ErrorCode::FailureInDlmalloc => 12,
  146|      0|            ErrorCode::MallocFailed => 13,
  147|      0|            ErrorCode::GuestFunctionParameterTypeMismatch => 14,
  148|      0|            ErrorCode::GuestError => 15,
  149|      0|            ErrorCode::ArrayLengthParamIsMissing => 16,
  150|       |        }
  151|      0|    }
  152|       |}
  153|       |
  154|       |impl From<ErrorCode> for String {
  155|      0|    fn from(error_code: ErrorCode) -> Self {
  156|      0|        match error_code {
  157|      0|            ErrorCode::NoError => "NoError".to_string(),
  158|      0|            ErrorCode::UnsupportedParameterType => "UnsupportedParameterType".to_string(),
  159|      0|            ErrorCode::GuestFunctionNameNotProvided => "GuestFunctionNameNotProvided".to_string(),
  160|      0|            ErrorCode::GuestFunctionNotFound => "GuestFunctionNotFound".to_string(),
  161|       |            ErrorCode::GuestFunctionIncorrecNoOfParameters => {
  162|      0|                "GuestFunctionIncorrecNoOfParameters".to_string()
  163|       |            }
  164|      0|            ErrorCode::GispatchFunctionPointerNotSet => "GispatchFunctionPointerNotSet".to_string(),
  165|      0|            ErrorCode::OutbError => "OutbError".to_string(),
  166|      0|            ErrorCode::UnknownError => "UnknownError".to_string(),
  167|      0|            ErrorCode::StackOverflow => "StackOverflow".to_string(),
  168|      0|            ErrorCode::GsCheckFailed => "GsCheckFailed".to_string(),
  169|      0|            ErrorCode::TooManyGuestFunctions => "TooManyGuestFunctions".to_string(),
  170|      0|            ErrorCode::FailureInDlmalloc => "FailureInDlmalloc".to_string(),
  171|      0|            ErrorCode::MallocFailed => "MallocFailed".to_string(),
  172|       |            ErrorCode::GuestFunctionParameterTypeMismatch => {
  173|      0|                "GuestFunctionParameterTypeMismatch".to_string()
  174|       |            }
  175|      0|            ErrorCode::GuestError => "GuestError".to_string(),
  176|      0|            ErrorCode::ArrayLengthParamIsMissing => "ArrayLengthParamIsMissing".to_string(),
  177|       |        }
  178|      0|    }
  179|       |}
  180|       |
  181|       |/// `GuestError` represents an error that occurred in the Hyperlight Guest.
  182|       |#[derive(Debug, Clone)]
  183|       |pub struct GuestError {
  184|       |    /// The error code.
  185|       |    pub code: ErrorCode,
  186|       |    /// The error message.
  187|       |    pub message: String,
  188|       |}
  189|       |
  190|       |impl GuestError {
  191|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
  192|      0|    pub fn new(code: ErrorCode, message: String) -> Self {
  193|      0|        Self { code, message }
  194|      0|    }
  195|       |}
  196|       |
  197|       |impl TryFrom<&[u8]> for GuestError {
  198|       |    type Error = Error;
  199|      0|    fn try_from(value: &[u8]) -> Result<Self> {
  200|      0|        let guest_error_fb = size_prefixed_root::<FbGuestError>(value)
  201|      0|            .map_err(|e| anyhow::anyhow!("Error while reading GuestError: {:?}", e))?;
  202|      0|        let code = guest_error_fb.code();
  203|      0|        let message = match guest_error_fb.message() {
  204|      0|            Some(message) => message.to_string(),
  205|      0|            None => String::new(),
  206|       |        };
  207|      0|        Ok(Self {
  208|      0|            code: code.into(),
  209|      0|            message,
  210|      0|        })
  211|      0|    }
  212|       |}
  213|       |
  214|       |impl TryFrom<&GuestError> for Vec<u8> {
  215|       |    type Error = Error;
  216|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  217|      0|    fn try_from(value: &GuestError) -> Result<Vec<u8>> {
  218|       |        let mut builder = flatbuffers::FlatBufferBuilder::new();
  219|       |        let message = builder.create_string(&value.message);
  220|       |
  221|       |        let guest_error_fb = FbGuestError::create(
  222|       |            &mut builder,
  223|       |            &GuestErrorArgs {
  224|       |                code: value.code.into(),
  225|       |                message: Some(message),
  226|       |            },
  227|       |        );
  228|       |        builder.finish_size_prefixed(guest_error_fb, None);
  229|       |        let res = builder.finished_data().to_vec();
  230|       |
  231|       |        Ok(res)
  232|      0|    }
  233|       |}
  234|       |
  235|       |impl Default for GuestError {
  236|       |    #[cfg_attr(feature = "tracing", instrument(parent = Span::current(), level= "Trace"))]
  237|      0|    fn default() -> Self {
  238|      0|        Self {
  239|      0|            code: ErrorCode::NoError,
  240|      0|            message: String::new(),
  241|      0|        }
  242|      0|    }
  243|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/guest_log_data.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use alloc::string::{String, ToString};
   18|       |use alloc::vec::Vec;
   19|       |
   20|       |use anyhow::{Error, Result, anyhow};
   21|       |use flatbuffers::size_prefixed_root;
   22|       |#[cfg(feature = "tracing")]
   23|       |use tracing::{Span, instrument};
   24|       |
   25|       |use super::guest_log_level::LogLevel;
   26|       |use crate::flatbuffers::hyperlight::generated::{
   27|       |    GuestLogData as FbGuestLogData, GuestLogDataArgs as FbGuestLogDataArgs, LogLevel as FbLogLevel,
   28|       |};
   29|       |
   30|       |/// The guest log data for a VM sandbox
   31|       |#[derive(Eq, PartialEq, Debug, Clone)]
   32|       |#[allow(missing_docs)]
   33|       |pub struct GuestLogData {
   34|       |    pub message: String,
   35|       |    pub source: String,
   36|       |    pub level: LogLevel,
   37|       |    pub caller: String,
   38|       |    pub source_file: String,
   39|       |    pub line: u32,
   40|       |}
   41|       |
   42|       |impl GuestLogData {
   43|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
   44|      0|    pub fn new(
   45|      0|        message: String,
   46|      0|        source: String,
   47|      0|        level: LogLevel,
   48|      0|        caller: String,
   49|      0|        source_file: String,
   50|      0|        line: u32,
   51|      0|    ) -> Self {
   52|      0|        Self {
   53|      0|            message,
   54|      0|            source,
   55|      0|            level,
   56|      0|            caller,
   57|      0|            source_file,
   58|      0|            line,
   59|      0|        }
   60|      0|    }
   61|       |}
   62|       |
   63|       |impl TryFrom<&[u8]> for GuestLogData {
   64|       |    type Error = Error;
   65|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   66|      0|    fn try_from(raw_bytes: &[u8]) -> Result<Self> {
   67|       |        let gld_gen = size_prefixed_root::<FbGuestLogData>(raw_bytes)
   68|      0|            .map_err(|e| anyhow!("Error while reading GuestLogData: {:?}", e))?;
   69|       |        let message = convert_generated_option("message", gld_gen.message())?;
   70|       |        let source = convert_generated_option("source", gld_gen.source())?;
   71|       |        let level = LogLevel::try_from(&gld_gen.level())?;
   72|       |        let caller = convert_generated_option("caller", gld_gen.caller())?;
   73|       |        let source_file = convert_generated_option("source file", gld_gen.source_file())?;
   74|       |        let line = gld_gen.line();
   75|       |
   76|       |        Ok(GuestLogData {
   77|       |            message,
   78|       |            source,
   79|       |            level,
   80|       |            caller,
   81|       |            source_file,
   82|       |            line,
   83|       |        })
   84|      0|    }
   85|       |}
   86|       |
   87|       |impl TryFrom<&GuestLogData> for Vec<u8> {
   88|       |    type Error = Error;
   89|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   90|      0|    fn try_from(value: &GuestLogData) -> Result<Vec<u8>> {
   91|       |        let mut builder = flatbuffers::FlatBufferBuilder::new();
   92|       |        let message = builder.create_string(&value.message);
   93|       |        let source = builder.create_string(&value.source);
   94|       |        let caller = builder.create_string(&value.caller);
   95|       |        let source_file = builder.create_string(&value.source_file);
   96|       |        let level = FbLogLevel::from(&value.level);
   97|       |
   98|       |        let guest_log_data_fb = FbGuestLogData::create(
   99|       |            &mut builder,
  100|       |            &FbGuestLogDataArgs {
  101|       |                message: Some(message),
  102|       |                source: Some(source),
  103|       |                level,
  104|       |                caller: Some(caller),
  105|       |                source_file: Some(source_file),
  106|       |                line: value.line,
  107|       |            },
  108|       |        );
  109|       |        builder.finish_size_prefixed(guest_log_data_fb, None);
  110|       |        let res = builder.finished_data().to_vec();
  111|       |
  112|       |        Ok(res)
  113|      0|    }
  114|       |}
  115|       |
  116|       |impl TryFrom<GuestLogData> for Vec<u8> {
  117|       |    type Error = Error;
  118|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  119|      0|    fn try_from(value: GuestLogData) -> Result<Vec<u8>> {
  120|       |        (&value).try_into()
  121|      0|    }
  122|       |}
  123|       |
  124|       |#[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  125|      0|fn convert_generated_option(field_name: &str, opt: Option<&str>) -> Result<String> {
  126|      0|    opt.map(|s| s.to_string())
  127|      0|        .ok_or_else(|| anyhow!("Missing field: {}", field_name))
  128|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/guest_log_level.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use anyhow::{Error, Result, bail};
   18|       |use log::Level;
   19|       |#[cfg(feature = "tracing")]
   20|       |use tracing::{Span, instrument};
   21|       |
   22|       |use crate::flatbuffers::hyperlight::generated::LogLevel as FbLogLevel;
   23|       |
   24|       |#[repr(u8)]
   25|       |#[derive(Copy, Clone, Eq, PartialEq, Debug)]
   26|       |pub enum LogLevel {
   27|       |    Trace = 0,
   28|       |    Debug = 1,
   29|       |    Information = 2,
   30|       |    Warning = 3,
   31|       |    Error = 4,
   32|       |    Critical = 5,
   33|       |    None = 6,
   34|       |}
   35|       |
   36|       |impl From<u8> for LogLevel {
   37|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
   38|      0|    fn from(val: u8) -> LogLevel {
   39|      0|        match val {
   40|      0|            0 => LogLevel::Trace,
   41|      0|            1 => LogLevel::Debug,
   42|      0|            2 => LogLevel::Information,
   43|      0|            3 => LogLevel::Warning,
   44|      0|            4 => LogLevel::Error,
   45|      0|            5 => LogLevel::Critical,
   46|      0|            _ => LogLevel::None,
   47|       |        }
   48|      0|    }
   49|       |}
   50|       |
   51|       |impl TryFrom<&FbLogLevel> for LogLevel {
   52|       |    type Error = Error;
   53|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   54|      0|    fn try_from(val: &FbLogLevel) -> Result<LogLevel> {
   55|      0|        match *val {
   56|       |            FbLogLevel::Trace => Ok(LogLevel::Trace),
   57|       |            FbLogLevel::Debug => Ok(LogLevel::Debug),
   58|       |            FbLogLevel::Information => Ok(LogLevel::Information),
   59|       |            FbLogLevel::Warning => Ok(LogLevel::Warning),
   60|       |            FbLogLevel::Error => Ok(LogLevel::Error),
   61|       |            FbLogLevel::Critical => Ok(LogLevel::Critical),
   62|       |            FbLogLevel::None => Ok(LogLevel::None),
   63|       |            _ => {
   64|       |                bail!("Unsupported Flatbuffers log level: {:?}", val);
   65|       |            }
   66|       |        }
   67|      0|    }
   68|       |}
   69|       |
   70|       |impl From<&LogLevel> for FbLogLevel {
   71|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
   72|      0|    fn from(val: &LogLevel) -> FbLogLevel {
   73|      0|        match val {
   74|      0|            LogLevel::Critical => FbLogLevel::Critical,
   75|      0|            LogLevel::Debug => FbLogLevel::Debug,
   76|      0|            LogLevel::Error => FbLogLevel::Error,
   77|      0|            LogLevel::Information => FbLogLevel::Information,
   78|      0|            LogLevel::None => FbLogLevel::None,
   79|      0|            LogLevel::Trace => FbLogLevel::Trace,
   80|      0|            LogLevel::Warning => FbLogLevel::Warning,
   81|       |        }
   82|      0|    }
   83|       |}
   84|       |
   85|       |impl From<&LogLevel> for Level {
   86|       |    // There is a test (sandbox::outb::tests::test_log_outb_log) which emits trace record as logs
   87|       |    // which causes a panic when this function is instrumented as the logger is contained in refcell and
   88|       |    // instrumentation ends up causing a double mutborrow. So this is not instrumented.
   89|       |    //TODO: instrument this once we fix the test
   90|      0|    fn from(val: &LogLevel) -> Level {
   91|      0|        match val {
   92|      0|            LogLevel::Trace => Level::Trace,
   93|      0|            LogLevel::Debug => Level::Debug,
   94|      0|            LogLevel::Information => Level::Info,
   95|      0|            LogLevel::Warning => Level::Warn,
   96|      0|            LogLevel::Error => Level::Error,
   97|      0|            LogLevel::Critical => Level::Error,
   98|       |            // If the log level is None then we will log as trace
   99|      0|            LogLevel::None => Level::Trace,
  100|       |        }
  101|      0|    }
  102|       |}
  103|       |
  104|       |impl From<Level> for LogLevel {
  105|      0|    fn from(val: Level) -> LogLevel {
  106|      0|        match val {
  107|      0|            Level::Trace => LogLevel::Trace,
  108|      0|            Level::Debug => LogLevel::Debug,
  109|      0|            Level::Info => LogLevel::Information,
  110|      0|            Level::Warn => LogLevel::Warning,
  111|      0|            Level::Error => LogLevel::Error,
  112|       |        }
  113|      0|    }
  114|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/host_function_definition.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use alloc::string::{String, ToString};
   18|       |use alloc::vec::Vec;
   19|       |
   20|       |use anyhow::{Error, Result, anyhow};
   21|       |use flatbuffers::{FlatBufferBuilder, WIPOffset};
   22|       |#[cfg(feature = "tracing")]
   23|       |use tracing::{Span, instrument};
   24|       |
   25|       |use super::function_types::{ParameterType, ReturnType};
   26|       |use crate::flatbuffers::hyperlight::generated::{
   27|       |    HostFunctionDefinition as FbHostFunctionDefinition,
   28|       |    HostFunctionDefinitionArgs as FbHostFunctionDefinitionArgs, ParameterType as FbParameterType,
   29|       |};
   30|       |
   31|       |/// The definition of a function exposed from the host to the guest
   32|       |#[derive(Debug, Default, Clone, PartialEq, Eq)]
   33|       |pub struct HostFunctionDefinition {
   34|       |    /// The function name
   35|       |    pub function_name: String,
   36|       |    /// The type of the parameter values for the host function call.
   37|       |    pub parameter_types: Option<Vec<ParameterType>>,
   38|       |    /// The type of the return value from the host function call
   39|       |    pub return_type: ReturnType,
   40|       |}
   41|       |
   42|       |impl HostFunctionDefinition {
   43|       |    /// Create a new `HostFunctionDefinition`.
   44|       |    #[cfg_attr(feature = "tracing", instrument(skip_all, parent = Span::current(), level= "Trace"))]
   45|     75|    pub fn new(
   46|     75|        function_name: String,
   47|     75|        parameter_types: Option<Vec<ParameterType>>,
   48|     75|        return_type: ReturnType,
   49|     75|    ) -> Self {
   50|     75|        Self {
   51|     75|            function_name,
   52|     75|            parameter_types,
   53|     75|            return_type,
   54|     75|        }
   55|     75|    }
   56|       |
   57|       |    /// Convert this `HostFunctionDefinition` into a `WIPOffset<FbHostFunctionDefinition>`.
   58|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   59|    150|    pub(crate) fn convert_to_flatbuffer_def<'a>(
   60|    150|        &self,
   61|    150|        builder: &mut FlatBufferBuilder<'a>,
   62|    150|    ) -> Result<WIPOffset<FbHostFunctionDefinition<'a>>> {
   63|       |        let host_function_name = builder.create_string(&self.function_name);
   64|       |        let return_value_type = self.return_type.into();
   65|       |        let vec_parameters = match &self.parameter_types {
   66|       |            Some(vec_pvt) => {
   67|       |                let num_items = vec_pvt.len();
   68|       |                let mut parameters: Vec<FbParameterType> = Vec::with_capacity(num_items);
   69|       |                for pvt in vec_pvt {
   70|       |                    let fb_pvt = pvt.clone().into();
   71|       |                    parameters.push(fb_pvt);
   72|       |                }
   73|       |                Some(builder.create_vector(&parameters))
   74|       |            }
   75|       |            None => None,
   76|       |        };
   77|       |
   78|       |        let fb_host_function_definition: WIPOffset<FbHostFunctionDefinition> =
   79|       |            FbHostFunctionDefinition::create(
   80|       |                builder,
   81|       |                &FbHostFunctionDefinitionArgs {
   82|       |                    function_name: Some(host_function_name),
   83|       |                    return_type: return_value_type,
   84|       |                    parameters: vec_parameters,
   85|       |                },
   86|       |            );
   87|       |
   88|       |        Ok(fb_host_function_definition)
   89|    150|    }
   90|       |
   91|       |    /// Verify that the function call has the correct parameter types.
   92|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   93|      0|    pub fn verify_equal_parameter_types(
   94|      0|        &self,
   95|      0|        function_call_parameter_types: &[ParameterType],
   96|      0|    ) -> Result<()> {
   97|       |        if let Some(parameter_types) = &self.parameter_types {
   98|       |            for (i, parameter_type) in parameter_types.iter().enumerate() {
   99|       |                if parameter_type != &function_call_parameter_types[i] {
  100|       |                    return Err(anyhow!("Incorrect parameter type for parameter {}", i + 1));
  101|       |                }
  102|       |            }
  103|       |        }
  104|       |        Ok(())
  105|      0|    }
  106|       |}
  107|       |
  108|       |impl TryFrom<&FbHostFunctionDefinition<'_>> for HostFunctionDefinition {
  109|       |    type Error = Error;
  110|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  111|     75|    fn try_from(value: &FbHostFunctionDefinition) -> Result<Self> {
  112|       |        let function_name = value.function_name().to_string();
  113|      0|        let return_type = value.return_type().try_into().map_err(|_| {
  114|      0|            anyhow!(
  115|      0|                "Failed to convert return type for function {}",
  116|      0|                function_name
  117|      0|            )
  118|      0|        })?;
  119|       |        let parameter_types = match value.parameters() {
  120|       |            Some(pvt) => {
  121|       |                let len = pvt.len();
  122|       |                let mut pv: Vec<ParameterType> = Vec::with_capacity(len);
  123|       |                for fb_pvt in pvt {
  124|      0|                    let pvt: ParameterType = fb_pvt.try_into().map_err(|_| {
  125|      0|                        anyhow!(
  126|      0|                            "Failed to convert parameter type for function {}",
  127|      0|                            function_name
  128|      0|                        )
  129|      0|                    })?;
  130|       |                    pv.push(pvt);
  131|       |                }
  132|       |                Some(pv)
  133|       |            }
  134|       |            None => None,
  135|       |        };
  136|       |
  137|       |        Ok(Self::new(function_name, parameter_types, return_type))
  138|     75|    }
  139|       |}
  140|       |
  141|       |impl TryFrom<&[u8]> for HostFunctionDefinition {
  142|       |    type Error = Error;
  143|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  144|      0|    fn try_from(value: &[u8]) -> Result<Self> {
  145|       |        let fb_host_function_definition = flatbuffers::root::<FbHostFunctionDefinition<'_>>(value)
  146|      0|            .map_err(|e| anyhow!("Error while reading HostFunctionDefinition: {:?}", e))?;
  147|       |        Self::try_from(&fb_host_function_definition)
  148|      0|    }
  149|       |}
  150|       |
  151|       |impl TryFrom<&HostFunctionDefinition> for Vec<u8> {
  152|       |    type Error = Error;
  153|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
  154|      0|    fn try_from(hfd: &HostFunctionDefinition) -> Result<Vec<u8>> {
  155|       |        let mut builder = flatbuffers::FlatBufferBuilder::new();
  156|       |        let host_function_definition = hfd.convert_to_flatbuffer_def(&mut builder)?;
  157|       |        builder.finish_size_prefixed(host_function_definition, None);
  158|       |        Ok(builder.finished_data().to_vec())
  159|      0|    }
  160|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/host_function_details.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use alloc::vec::Vec;
   18|       |
   19|       |use anyhow::{Error, Result};
   20|       |use flatbuffers::{WIPOffset, size_prefixed_root};
   21|       |#[cfg(feature = "tracing")]
   22|       |use tracing::{Span, instrument};
   23|       |
   24|       |use super::host_function_definition::HostFunctionDefinition;
   25|       |use crate::flatbuffers::hyperlight::generated::{
   26|       |    HostFunctionDefinition as FbHostFunctionDefinition,
   27|       |    HostFunctionDetails as FbHostFunctionDetails,
   28|       |    HostFunctionDetailsArgs as FbHostFunctionDetailsArgs,
   29|       |};
   30|       |
   31|       |/// `HostFunctionDetails` represents the set of functions that the host exposes to the guest.
   32|       |#[derive(Debug, Default, Clone)]
   33|       |pub struct HostFunctionDetails {
   34|       |    /// The host functions.
   35|       |    pub host_functions: Option<Vec<HostFunctionDefinition>>,
   36|       |}
   37|       |
   38|       |impl TryFrom<&[u8]> for HostFunctionDetails {
   39|       |    type Error = Error;
   40|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   41|     71|    fn try_from(value: &[u8]) -> Result<Self> {
   42|       |        let host_function_details_fb = size_prefixed_root::<FbHostFunctionDetails>(value)
   43|      0|            .map_err(|e| anyhow::anyhow!("Error while reading HostFunctionDetails: {:?}", e))?;
   44|       |
   45|       |        let host_function_definitions = match host_function_details_fb.functions() {
   46|       |            Some(hfd) => {
   47|       |                let len = hfd.len();
   48|       |                let mut vec_hfd: Vec<HostFunctionDefinition> = Vec::with_capacity(len);
   49|       |                for i in 0..len {
   50|       |                    let fb_host_function_definition = hfd.get(i);
   51|       |                    let hfdef = HostFunctionDefinition::try_from(&fb_host_function_definition)?;
   52|       |                    vec_hfd.push(hfdef);
   53|       |                }
   54|       |
   55|       |                Some(vec_hfd)
   56|       |            }
   57|       |
   58|       |            None => None,
   59|       |        };
   60|       |
   61|       |        Ok(Self {
   62|       |            host_functions: host_function_definitions,
   63|       |        })
   64|     71|    }
   65|       |}
   66|       |
   67|       |impl TryFrom<&HostFunctionDetails> for Vec<u8> {
   68|       |    type Error = Error;
   69|       |    #[cfg_attr(feature = "tracing", instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace"))]
   70|    142|    fn try_from(value: &HostFunctionDetails) -> Result<Vec<u8>> {
   71|       |        let mut builder = flatbuffers::FlatBufferBuilder::new();
   72|       |        let vec_host_function_definitions = match &value.host_functions {
   73|       |            Some(vec_hfd) => {
   74|       |                let num_items = vec_hfd.len();
   75|       |                let mut host_function_definitions: Vec<WIPOffset<FbHostFunctionDefinition>> =
   76|       |                    Vec::with_capacity(num_items);
   77|       |
   78|       |                for hfd in vec_hfd {
   79|       |                    let host_function_definition = hfd.convert_to_flatbuffer_def(&mut builder)?;
   80|       |                    host_function_definitions.push(host_function_definition);
   81|       |                }
   82|       |
   83|       |                Some(host_function_definitions)
   84|       |            }
   85|       |            None => None,
   86|       |        };
   87|       |
   88|       |        let fb_host_function_definitions =
   89|    142|            vec_host_function_definitions.map(|v| builder.create_vector(&v));
   90|       |
   91|       |        let host_function_details = FbHostFunctionDetails::create(
   92|       |            &mut builder,
   93|       |            &FbHostFunctionDetailsArgs {
   94|       |                functions: fb_host_function_definitions,
   95|       |            },
   96|       |        );
   97|       |        builder.finish_size_prefixed(host_function_details, None);
   98|       |        let res = builder.finished_data().to_vec();
   99|       |
  100|       |        Ok(res)
  101|    142|    }
  102|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffer_wrappers/util.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use alloc::vec::Vec;
   18|       |
   19|       |use flatbuffers::FlatBufferBuilder;
   20|       |
   21|       |use crate::flatbuffer_wrappers::function_types::ParameterValue;
   22|       |use crate::flatbuffers::hyperlight::generated::{
   23|       |    FunctionCallResult as FbFunctionCallResult, FunctionCallResultArgs as FbFunctionCallResultArgs,
   24|       |    ReturnValue as FbReturnValue, hlbool as Fbhlbool, hlboolArgs as FbhlboolArgs,
   25|       |    hldouble as Fbhldouble, hldoubleArgs as FbhldoubleArgs, hlfloat as Fbhlfloat,
   26|       |    hlfloatArgs as FbhlfloatArgs, hlint as Fbhlint, hlintArgs as FbhlintArgs, hllong as Fbhllong,
   27|       |    hllongArgs as FbhllongArgs, hlsizeprefixedbuffer as Fbhlsizeprefixedbuffer,
   28|       |    hlsizeprefixedbufferArgs as FbhlsizeprefixedbufferArgs, hlstring as Fbhlstring,
   29|       |    hlstringArgs as FbhlstringArgs, hluint as Fbhluint, hluintArgs as FbhluintArgs,
   30|       |    hlulong as Fbhlulong, hlulongArgs as FbhlulongArgs, hlvoid as Fbhlvoid,
   31|       |    hlvoidArgs as FbhlvoidArgs,
   32|       |};
   33|       |
   34|       |/// Flatbuffer-encodes the given value
   35|      0|pub fn get_flatbuffer_result<T: FlatbufferSerializable>(val: T) -> Vec<u8> {
   36|      0|    let mut builder = FlatBufferBuilder::new();
   37|      0|    let res = &T::serialize(&val, &mut builder);
   38|      0|    let result_offset = FbFunctionCallResult::create(&mut builder, res);
   39|      0|
   40|      0|    builder.finish_size_prefixed(result_offset, None);
   41|      0|
   42|      0|    builder.finished_data().to_vec()
   43|      0|}
   44|       |
   45|       |pub trait FlatbufferSerializable {
   46|       |    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs;
   47|       |}
   48|       |
   49|       |// Implementations for basic types below
   50|       |
   51|       |impl FlatbufferSerializable for () {
   52|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
   53|      0|        FbFunctionCallResultArgs {
   54|      0|            return_value: Some(Fbhlvoid::create(builder, &FbhlvoidArgs {}).as_union_value()),
   55|      0|            return_value_type: FbReturnValue::hlvoid,
   56|      0|        }
   57|      0|    }
   58|       |}
   59|       |
   60|       |impl FlatbufferSerializable for &str {
   61|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
   62|      0|        let string_offset = builder.create_string(self);
   63|      0|        FbFunctionCallResultArgs {
   64|      0|            return_value: Some(
   65|      0|                Fbhlstring::create(
   66|      0|                    builder,
   67|      0|                    &FbhlstringArgs {
   68|      0|                        value: Some(string_offset),
   69|      0|                    },
   70|      0|                )
   71|      0|                .as_union_value(),
   72|      0|            ),
   73|      0|            return_value_type: FbReturnValue::hlstring,
   74|      0|        }
   75|      0|    }
   76|       |}
   77|       |
   78|       |impl FlatbufferSerializable for &[u8] {
   79|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
   80|      0|        let vec_offset = builder.create_vector(self);
   81|      0|        FbFunctionCallResultArgs {
   82|      0|            return_value: Some(
   83|      0|                Fbhlsizeprefixedbuffer::create(
   84|      0|                    builder,
   85|      0|                    &FbhlsizeprefixedbufferArgs {
   86|      0|                        size: self.len() as i32,
   87|      0|                        value: Some(vec_offset),
   88|      0|                    },
   89|      0|                )
   90|      0|                .as_union_value(),
   91|      0|            ),
   92|      0|            return_value_type: FbReturnValue::hlsizeprefixedbuffer,
   93|      0|        }
   94|      0|    }
   95|       |}
   96|       |
   97|       |impl FlatbufferSerializable for f32 {
   98|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
   99|      0|        FbFunctionCallResultArgs {
  100|      0|            return_value: Some(
  101|      0|                Fbhlfloat::create(builder, &FbhlfloatArgs { value: *self }).as_union_value(),
  102|      0|            ),
  103|      0|            return_value_type: FbReturnValue::hlfloat,
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |impl FlatbufferSerializable for f64 {
  109|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
  110|      0|        FbFunctionCallResultArgs {
  111|      0|            return_value: Some(
  112|      0|                Fbhldouble::create(builder, &FbhldoubleArgs { value: *self }).as_union_value(),
  113|      0|            ),
  114|      0|            return_value_type: FbReturnValue::hldouble,
  115|      0|        }
  116|      0|    }
  117|       |}
  118|       |
  119|       |impl FlatbufferSerializable for i32 {
  120|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
  121|      0|        FbFunctionCallResultArgs {
  122|      0|            return_value: Some(
  123|      0|                Fbhlint::create(builder, &FbhlintArgs { value: *self }).as_union_value(),
  124|      0|            ),
  125|      0|            return_value_type: FbReturnValue::hlint,
  126|      0|        }
  127|      0|    }
  128|       |}
  129|       |
  130|       |impl FlatbufferSerializable for i64 {
  131|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
  132|      0|        FbFunctionCallResultArgs {
  133|      0|            return_value: Some(
  134|      0|                Fbhllong::create(builder, &FbhllongArgs { value: *self }).as_union_value(),
  135|      0|            ),
  136|      0|            return_value_type: FbReturnValue::hllong,
  137|      0|        }
  138|      0|    }
  139|       |}
  140|       |
  141|       |impl FlatbufferSerializable for u32 {
  142|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
  143|      0|        FbFunctionCallResultArgs {
  144|      0|            return_value: Some(
  145|      0|                Fbhluint::create(builder, &FbhluintArgs { value: *self }).as_union_value(),
  146|      0|            ),
  147|      0|            return_value_type: FbReturnValue::hluint,
  148|      0|        }
  149|      0|    }
  150|       |}
  151|       |
  152|       |impl FlatbufferSerializable for u64 {
  153|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
  154|      0|        FbFunctionCallResultArgs {
  155|      0|            return_value: Some(
  156|      0|                Fbhlulong::create(builder, &FbhlulongArgs { value: *self }).as_union_value(),
  157|      0|            ),
  158|      0|            return_value_type: FbReturnValue::hlulong,
  159|      0|        }
  160|      0|    }
  161|       |}
  162|       |
  163|       |impl FlatbufferSerializable for bool {
  164|      0|    fn serialize(&self, builder: &mut FlatBufferBuilder) -> FbFunctionCallResultArgs {
  165|      0|        FbFunctionCallResultArgs {
  166|      0|            return_value: Some(
  167|      0|                Fbhlbool::create(builder, &FbhlboolArgs { value: *self }).as_union_value(),
  168|      0|            ),
  169|      0|            return_value_type: FbReturnValue::hlbool,
  170|      0|        }
  171|      0|    }
  172|       |}
  173|       |
  174|       |/// Estimates the required buffer capacity for encoding a FunctionCall with the given parameters.
  175|       |/// This helps avoid reallocation during FlatBuffer encoding when passing large slices and strings.
  176|       |///
  177|       |/// The function aims to be lightweight and fast and run in O(1) as long as the number of parameters is limited
  178|       |/// (which it is since hyperlight only currently supports up to 12).
  179|       |///
  180|       |/// Note: This estimates the capacity needed for the inner vec inside a FlatBufferBuilder. It does not
  181|       |/// necessarily match the size of the final encoded buffer. The estimation always rounds up to the
  182|       |/// nearest power of two to match FlatBufferBuilder's allocation strategy.
  183|       |///
  184|       |/// The estimations are numbers used are empirically derived based on the tests below and vaguely based
  185|       |/// on https://flatbuffers.dev/internals/ and https://github.com/dvidelabs/flatcc/blob/f064cefb2034d1e7407407ce32a6085c322212a7/doc/binary-format.md#flatbuffers-binary-format
  186|       |#[inline] // allow cross-crate inlining (for hyperlight-host calls)
  187|      0|pub fn estimate_flatbuffer_capacity(function_name: &str, args: &[ParameterValue]) -> usize {
  188|      0|    let mut estimated_capacity = 20;
  189|      0|
  190|      0|    // Function name overhead
  191|      0|    estimated_capacity += function_name.len() + 12;
  192|      0|
  193|      0|    // Parameters vector overhead
  194|      0|    estimated_capacity += 12 + args.len() * 6;
  195|       |
  196|       |    // Per-parameter overhead
  197|      0|    for arg in args {
  198|      0|        estimated_capacity += 16; // Base parameter structure
  199|      0|        estimated_capacity += match arg {
  200|      0|            ParameterValue::String(s) => s.len() + 20,
  201|      0|            ParameterValue::VecBytes(v) => v.len() + 20,
  202|      0|            ParameterValue::Int(_) | ParameterValue::UInt(_) => 16,
  203|      0|            ParameterValue::Long(_) | ParameterValue::ULong(_) => 20,
  204|      0|            ParameterValue::Float(_) => 16,
  205|      0|            ParameterValue::Double(_) => 20,
  206|      0|            ParameterValue::Bool(_) => 12,
  207|       |        };
  208|       |    }
  209|       |
  210|       |    // match how vec grows
  211|      0|    estimated_capacity.next_power_of_two()
  212|      0|}
  213|       |
  214|       |#[cfg(test)]
  215|       |mod tests {
  216|       |    use alloc::string::ToString;
  217|       |    use alloc::vec;
  218|       |    use alloc::vec::Vec;
  219|       |
  220|       |    use super::*;
  221|       |    use crate::flatbuffer_wrappers::function_call::{FunctionCall, FunctionCallType};
  222|       |    use crate::flatbuffer_wrappers::function_types::{ParameterValue, ReturnType};
  223|       |
  224|       |    /// Helper function to check that estimation is within reasonable bounds (25%)
  225|       |    fn assert_estimation_accuracy(
  226|       |        function_name: &str,
  227|       |        args: Vec<ParameterValue>,
  228|       |        call_type: FunctionCallType,
  229|       |        return_type: ReturnType,
  230|       |    ) {
  231|       |        let estimated = estimate_flatbuffer_capacity(function_name, &args);
  232|       |
  233|       |        let fc = FunctionCall::new(
  234|       |            function_name.to_string(),
  235|       |            Some(args),
  236|       |            call_type.clone(),
  237|       |            return_type,
  238|       |        );
  239|       |        // Important that this FlatBufferBuilder is created with capacity 0 so it grows to its needed capacity
  240|       |        let mut builder = FlatBufferBuilder::new();
  241|       |        let _buffer = fc.encode(&mut builder);
  242|       |        let actual = builder.collapse().0.capacity();
  243|       |
  244|       |        let lower_bound = (actual as f64 * 0.75) as usize;
  245|       |        let upper_bound = (actual as f64 * 1.25) as usize;
  246|       |
  247|       |        assert!(
  248|       |            estimated >= lower_bound && estimated <= upper_bound,
  249|       |            "Estimation {} outside bounds [{}, {}] for actual size {} (function: {}, call_type: {:?}, return_type: {:?})",
  250|       |            estimated,
  251|       |            lower_bound,
  252|       |            upper_bound,
  253|       |            actual,
  254|       |            function_name,
  255|       |            call_type,
  256|       |            return_type
  257|       |        );
  258|       |    }
  259|       |
  260|       |    #[test]
  261|       |    fn test_estimate_no_parameters() {
  262|       |        assert_estimation_accuracy(
  263|       |            "simple_function",
  264|       |            vec![],
  265|       |            FunctionCallType::Guest,
  266|       |            ReturnType::Void,
  267|       |        );
  268|       |    }
  269|       |
  270|       |    #[test]
  271|       |    fn test_estimate_single_int_parameter() {
  272|       |        assert_estimation_accuracy(
  273|       |            "add_one",
  274|       |            vec![ParameterValue::Int(42)],
  275|       |            FunctionCallType::Guest,
  276|       |            ReturnType::Int,
  277|       |        );
  278|       |    }
  279|       |
  280|       |    #[test]
  281|       |    fn test_estimate_multiple_scalar_parameters() {
  282|       |        assert_estimation_accuracy(
  283|       |            "calculate",
  284|       |            vec![
  285|       |                ParameterValue::Int(10),
  286|       |                ParameterValue::UInt(20),
  287|       |                ParameterValue::Long(30),
  288|       |                ParameterValue::ULong(40),
  289|       |                ParameterValue::Float(1.5),
  290|       |                ParameterValue::Double(2.5),
  291|       |                ParameterValue::Bool(true),
  292|       |            ],
  293|       |            FunctionCallType::Guest,
  294|       |            ReturnType::Double,
  295|       |        );
  296|       |    }
  297|       |
  298|       |    #[test]
  299|       |    fn test_estimate_string_parameters() {
  300|       |        assert_estimation_accuracy(
  301|       |            "process_strings",
  302|       |            vec![
  303|       |                ParameterValue::String("hello".to_string()),
  304|       |                ParameterValue::String("world".to_string()),
  305|       |                ParameterValue::String("this is a longer string for testing".to_string()),
  306|       |            ],
  307|       |            FunctionCallType::Host,
  308|       |            ReturnType::String,
  309|       |        );
  310|       |    }
  311|       |
  312|       |    #[test]
  313|       |    fn test_estimate_very_long_string() {
  314|       |        let long_string = "a".repeat(1000);
  315|       |        assert_estimation_accuracy(
  316|       |            "process_long_string",
  317|       |            vec![ParameterValue::String(long_string)],
  318|       |            FunctionCallType::Guest,
  319|       |            ReturnType::String,
  320|       |        );
  321|       |    }
  322|       |
  323|       |    #[test]
  324|       |    fn test_estimate_vector_parameters() {
  325|       |        assert_estimation_accuracy(
  326|       |            "process_vectors",
  327|       |            vec![
  328|       |                ParameterValue::VecBytes(vec![1, 2, 3, 4, 5]),
  329|       |                ParameterValue::VecBytes(vec![]),
  330|       |                ParameterValue::VecBytes(vec![0; 100]),
  331|       |            ],
  332|       |            FunctionCallType::Host,
  333|       |            ReturnType::VecBytes,
  334|       |        );
  335|       |    }
  336|       |
  337|       |    #[test]
  338|       |    fn test_estimate_mixed_parameters() {
  339|       |        assert_estimation_accuracy(
  340|       |            "complex_function",
  341|       |            vec![
  342|       |                ParameterValue::String("test".to_string()),
  343|       |                ParameterValue::Int(42),
  344|       |                ParameterValue::VecBytes(vec![1, 2, 3, 4, 5]),
  345|       |                ParameterValue::Bool(true),
  346|       |                ParameterValue::Double(553.14159),
  347|       |                ParameterValue::String("another string".to_string()),
  348|       |                ParameterValue::Long(9223372036854775807),
  349|       |            ],
  350|       |            FunctionCallType::Guest,
  351|       |            ReturnType::VecBytes,
  352|       |        );
  353|       |    }
  354|       |
  355|       |    #[test]
  356|       |    fn test_estimate_large_function_name() {
  357|       |        let long_name = "very_long_function_name_that_exceeds_normal_lengths_for_testing_purposes";
  358|       |        assert_estimation_accuracy(
  359|       |            long_name,
  360|       |            vec![ParameterValue::Int(1)],
  361|       |            FunctionCallType::Host,
  362|       |            ReturnType::Long,
  363|       |        );
  364|       |    }
  365|       |
  366|       |    #[test]
  367|       |    fn test_estimate_large_vector() {
  368|       |        let large_vector = vec![42u8; 10000];
  369|       |        assert_estimation_accuracy(
  370|       |            "process_large_data",
  371|       |            vec![ParameterValue::VecBytes(large_vector)],
  372|       |            FunctionCallType::Guest,
  373|       |            ReturnType::Bool,
  374|       |        );
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_estimate_all_parameter_types() {
  379|       |        assert_estimation_accuracy(
  380|       |            "comprehensive_test",
  381|       |            vec![
  382|       |                ParameterValue::Int(i32::MIN),
  383|       |                ParameterValue::UInt(u32::MAX),
  384|       |                ParameterValue::Long(i64::MIN),
  385|       |                ParameterValue::ULong(u64::MAX),
  386|       |                ParameterValue::Float(f32::MIN),
  387|       |                ParameterValue::Double(f64::MAX),
  388|       |                ParameterValue::Bool(false),
  389|       |                ParameterValue::String("test string".to_string()),
  390|       |                ParameterValue::VecBytes(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),
  391|       |            ],
  392|       |            FunctionCallType::Host,
  393|       |            ReturnType::ULong,
  394|       |        );
  395|       |    }
  396|       |
  397|       |    #[test]
  398|       |    fn test_different_function_call_types() {
  399|       |        assert_estimation_accuracy(
  400|       |            "guest_function",
  401|       |            vec![ParameterValue::String("guest call".to_string())],
  402|       |            FunctionCallType::Guest,
  403|       |            ReturnType::String,
  404|       |        );
  405|       |
  406|       |        assert_estimation_accuracy(
  407|       |            "host_function",
  408|       |            vec![ParameterValue::String("host call".to_string())],
  409|       |            FunctionCallType::Host,
  410|       |            ReturnType::String,
  411|       |        );
  412|       |    }
  413|       |
  414|       |    #[test]
  415|       |    fn test_different_return_types() {
  416|       |        let args = vec![
  417|       |            ParameterValue::Int(42),
  418|       |            ParameterValue::String("test".to_string()),
  419|       |        ];
  420|       |
  421|       |        let void_est = estimate_flatbuffer_capacity("test_void", &args);
  422|       |        let int_est = estimate_flatbuffer_capacity("test_int", &args);
  423|       |        let string_est = estimate_flatbuffer_capacity("test_string", &args);
  424|       |
  425|       |        assert!((void_est as i32 - int_est as i32).abs() < 10);
  426|       |        assert!((int_est as i32 - string_est as i32).abs() < 10);
  427|       |
  428|       |        assert_estimation_accuracy(
  429|       |            "test_void",
  430|       |            args.clone(),
  431|       |            FunctionCallType::Guest,
  432|       |            ReturnType::Void,
  433|       |        );
  434|       |        assert_estimation_accuracy(
  435|       |            "test_int",
  436|       |            args.clone(),
  437|       |            FunctionCallType::Guest,
  438|       |            ReturnType::Int,
  439|       |        );
  440|       |        assert_estimation_accuracy(
  441|       |            "test_string",
  442|       |            args,
  443|       |            FunctionCallType::Guest,
  444|       |            ReturnType::String,
  445|       |        );
  446|       |    }
  447|       |
  448|       |    #[test]
  449|       |    fn test_estimate_many_large_vectors_and_strings() {
  450|       |        assert_estimation_accuracy(
  451|       |            "process_bulk_data",
  452|       |            vec![
  453|       |                ParameterValue::String("Large string data: ".to_string() + &"x".repeat(2000)),
  454|       |                ParameterValue::VecBytes(vec![1u8; 5000]),
  455|       |                ParameterValue::String(
  456|       |                    "Another large string with lots of content ".to_string() + &"y".repeat(3000),
  457|       |                ),
  458|       |                ParameterValue::VecBytes(vec![255u8; 7500]),
  459|       |                ParameterValue::String(
  460|       |                    "Third massive string parameter ".to_string() + &"z".repeat(1500),
  461|       |                ),
  462|       |                ParameterValue::VecBytes(vec![128u8; 10000]),
  463|       |                ParameterValue::Int(42),
  464|       |                ParameterValue::String("Final large string ".to_string() + &"a".repeat(4000)),
  465|       |                ParameterValue::VecBytes(vec![64u8; 2500]),
  466|       |                ParameterValue::Bool(true),
  467|       |            ],
  468|       |            FunctionCallType::Host,
  469|       |            ReturnType::VecBytes,
  470|       |        );
  471|       |    }
  472|       |
  473|       |    #[test]
  474|       |    fn test_estimate_twenty_parameters() {
  475|       |        assert_estimation_accuracy(
  476|       |            "function_with_many_parameters",
  477|       |            vec![
  478|       |                ParameterValue::Int(1),
  479|       |                ParameterValue::String("param2".to_string()),
  480|       |                ParameterValue::Bool(true),
  481|       |                ParameterValue::Float(3213.14),
  482|       |                ParameterValue::VecBytes(vec![1, 2, 3]),
  483|       |                ParameterValue::Long(1000000),
  484|       |                ParameterValue::Double(322.718),
  485|       |                ParameterValue::UInt(42),
  486|       |                ParameterValue::String("param9".to_string()),
  487|       |                ParameterValue::Bool(false),
  488|       |                ParameterValue::ULong(9999999999),
  489|       |                ParameterValue::VecBytes(vec![4, 5, 6, 7, 8]),
  490|       |                ParameterValue::Int(-100),
  491|       |                ParameterValue::Float(1.414),
  492|       |                ParameterValue::String("param15".to_string()),
  493|       |                ParameterValue::Double(1.732),
  494|       |                ParameterValue::Bool(true),
  495|       |                ParameterValue::VecBytes(vec![9, 10]),
  496|       |                ParameterValue::Long(-5000000),
  497|       |                ParameterValue::UInt(12345),
  498|       |            ],
  499|       |            FunctionCallType::Guest,
  500|       |            ReturnType::Int,
  501|       |        );
  502|       |    }
  503|       |
  504|       |    #[test]
  505|       |    fn test_estimate_megabyte_parameters() {
  506|       |        assert_estimation_accuracy(
  507|       |            "process_megabyte_data",
  508|       |            vec![
  509|       |                ParameterValue::String("MB String 1: ".to_string() + &"x".repeat(1_048_576)), // 1MB string
  510|       |                ParameterValue::VecBytes(vec![42u8; 2_097_152]), // 2MB vector
  511|       |                ParameterValue::String("MB String 2: ".to_string() + &"y".repeat(1_572_864)), // 1.5MB string
  512|       |                ParameterValue::VecBytes(vec![128u8; 3_145_728]), // 3MB vector
  513|       |                ParameterValue::String("MB String 3: ".to_string() + &"z".repeat(2_097_152)), // 2MB string
  514|       |            ],
  515|       |            FunctionCallType::Host,
  516|       |            ReturnType::VecBytes,
  517|       |        );
  518|       |    }
  519|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/error_code_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_ERROR_CODE: u64 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_ERROR_CODE: u64 = 16;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_ERROR_CODE: [ErrorCode; 16] = [
   29|       |    ErrorCode::NoError,
   30|       |    ErrorCode::UnsupportedParameterType,
   31|       |    ErrorCode::GuestFunctionNameNotProvided,
   32|       |    ErrorCode::GuestFunctionNotFound,
   33|       |    ErrorCode::GuestFunctionIncorrecNoOfParameters,
   34|       |    ErrorCode::GispatchFunctionPointerNotSet,
   35|       |    ErrorCode::OutbError,
   36|       |    ErrorCode::UnknownError,
   37|       |    ErrorCode::StackOverflow,
   38|       |    ErrorCode::GsCheckFailed,
   39|       |    ErrorCode::TooManyGuestFunctions,
   40|       |    ErrorCode::FailureInDlmalloc,
   41|       |    ErrorCode::MallocFailed,
   42|       |    ErrorCode::GuestFunctionParameterTypeMismatch,
   43|       |    ErrorCode::GuestError,
   44|       |    ErrorCode::ArrayLengthParamIsMissing,
   45|       |];
   46|       |
   47|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   48|       |#[repr(transparent)]
   49|       |pub struct ErrorCode(pub u64);
   50|       |#[allow(non_upper_case_globals)]
   51|       |impl ErrorCode {
   52|       |    pub const NoError: Self = Self(0);
   53|       |    pub const UnsupportedParameterType: Self = Self(2);
   54|       |    pub const GuestFunctionNameNotProvided: Self = Self(3);
   55|       |    pub const GuestFunctionNotFound: Self = Self(4);
   56|       |    pub const GuestFunctionIncorrecNoOfParameters: Self = Self(5);
   57|       |    pub const GispatchFunctionPointerNotSet: Self = Self(6);
   58|       |    pub const OutbError: Self = Self(7);
   59|       |    pub const UnknownError: Self = Self(8);
   60|       |    pub const StackOverflow: Self = Self(9);
   61|       |    pub const GsCheckFailed: Self = Self(10);
   62|       |    pub const TooManyGuestFunctions: Self = Self(11);
   63|       |    pub const FailureInDlmalloc: Self = Self(12);
   64|       |    pub const MallocFailed: Self = Self(13);
   65|       |    pub const GuestFunctionParameterTypeMismatch: Self = Self(14);
   66|       |    pub const GuestError: Self = Self(15);
   67|       |    pub const ArrayLengthParamIsMissing: Self = Self(16);
   68|       |
   69|       |    pub const ENUM_MIN: u64 = 0;
   70|       |    pub const ENUM_MAX: u64 = 16;
   71|       |    pub const ENUM_VALUES: &'static [Self] = &[
   72|       |        Self::NoError,
   73|       |        Self::UnsupportedParameterType,
   74|       |        Self::GuestFunctionNameNotProvided,
   75|       |        Self::GuestFunctionNotFound,
   76|       |        Self::GuestFunctionIncorrecNoOfParameters,
   77|       |        Self::GispatchFunctionPointerNotSet,
   78|       |        Self::OutbError,
   79|       |        Self::UnknownError,
   80|       |        Self::StackOverflow,
   81|       |        Self::GsCheckFailed,
   82|       |        Self::TooManyGuestFunctions,
   83|       |        Self::FailureInDlmalloc,
   84|       |        Self::MallocFailed,
   85|       |        Self::GuestFunctionParameterTypeMismatch,
   86|       |        Self::GuestError,
   87|       |        Self::ArrayLengthParamIsMissing,
   88|       |    ];
   89|       |    /// Returns the variant's name or "" if unknown.
   90|      0|    pub fn variant_name(self) -> Option<&'static str> {
   91|      0|        match self {
   92|      0|            Self::NoError => Some("NoError"),
   93|      0|            Self::UnsupportedParameterType => Some("UnsupportedParameterType"),
   94|      0|            Self::GuestFunctionNameNotProvided => Some("GuestFunctionNameNotProvided"),
   95|      0|            Self::GuestFunctionNotFound => Some("GuestFunctionNotFound"),
   96|       |            Self::GuestFunctionIncorrecNoOfParameters => {
   97|      0|                Some("GuestFunctionIncorrecNoOfParameters")
   98|       |            }
   99|      0|            Self::GispatchFunctionPointerNotSet => Some("GispatchFunctionPointerNotSet"),
  100|      0|            Self::OutbError => Some("OutbError"),
  101|      0|            Self::UnknownError => Some("UnknownError"),
  102|      0|            Self::StackOverflow => Some("StackOverflow"),
  103|      0|            Self::GsCheckFailed => Some("GsCheckFailed"),
  104|      0|            Self::TooManyGuestFunctions => Some("TooManyGuestFunctions"),
  105|      0|            Self::FailureInDlmalloc => Some("FailureInDlmalloc"),
  106|      0|            Self::MallocFailed => Some("MallocFailed"),
  107|      0|            Self::GuestFunctionParameterTypeMismatch => Some("GuestFunctionParameterTypeMismatch"),
  108|      0|            Self::GuestError => Some("GuestError"),
  109|      0|            Self::ArrayLengthParamIsMissing => Some("ArrayLengthParamIsMissing"),
  110|      0|            _ => None,
  111|       |        }
  112|      0|    }
  113|       |}
  114|       |impl core::fmt::Debug for ErrorCode {
  115|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
  116|      0|        if let Some(name) = self.variant_name() {
  117|      0|            f.write_str(name)
  118|       |        } else {
  119|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
  120|       |        }
  121|      0|    }
  122|       |}
  123|       |impl<'a> flatbuffers::Follow<'a> for ErrorCode {
  124|       |    type Inner = Self;
  125|       |    #[inline]
  126|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
  127|      0|        let b = flatbuffers::read_scalar_at::<u64>(buf, loc);
  128|      0|        Self(b)
  129|      0|    }
  130|       |}
  131|       |
  132|       |impl flatbuffers::Push for ErrorCode {
  133|       |    type Output = ErrorCode;
  134|       |    #[inline]
  135|      0|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
  136|      0|        flatbuffers::emplace_scalar::<u64>(dst, self.0);
  137|      0|    }
  138|       |}
  139|       |
  140|       |impl flatbuffers::EndianScalar for ErrorCode {
  141|       |    type Scalar = u64;
  142|       |    #[inline]
  143|      0|    fn to_little_endian(self) -> u64 {
  144|      0|        self.0.to_le()
  145|      0|    }
  146|       |    #[inline]
  147|       |    #[allow(clippy::wrong_self_convention)]
  148|      0|    fn from_little_endian(v: u64) -> Self {
  149|      0|        let b = u64::from_le(v);
  150|      0|        Self(b)
  151|      0|    }
  152|       |}
  153|       |
  154|       |impl<'a> flatbuffers::Verifiable for ErrorCode {
  155|       |    #[inline]
  156|      0|    fn run_verifier(
  157|      0|        v: &mut flatbuffers::Verifier,
  158|      0|        pos: usize,
  159|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  160|       |        use self::flatbuffers::Verifiable;
  161|      0|        u64::run_verifier(v, pos)
  162|      0|    }
  163|       |}
  164|       |
  165|       |impl flatbuffers::SimpleToVerifyInSlice for ErrorCode {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/function_call_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum FunctionCallOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct FunctionCall<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for FunctionCall<'a> {
   21|       |    type Inner = FunctionCall<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> FunctionCall<'a> {
   31|       |    pub const VT_FUNCTION_NAME: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
   33|       |    pub const VT_FUNCTION_CALL_TYPE: flatbuffers::VOffsetT = 8;
   34|       |    pub const VT_EXPECTED_RETURN_TYPE: flatbuffers::VOffsetT = 10;
   35|       |
   36|       |    #[inline]
   37|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   38|      0|        FunctionCall { _tab: table }
   39|      0|    }
   40|       |    #[allow(unused_mut)]
   41|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   42|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   43|      0|        args: &'args FunctionCallArgs<'args>,
   44|      0|    ) -> flatbuffers::WIPOffset<FunctionCall<'bldr>> {
   45|      0|        let mut builder = FunctionCallBuilder::new(_fbb);
   46|      0|        if let Some(x) = args.parameters {
   47|      0|            builder.add_parameters(x);
   48|      0|        }
   49|      0|        if let Some(x) = args.function_name {
   50|      0|            builder.add_function_name(x);
   51|      0|        }
   52|      0|        builder.add_expected_return_type(args.expected_return_type);
   53|      0|        builder.add_function_call_type(args.function_call_type);
   54|      0|        builder.finish()
   55|      0|    }
   56|       |
   57|       |    #[inline]
   58|      0|    pub fn function_name(&self) -> &'a str {
   59|      0|        // Safety:
   60|      0|        // Created from valid Table for this object
   61|      0|        // which contains a valid value in this slot
   62|      0|        unsafe {
   63|      0|            self._tab
   64|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(FunctionCall::VT_FUNCTION_NAME, None)
   65|      0|                .unwrap()
   66|      0|        }
   67|      0|    }
   68|       |    #[inline]
   69|      0|    pub fn key_compare_less_than(&self, o: &FunctionCall) -> bool {
   70|      0|        self.function_name() < o.function_name()
   71|      0|    }
   72|       |
   73|       |    #[inline]
   74|      0|    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
   75|      0|        let key = self.function_name();
   76|      0|        key.cmp(val)
   77|      0|    }
   78|       |    #[inline]
   79|      0|    pub fn parameters(
   80|      0|        &self,
   81|      0|    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Parameter<'a>>>> {
   82|      0|        // Safety:
   83|      0|        // Created from valid Table for this object
   84|      0|        // which contains a valid value in this slot
   85|      0|        unsafe {
   86|      0|            self._tab.get::<flatbuffers::ForwardsUOffset<
   87|      0|                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Parameter>>,
   88|      0|            >>(FunctionCall::VT_PARAMETERS, None)
   89|      0|        }
   90|      0|    }
   91|       |    #[inline]
   92|      0|    pub fn function_call_type(&self) -> FunctionCallType {
   93|      0|        // Safety:
   94|      0|        // Created from valid Table for this object
   95|      0|        // which contains a valid value in this slot
   96|      0|        unsafe {
   97|      0|            self._tab
   98|      0|                .get::<FunctionCallType>(
   99|      0|                    FunctionCall::VT_FUNCTION_CALL_TYPE,
  100|      0|                    Some(FunctionCallType::none),
  101|      0|                )
  102|      0|                .unwrap()
  103|      0|        }
  104|      0|    }
  105|       |    #[inline]
  106|      0|    pub fn expected_return_type(&self) -> ReturnType {
  107|      0|        // Safety:
  108|      0|        // Created from valid Table for this object
  109|      0|        // which contains a valid value in this slot
  110|      0|        unsafe {
  111|      0|            self._tab
  112|      0|                .get::<ReturnType>(
  113|      0|                    FunctionCall::VT_EXPECTED_RETURN_TYPE,
  114|      0|                    Some(ReturnType::hlint),
  115|      0|                )
  116|      0|                .unwrap()
  117|      0|        }
  118|      0|    }
  119|       |}
  120|       |
  121|       |impl flatbuffers::Verifiable for FunctionCall<'_> {
  122|       |    #[inline]
  123|      0|    fn run_verifier(
  124|      0|        v: &mut flatbuffers::Verifier,
  125|      0|        pos: usize,
  126|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  127|       |        use self::flatbuffers::Verifiable;
  128|      0|        v.visit_table(pos)?
  129|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
  130|      0|                "function_name",
  131|      0|                Self::VT_FUNCTION_NAME,
  132|      0|                true,
  133|      0|            )?
  134|      0|            .visit_field::<flatbuffers::ForwardsUOffset<
  135|      0|                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Parameter>>,
  136|      0|            >>("parameters", Self::VT_PARAMETERS, false)?
  137|      0|            .visit_field::<FunctionCallType>(
  138|      0|                "function_call_type",
  139|      0|                Self::VT_FUNCTION_CALL_TYPE,
  140|      0|                false,
  141|      0|            )?
  142|      0|            .visit_field::<ReturnType>(
  143|      0|                "expected_return_type",
  144|      0|                Self::VT_EXPECTED_RETURN_TYPE,
  145|      0|                false,
  146|      0|            )?
  147|      0|            .finish();
  148|      0|        Ok(())
  149|      0|    }
  150|       |}
  151|       |pub struct FunctionCallArgs<'a> {
  152|       |    pub function_name: Option<flatbuffers::WIPOffset<&'a str>>,
  153|       |    pub parameters: Option<
  154|       |        flatbuffers::WIPOffset<
  155|       |            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Parameter<'a>>>,
  156|       |        >,
  157|       |    >,
  158|       |    pub function_call_type: FunctionCallType,
  159|       |    pub expected_return_type: ReturnType,
  160|       |}
  161|       |impl<'a> Default for FunctionCallArgs<'a> {
  162|       |    #[inline]
  163|      0|    fn default() -> Self {
  164|      0|        FunctionCallArgs {
  165|      0|            function_name: None, // required field
  166|      0|            parameters: None,
  167|      0|            function_call_type: FunctionCallType::none,
  168|      0|            expected_return_type: ReturnType::hlint,
  169|      0|        }
  170|      0|    }
  171|       |}
  172|       |
  173|       |pub struct FunctionCallBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  174|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  175|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  176|       |}
  177|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FunctionCallBuilder<'a, 'b, A> {
  178|       |    #[inline]
  179|      0|    pub fn add_function_name(&mut self, function_name: flatbuffers::WIPOffset<&'b str>) {
  180|      0|        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
  181|      0|            FunctionCall::VT_FUNCTION_NAME,
  182|      0|            function_name,
  183|      0|        );
  184|      0|    }
  185|       |    #[inline]
  186|      0|    pub fn add_parameters(
  187|      0|        &mut self,
  188|      0|        parameters: flatbuffers::WIPOffset<
  189|      0|            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Parameter<'b>>>,
  190|      0|        >,
  191|      0|    ) {
  192|      0|        self.fbb_
  193|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(FunctionCall::VT_PARAMETERS, parameters);
  194|      0|    }
  195|       |    #[inline]
  196|      0|    pub fn add_function_call_type(&mut self, function_call_type: FunctionCallType) {
  197|      0|        self.fbb_.push_slot::<FunctionCallType>(
  198|      0|            FunctionCall::VT_FUNCTION_CALL_TYPE,
  199|      0|            function_call_type,
  200|      0|            FunctionCallType::none,
  201|      0|        );
  202|      0|    }
  203|       |    #[inline]
  204|      0|    pub fn add_expected_return_type(&mut self, expected_return_type: ReturnType) {
  205|      0|        self.fbb_.push_slot::<ReturnType>(
  206|      0|            FunctionCall::VT_EXPECTED_RETURN_TYPE,
  207|      0|            expected_return_type,
  208|      0|            ReturnType::hlint,
  209|      0|        );
  210|      0|    }
  211|       |    #[inline]
  212|      0|    pub fn new(
  213|      0|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  214|      0|    ) -> FunctionCallBuilder<'a, 'b, A> {
  215|      0|        let start = _fbb.start_table();
  216|      0|        FunctionCallBuilder {
  217|      0|            fbb_: _fbb,
  218|      0|            start_: start,
  219|      0|        }
  220|      0|    }
  221|       |    #[inline]
  222|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<FunctionCall<'a>> {
  223|      0|        let o = self.fbb_.end_table(self.start_);
  224|      0|        self.fbb_
  225|      0|            .required(o, FunctionCall::VT_FUNCTION_NAME, "function_name");
  226|      0|        flatbuffers::WIPOffset::new(o.value())
  227|      0|    }
  228|       |}
  229|       |
  230|       |impl core::fmt::Debug for FunctionCall<'_> {
  231|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  232|      0|        let mut ds = f.debug_struct("FunctionCall");
  233|      0|        ds.field("function_name", &self.function_name());
  234|      0|        ds.field("parameters", &self.parameters());
  235|      0|        ds.field("function_call_type", &self.function_call_type());
  236|      0|        ds.field("expected_return_type", &self.expected_return_type());
  237|      0|        ds.finish()
  238|      0|    }
  239|       |}
  240|       |#[inline]
  241|       |/// Verifies that a buffer of bytes contains a `FunctionCall`
  242|       |/// and returns it.
  243|       |/// Note that verification is still experimental and may not
  244|       |/// catch every error, or be maximally performant. For the
  245|       |/// previous, unchecked, behavior use
  246|       |/// `root_as_function_call_unchecked`.
  247|      0|pub fn root_as_function_call(buf: &[u8]) -> Result<FunctionCall, flatbuffers::InvalidFlatbuffer> {
  248|      0|    flatbuffers::root::<FunctionCall>(buf)
  249|      0|}
  250|       |#[inline]
  251|       |/// Verifies that a buffer of bytes contains a size prefixed
  252|       |/// `FunctionCall` and returns it.
  253|       |/// Note that verification is still experimental and may not
  254|       |/// catch every error, or be maximally performant. For the
  255|       |/// previous, unchecked, behavior use
  256|       |/// `size_prefixed_root_as_function_call_unchecked`.
  257|      0|pub fn size_prefixed_root_as_function_call(
  258|      0|    buf: &[u8],
  259|      0|) -> Result<FunctionCall, flatbuffers::InvalidFlatbuffer> {
  260|      0|    flatbuffers::size_prefixed_root::<FunctionCall>(buf)
  261|      0|}
  262|       |#[inline]
  263|       |/// Verifies, with the given options, that a buffer of bytes
  264|       |/// contains a `FunctionCall` and returns it.
  265|       |/// Note that verification is still experimental and may not
  266|       |/// catch every error, or be maximally performant. For the
  267|       |/// previous, unchecked, behavior use
  268|       |/// `root_as_function_call_unchecked`.
  269|      0|pub fn root_as_function_call_with_opts<'b, 'o>(
  270|      0|    opts: &'o flatbuffers::VerifierOptions,
  271|      0|    buf: &'b [u8],
  272|      0|) -> Result<FunctionCall<'b>, flatbuffers::InvalidFlatbuffer> {
  273|      0|    flatbuffers::root_with_opts::<FunctionCall<'b>>(opts, buf)
  274|      0|}
  275|       |#[inline]
  276|       |/// Verifies, with the given verifier options, that a buffer of
  277|       |/// bytes contains a size prefixed `FunctionCall` and returns
  278|       |/// it. Note that verification is still experimental and may not
  279|       |/// catch every error, or be maximally performant. For the
  280|       |/// previous, unchecked, behavior use
  281|       |/// `root_as_function_call_unchecked`.
  282|      0|pub fn size_prefixed_root_as_function_call_with_opts<'b, 'o>(
  283|      0|    opts: &'o flatbuffers::VerifierOptions,
  284|      0|    buf: &'b [u8],
  285|      0|) -> Result<FunctionCall<'b>, flatbuffers::InvalidFlatbuffer> {
  286|      0|    flatbuffers::size_prefixed_root_with_opts::<FunctionCall<'b>>(opts, buf)
  287|      0|}
  288|       |#[inline]
  289|       |/// Assumes, without verification, that a buffer of bytes contains a FunctionCall and returns it.
  290|       |/// # Safety
  291|       |/// Callers must trust the given bytes do indeed contain a valid `FunctionCall`.
  292|      0|pub unsafe fn root_as_function_call_unchecked(buf: &[u8]) -> FunctionCall {
  293|      0|    flatbuffers::root_unchecked::<FunctionCall>(buf)
  294|      0|}
  295|       |#[inline]
  296|       |/// Assumes, without verification, that a buffer of bytes contains a size prefixed FunctionCall and returns it.
  297|       |/// # Safety
  298|       |/// Callers must trust the given bytes do indeed contain a valid size prefixed `FunctionCall`.
  299|      0|pub unsafe fn size_prefixed_root_as_function_call_unchecked(buf: &[u8]) -> FunctionCall {
  300|      0|    flatbuffers::size_prefixed_root_unchecked::<FunctionCall>(buf)
  301|      0|}
  302|       |#[inline]
  303|      0|pub fn finish_function_call_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  304|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  305|      0|    root: flatbuffers::WIPOffset<FunctionCall<'a>>,
  306|      0|) {
  307|      0|    fbb.finish(root, None);
  308|      0|}
  309|       |
  310|       |#[inline]
  311|      0|pub fn finish_size_prefixed_function_call_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  312|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  313|      0|    root: flatbuffers::WIPOffset<FunctionCall<'a>>,
  314|      0|) {
  315|      0|    fbb.finish_size_prefixed(root, None);
  316|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/function_call_result_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum FunctionCallResultOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct FunctionCallResult<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for FunctionCallResult<'a> {
   21|       |    type Inner = FunctionCallResult<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> FunctionCallResult<'a> {
   31|       |    pub const VT_RETURN_VALUE_TYPE: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_RETURN_VALUE: flatbuffers::VOffsetT = 6;
   33|       |
   34|       |    #[inline]
   35|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   36|      0|        FunctionCallResult { _tab: table }
   37|      0|    }
   38|       |    #[allow(unused_mut)]
   39|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   40|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   41|      0|        args: &'args FunctionCallResultArgs,
   42|      0|    ) -> flatbuffers::WIPOffset<FunctionCallResult<'bldr>> {
   43|      0|        let mut builder = FunctionCallResultBuilder::new(_fbb);
   44|      0|        if let Some(x) = args.return_value {
   45|      0|            builder.add_return_value(x);
   46|      0|        }
   47|      0|        builder.add_return_value_type(args.return_value_type);
   48|      0|        builder.finish()
   49|      0|    }
   50|       |
   51|       |    #[inline]
   52|      0|    pub fn return_value_type(&self) -> ReturnValue {
   53|      0|        // Safety:
   54|      0|        // Created from valid Table for this object
   55|      0|        // which contains a valid value in this slot
   56|      0|        unsafe {
   57|      0|            self._tab
   58|      0|                .get::<ReturnValue>(
   59|      0|                    FunctionCallResult::VT_RETURN_VALUE_TYPE,
   60|      0|                    Some(ReturnValue::NONE),
   61|      0|                )
   62|      0|                .unwrap()
   63|      0|        }
   64|      0|    }
   65|       |    #[inline]
   66|      0|    pub fn return_value(&self) -> flatbuffers::Table<'a> {
   67|      0|        // Safety:
   68|      0|        // Created from valid Table for this object
   69|      0|        // which contains a valid value in this slot
   70|      0|        unsafe {
   71|      0|            self._tab
   72|      0|                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
   73|      0|                    FunctionCallResult::VT_RETURN_VALUE,
   74|      0|                    None,
   75|      0|                )
   76|      0|                .unwrap()
   77|      0|        }
   78|      0|    }
   79|       |    #[inline]
   80|       |    #[allow(non_snake_case)]
   81|      0|    pub fn return_value_as_hlint(&self) -> Option<hlint<'a>> {
   82|      0|        if self.return_value_type() == ReturnValue::hlint {
   83|      0|            let u = self.return_value();
   84|      0|            // Safety:
   85|      0|            // Created from a valid Table for this object
   86|      0|            // Which contains a valid union in this slot
   87|      0|            Some(unsafe { hlint::init_from_table(u) })
   88|       |        } else {
   89|      0|            None
   90|       |        }
   91|      0|    }
   92|       |
   93|       |    #[inline]
   94|       |    #[allow(non_snake_case)]
   95|      0|    pub fn return_value_as_hluint(&self) -> Option<hluint<'a>> {
   96|      0|        if self.return_value_type() == ReturnValue::hluint {
   97|      0|            let u = self.return_value();
   98|      0|            // Safety:
   99|      0|            // Created from a valid Table for this object
  100|      0|            // Which contains a valid union in this slot
  101|      0|            Some(unsafe { hluint::init_from_table(u) })
  102|       |        } else {
  103|      0|            None
  104|       |        }
  105|      0|    }
  106|       |
  107|       |    #[inline]
  108|       |    #[allow(non_snake_case)]
  109|      0|    pub fn return_value_as_hllong(&self) -> Option<hllong<'a>> {
  110|      0|        if self.return_value_type() == ReturnValue::hllong {
  111|      0|            let u = self.return_value();
  112|      0|            // Safety:
  113|      0|            // Created from a valid Table for this object
  114|      0|            // Which contains a valid union in this slot
  115|      0|            Some(unsafe { hllong::init_from_table(u) })
  116|       |        } else {
  117|      0|            None
  118|       |        }
  119|      0|    }
  120|       |
  121|       |    #[inline]
  122|       |    #[allow(non_snake_case)]
  123|      0|    pub fn return_value_as_hlulong(&self) -> Option<hlulong<'a>> {
  124|      0|        if self.return_value_type() == ReturnValue::hlulong {
  125|      0|            let u = self.return_value();
  126|      0|            // Safety:
  127|      0|            // Created from a valid Table for this object
  128|      0|            // Which contains a valid union in this slot
  129|      0|            Some(unsafe { hlulong::init_from_table(u) })
  130|       |        } else {
  131|      0|            None
  132|       |        }
  133|      0|    }
  134|       |
  135|       |    #[inline]
  136|       |    #[allow(non_snake_case)]
  137|      0|    pub fn return_value_as_hlfloat(&self) -> Option<hlfloat<'a>> {
  138|      0|        if self.return_value_type() == ReturnValue::hlfloat {
  139|      0|            let u = self.return_value();
  140|      0|            // Safety:
  141|      0|            // Created from a valid Table for this object
  142|      0|            // Which contains a valid union in this slot
  143|      0|            Some(unsafe { hlfloat::init_from_table(u) })
  144|       |        } else {
  145|      0|            None
  146|       |        }
  147|      0|    }
  148|       |
  149|       |    #[inline]
  150|       |    #[allow(non_snake_case)]
  151|      0|    pub fn return_value_as_hldouble(&self) -> Option<hldouble<'a>> {
  152|      0|        if self.return_value_type() == ReturnValue::hldouble {
  153|      0|            let u = self.return_value();
  154|      0|            // Safety:
  155|      0|            // Created from a valid Table for this object
  156|      0|            // Which contains a valid union in this slot
  157|      0|            Some(unsafe { hldouble::init_from_table(u) })
  158|       |        } else {
  159|      0|            None
  160|       |        }
  161|      0|    }
  162|       |
  163|       |    #[inline]
  164|       |    #[allow(non_snake_case)]
  165|      0|    pub fn return_value_as_hlstring(&self) -> Option<hlstring<'a>> {
  166|      0|        if self.return_value_type() == ReturnValue::hlstring {
  167|      0|            let u = self.return_value();
  168|      0|            // Safety:
  169|      0|            // Created from a valid Table for this object
  170|      0|            // Which contains a valid union in this slot
  171|      0|            Some(unsafe { hlstring::init_from_table(u) })
  172|       |        } else {
  173|      0|            None
  174|       |        }
  175|      0|    }
  176|       |
  177|       |    #[inline]
  178|       |    #[allow(non_snake_case)]
  179|      0|    pub fn return_value_as_hlbool(&self) -> Option<hlbool<'a>> {
  180|      0|        if self.return_value_type() == ReturnValue::hlbool {
  181|      0|            let u = self.return_value();
  182|      0|            // Safety:
  183|      0|            // Created from a valid Table for this object
  184|      0|            // Which contains a valid union in this slot
  185|      0|            Some(unsafe { hlbool::init_from_table(u) })
  186|       |        } else {
  187|      0|            None
  188|       |        }
  189|      0|    }
  190|       |
  191|       |    #[inline]
  192|       |    #[allow(non_snake_case)]
  193|      0|    pub fn return_value_as_hlvoid(&self) -> Option<hlvoid<'a>> {
  194|      0|        if self.return_value_type() == ReturnValue::hlvoid {
  195|      0|            let u = self.return_value();
  196|      0|            // Safety:
  197|      0|            // Created from a valid Table for this object
  198|      0|            // Which contains a valid union in this slot
  199|      0|            Some(unsafe { hlvoid::init_from_table(u) })
  200|       |        } else {
  201|      0|            None
  202|       |        }
  203|      0|    }
  204|       |
  205|       |    #[inline]
  206|       |    #[allow(non_snake_case)]
  207|      0|    pub fn return_value_as_hlsizeprefixedbuffer(&self) -> Option<hlsizeprefixedbuffer<'a>> {
  208|      0|        if self.return_value_type() == ReturnValue::hlsizeprefixedbuffer {
  209|      0|            let u = self.return_value();
  210|      0|            // Safety:
  211|      0|            // Created from a valid Table for this object
  212|      0|            // Which contains a valid union in this slot
  213|      0|            Some(unsafe { hlsizeprefixedbuffer::init_from_table(u) })
  214|       |        } else {
  215|      0|            None
  216|       |        }
  217|      0|    }
  218|       |}
  219|       |
  220|       |impl flatbuffers::Verifiable for FunctionCallResult<'_> {
  221|       |    #[inline]
  222|      0|    fn run_verifier(
  223|      0|        v: &mut flatbuffers::Verifier,
  224|      0|        pos: usize,
  225|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  226|       |        use self::flatbuffers::Verifiable;
  227|      0|        v.visit_table(pos)?
  228|      0|            .visit_union::<ReturnValue, _>(
  229|      0|                "return_value_type",
  230|      0|                Self::VT_RETURN_VALUE_TYPE,
  231|      0|                "return_value",
  232|      0|                Self::VT_RETURN_VALUE,
  233|      0|                true,
  234|      0|                |key, v, pos| match key {
  235|      0|                    ReturnValue::hlint => v
  236|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlint>>(
  237|      0|                            "ReturnValue::hlint",
  238|      0|                            pos,
  239|      0|                        ),
  240|      0|                    ReturnValue::hluint => v
  241|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hluint>>(
  242|      0|                            "ReturnValue::hluint",
  243|      0|                            pos,
  244|      0|                        ),
  245|      0|                    ReturnValue::hllong => v
  246|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hllong>>(
  247|      0|                            "ReturnValue::hllong",
  248|      0|                            pos,
  249|      0|                        ),
  250|      0|                    ReturnValue::hlulong => v
  251|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlulong>>(
  252|      0|                            "ReturnValue::hlulong",
  253|      0|                            pos,
  254|      0|                        ),
  255|      0|                    ReturnValue::hlfloat => v
  256|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlfloat>>(
  257|      0|                            "ReturnValue::hlfloat",
  258|      0|                            pos,
  259|      0|                        ),
  260|      0|                    ReturnValue::hldouble => v
  261|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hldouble>>(
  262|      0|                            "ReturnValue::hldouble",
  263|      0|                            pos,
  264|      0|                        ),
  265|      0|                    ReturnValue::hlstring => v
  266|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlstring>>(
  267|      0|                            "ReturnValue::hlstring",
  268|      0|                            pos,
  269|      0|                        ),
  270|      0|                    ReturnValue::hlbool => v
  271|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlbool>>(
  272|      0|                            "ReturnValue::hlbool",
  273|      0|                            pos,
  274|      0|                        ),
  275|      0|                    ReturnValue::hlvoid => v
  276|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlvoid>>(
  277|      0|                            "ReturnValue::hlvoid",
  278|      0|                            pos,
  279|      0|                        ),
  280|      0|                    ReturnValue::hlsizeprefixedbuffer => v
  281|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlsizeprefixedbuffer>>(
  282|      0|                            "ReturnValue::hlsizeprefixedbuffer",
  283|      0|                            pos,
  284|      0|                        ),
  285|      0|                    _ => Ok(()),
  286|      0|                },
  287|      0|            )?
  288|      0|            .finish();
  289|      0|        Ok(())
  290|      0|    }
  291|       |}
  292|       |pub struct FunctionCallResultArgs {
  293|       |    pub return_value_type: ReturnValue,
  294|       |    pub return_value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
  295|       |}
  296|       |impl<'a> Default for FunctionCallResultArgs {
  297|       |    #[inline]
  298|      0|    fn default() -> Self {
  299|      0|        FunctionCallResultArgs {
  300|      0|            return_value_type: ReturnValue::NONE,
  301|      0|            return_value: None, // required field
  302|      0|        }
  303|      0|    }
  304|       |}
  305|       |
  306|       |pub struct FunctionCallResultBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  307|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  308|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  309|       |}
  310|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FunctionCallResultBuilder<'a, 'b, A> {
  311|       |    #[inline]
  312|      0|    pub fn add_return_value_type(&mut self, return_value_type: ReturnValue) {
  313|      0|        self.fbb_.push_slot::<ReturnValue>(
  314|      0|            FunctionCallResult::VT_RETURN_VALUE_TYPE,
  315|      0|            return_value_type,
  316|      0|            ReturnValue::NONE,
  317|      0|        );
  318|      0|    }
  319|       |    #[inline]
  320|      0|    pub fn add_return_value(
  321|      0|        &mut self,
  322|      0|        return_value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
  323|      0|    ) {
  324|      0|        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
  325|      0|            FunctionCallResult::VT_RETURN_VALUE,
  326|      0|            return_value,
  327|      0|        );
  328|      0|    }
  329|       |    #[inline]
  330|      0|    pub fn new(
  331|      0|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  332|      0|    ) -> FunctionCallResultBuilder<'a, 'b, A> {
  333|      0|        let start = _fbb.start_table();
  334|      0|        FunctionCallResultBuilder {
  335|      0|            fbb_: _fbb,
  336|      0|            start_: start,
  337|      0|        }
  338|      0|    }
  339|       |    #[inline]
  340|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<FunctionCallResult<'a>> {
  341|      0|        let o = self.fbb_.end_table(self.start_);
  342|      0|        self.fbb_
  343|      0|            .required(o, FunctionCallResult::VT_RETURN_VALUE, "return_value");
  344|      0|        flatbuffers::WIPOffset::new(o.value())
  345|      0|    }
  346|       |}
  347|       |
  348|       |impl core::fmt::Debug for FunctionCallResult<'_> {
  349|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  350|      0|        let mut ds = f.debug_struct("FunctionCallResult");
  351|      0|        ds.field("return_value_type", &self.return_value_type());
  352|      0|        match self.return_value_type() {
  353|       |            ReturnValue::hlint => {
  354|      0|                if let Some(x) = self.return_value_as_hlint() {
  355|      0|                    ds.field("return_value", &x)
  356|       |                } else {
  357|      0|                    ds.field(
  358|      0|                        "return_value",
  359|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  360|      0|                    )
  361|       |                }
  362|       |            }
  363|       |            ReturnValue::hluint => {
  364|      0|                if let Some(x) = self.return_value_as_hluint() {
  365|      0|                    ds.field("return_value", &x)
  366|       |                } else {
  367|      0|                    ds.field(
  368|      0|                        "return_value",
  369|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  370|      0|                    )
  371|       |                }
  372|       |            }
  373|       |            ReturnValue::hllong => {
  374|      0|                if let Some(x) = self.return_value_as_hllong() {
  375|      0|                    ds.field("return_value", &x)
  376|       |                } else {
  377|      0|                    ds.field(
  378|      0|                        "return_value",
  379|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  380|      0|                    )
  381|       |                }
  382|       |            }
  383|       |            ReturnValue::hlulong => {
  384|      0|                if let Some(x) = self.return_value_as_hlulong() {
  385|      0|                    ds.field("return_value", &x)
  386|       |                } else {
  387|      0|                    ds.field(
  388|      0|                        "return_value",
  389|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  390|      0|                    )
  391|       |                }
  392|       |            }
  393|       |            ReturnValue::hlfloat => {
  394|      0|                if let Some(x) = self.return_value_as_hlfloat() {
  395|      0|                    ds.field("return_value", &x)
  396|       |                } else {
  397|      0|                    ds.field(
  398|      0|                        "return_value",
  399|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  400|      0|                    )
  401|       |                }
  402|       |            }
  403|       |            ReturnValue::hldouble => {
  404|      0|                if let Some(x) = self.return_value_as_hldouble() {
  405|      0|                    ds.field("return_value", &x)
  406|       |                } else {
  407|      0|                    ds.field(
  408|      0|                        "return_value",
  409|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  410|      0|                    )
  411|       |                }
  412|       |            }
  413|       |            ReturnValue::hlstring => {
  414|      0|                if let Some(x) = self.return_value_as_hlstring() {
  415|      0|                    ds.field("return_value", &x)
  416|       |                } else {
  417|      0|                    ds.field(
  418|      0|                        "return_value",
  419|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  420|      0|                    )
  421|       |                }
  422|       |            }
  423|       |            ReturnValue::hlbool => {
  424|      0|                if let Some(x) = self.return_value_as_hlbool() {
  425|      0|                    ds.field("return_value", &x)
  426|       |                } else {
  427|      0|                    ds.field(
  428|      0|                        "return_value",
  429|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  430|      0|                    )
  431|       |                }
  432|       |            }
  433|       |            ReturnValue::hlvoid => {
  434|      0|                if let Some(x) = self.return_value_as_hlvoid() {
  435|      0|                    ds.field("return_value", &x)
  436|       |                } else {
  437|      0|                    ds.field(
  438|      0|                        "return_value",
  439|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  440|      0|                    )
  441|       |                }
  442|       |            }
  443|       |            ReturnValue::hlsizeprefixedbuffer => {
  444|      0|                if let Some(x) = self.return_value_as_hlsizeprefixedbuffer() {
  445|      0|                    ds.field("return_value", &x)
  446|       |                } else {
  447|      0|                    ds.field(
  448|      0|                        "return_value",
  449|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  450|      0|                    )
  451|       |                }
  452|       |            }
  453|       |            _ => {
  454|      0|                let x: Option<()> = None;
  455|      0|                ds.field("return_value", &x)
  456|       |            }
  457|       |        };
  458|      0|        ds.finish()
  459|      0|    }
  460|       |}
  461|       |#[inline]
  462|       |/// Verifies that a buffer of bytes contains a `FunctionCallResult`
  463|       |/// and returns it.
  464|       |/// Note that verification is still experimental and may not
  465|       |/// catch every error, or be maximally performant. For the
  466|       |/// previous, unchecked, behavior use
  467|       |/// `root_as_function_call_result_unchecked`.
  468|      0|pub fn root_as_function_call_result(
  469|      0|    buf: &[u8],
  470|      0|) -> Result<FunctionCallResult, flatbuffers::InvalidFlatbuffer> {
  471|      0|    flatbuffers::root::<FunctionCallResult>(buf)
  472|      0|}
  473|       |#[inline]
  474|       |/// Verifies that a buffer of bytes contains a size prefixed
  475|       |/// `FunctionCallResult` and returns it.
  476|       |/// Note that verification is still experimental and may not
  477|       |/// catch every error, or be maximally performant. For the
  478|       |/// previous, unchecked, behavior use
  479|       |/// `size_prefixed_root_as_function_call_result_unchecked`.
  480|      0|pub fn size_prefixed_root_as_function_call_result(
  481|      0|    buf: &[u8],
  482|      0|) -> Result<FunctionCallResult, flatbuffers::InvalidFlatbuffer> {
  483|      0|    flatbuffers::size_prefixed_root::<FunctionCallResult>(buf)
  484|      0|}
  485|       |#[inline]
  486|       |/// Verifies, with the given options, that a buffer of bytes
  487|       |/// contains a `FunctionCallResult` and returns it.
  488|       |/// Note that verification is still experimental and may not
  489|       |/// catch every error, or be maximally performant. For the
  490|       |/// previous, unchecked, behavior use
  491|       |/// `root_as_function_call_result_unchecked`.
  492|      0|pub fn root_as_function_call_result_with_opts<'b, 'o>(
  493|      0|    opts: &'o flatbuffers::VerifierOptions,
  494|      0|    buf: &'b [u8],
  495|      0|) -> Result<FunctionCallResult<'b>, flatbuffers::InvalidFlatbuffer> {
  496|      0|    flatbuffers::root_with_opts::<FunctionCallResult<'b>>(opts, buf)
  497|      0|}
  498|       |#[inline]
  499|       |/// Verifies, with the given verifier options, that a buffer of
  500|       |/// bytes contains a size prefixed `FunctionCallResult` and returns
  501|       |/// it. Note that verification is still experimental and may not
  502|       |/// catch every error, or be maximally performant. For the
  503|       |/// previous, unchecked, behavior use
  504|       |/// `root_as_function_call_result_unchecked`.
  505|      0|pub fn size_prefixed_root_as_function_call_result_with_opts<'b, 'o>(
  506|      0|    opts: &'o flatbuffers::VerifierOptions,
  507|      0|    buf: &'b [u8],
  508|      0|) -> Result<FunctionCallResult<'b>, flatbuffers::InvalidFlatbuffer> {
  509|      0|    flatbuffers::size_prefixed_root_with_opts::<FunctionCallResult<'b>>(opts, buf)
  510|      0|}
  511|       |#[inline]
  512|       |/// Assumes, without verification, that a buffer of bytes contains a FunctionCallResult and returns it.
  513|       |/// # Safety
  514|       |/// Callers must trust the given bytes do indeed contain a valid `FunctionCallResult`.
  515|      0|pub unsafe fn root_as_function_call_result_unchecked(buf: &[u8]) -> FunctionCallResult {
  516|      0|    flatbuffers::root_unchecked::<FunctionCallResult>(buf)
  517|      0|}
  518|       |#[inline]
  519|       |/// Assumes, without verification, that a buffer of bytes contains a size prefixed FunctionCallResult and returns it.
  520|       |/// # Safety
  521|       |/// Callers must trust the given bytes do indeed contain a valid size prefixed `FunctionCallResult`.
  522|      0|pub unsafe fn size_prefixed_root_as_function_call_result_unchecked(
  523|      0|    buf: &[u8],
  524|      0|) -> FunctionCallResult {
  525|      0|    flatbuffers::size_prefixed_root_unchecked::<FunctionCallResult>(buf)
  526|      0|}
  527|       |#[inline]
  528|      0|pub fn finish_function_call_result_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  529|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  530|      0|    root: flatbuffers::WIPOffset<FunctionCallResult<'a>>,
  531|      0|) {
  532|      0|    fbb.finish(root, None);
  533|      0|}
  534|       |
  535|       |#[inline]
  536|      0|pub fn finish_size_prefixed_function_call_result_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  537|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  538|      0|    root: flatbuffers::WIPOffset<FunctionCallResult<'a>>,
  539|      0|) {
  540|      0|    fbb.finish_size_prefixed(root, None);
  541|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/function_call_type_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_FUNCTION_CALL_TYPE: u8 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_FUNCTION_CALL_TYPE: u8 = 2;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_FUNCTION_CALL_TYPE: [FunctionCallType; 3] = [
   29|       |    FunctionCallType::none,
   30|       |    FunctionCallType::guest,
   31|       |    FunctionCallType::host,
   32|       |];
   33|       |
   34|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   35|       |#[repr(transparent)]
   36|       |pub struct FunctionCallType(pub u8);
   37|       |#[allow(non_upper_case_globals)]
   38|       |impl FunctionCallType {
   39|       |    pub const none: Self = Self(0);
   40|       |    pub const guest: Self = Self(1);
   41|       |    pub const host: Self = Self(2);
   42|       |
   43|       |    pub const ENUM_MIN: u8 = 0;
   44|       |    pub const ENUM_MAX: u8 = 2;
   45|       |    pub const ENUM_VALUES: &'static [Self] = &[Self::none, Self::guest, Self::host];
   46|       |    /// Returns the variant's name or "" if unknown.
   47|      0|    pub fn variant_name(self) -> Option<&'static str> {
   48|      0|        match self {
   49|      0|            Self::none => Some("none"),
   50|      0|            Self::guest => Some("guest"),
   51|      0|            Self::host => Some("host"),
   52|      0|            _ => None,
   53|       |        }
   54|      0|    }
   55|       |}
   56|       |impl core::fmt::Debug for FunctionCallType {
   57|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
   58|      0|        if let Some(name) = self.variant_name() {
   59|      0|            f.write_str(name)
   60|       |        } else {
   61|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
   62|       |        }
   63|      0|    }
   64|       |}
   65|       |impl<'a> flatbuffers::Follow<'a> for FunctionCallType {
   66|       |    type Inner = Self;
   67|       |    #[inline]
   68|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   69|      0|        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
   70|      0|        Self(b)
   71|      0|    }
   72|       |}
   73|       |
   74|       |impl flatbuffers::Push for FunctionCallType {
   75|       |    type Output = FunctionCallType;
   76|       |    #[inline]
   77|      0|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
   78|      0|        flatbuffers::emplace_scalar::<u8>(dst, self.0);
   79|      0|    }
   80|       |}
   81|       |
   82|       |impl flatbuffers::EndianScalar for FunctionCallType {
   83|       |    type Scalar = u8;
   84|       |    #[inline]
   85|      0|    fn to_little_endian(self) -> u8 {
   86|      0|        self.0.to_le()
   87|      0|    }
   88|       |    #[inline]
   89|       |    #[allow(clippy::wrong_self_convention)]
   90|      0|    fn from_little_endian(v: u8) -> Self {
   91|      0|        let b = u8::from_le(v);
   92|      0|        Self(b)
   93|      0|    }
   94|       |}
   95|       |
   96|       |impl<'a> flatbuffers::Verifiable for FunctionCallType {
   97|       |    #[inline]
   98|      0|    fn run_verifier(
   99|      0|        v: &mut flatbuffers::Verifier,
  100|      0|        pos: usize,
  101|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  102|       |        use self::flatbuffers::Verifiable;
  103|      0|        u8::run_verifier(v, pos)
  104|      0|    }
  105|       |}
  106|       |
  107|       |impl flatbuffers::SimpleToVerifyInSlice for FunctionCallType {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/guest_error_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum GuestErrorOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct GuestError<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for GuestError<'a> {
   21|       |    type Inner = GuestError<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> GuestError<'a> {
   31|       |    pub const VT_CODE: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;
   33|       |
   34|       |    #[inline]
   35|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   36|      0|        GuestError { _tab: table }
   37|      0|    }
   38|       |    #[allow(unused_mut)]
   39|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   40|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   41|      0|        args: &'args GuestErrorArgs<'args>,
   42|      0|    ) -> flatbuffers::WIPOffset<GuestError<'bldr>> {
   43|      0|        let mut builder = GuestErrorBuilder::new(_fbb);
   44|      0|        builder.add_code(args.code);
   45|      0|        if let Some(x) = args.message {
   46|      0|            builder.add_message(x);
   47|      0|        }
   48|      0|        builder.finish()
   49|      0|    }
   50|       |
   51|       |    #[inline]
   52|      0|    pub fn code(&self) -> ErrorCode {
   53|      0|        // Safety:
   54|      0|        // Created from valid Table for this object
   55|      0|        // which contains a valid value in this slot
   56|      0|        unsafe {
   57|      0|            self._tab
   58|      0|                .get::<ErrorCode>(GuestError::VT_CODE, Some(ErrorCode::NoError))
   59|      0|                .unwrap()
   60|      0|        }
   61|      0|    }
   62|       |    #[inline]
   63|      0|    pub fn message(&self) -> Option<&'a str> {
   64|      0|        // Safety:
   65|      0|        // Created from valid Table for this object
   66|      0|        // which contains a valid value in this slot
   67|      0|        unsafe {
   68|      0|            self._tab
   69|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(GuestError::VT_MESSAGE, None)
   70|      0|        }
   71|      0|    }
   72|       |}
   73|       |
   74|       |impl flatbuffers::Verifiable for GuestError<'_> {
   75|       |    #[inline]
   76|      0|    fn run_verifier(
   77|      0|        v: &mut flatbuffers::Verifier,
   78|      0|        pos: usize,
   79|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   80|       |        use self::flatbuffers::Verifiable;
   81|      0|        v.visit_table(pos)?
   82|      0|            .visit_field::<ErrorCode>("code", Self::VT_CODE, false)?
   83|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
   84|      0|            .finish();
   85|      0|        Ok(())
   86|      0|    }
   87|       |}
   88|       |pub struct GuestErrorArgs<'a> {
   89|       |    pub code: ErrorCode,
   90|       |    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
   91|       |}
   92|       |impl<'a> Default for GuestErrorArgs<'a> {
   93|       |    #[inline]
   94|      0|    fn default() -> Self {
   95|      0|        GuestErrorArgs {
   96|      0|            code: ErrorCode::NoError,
   97|      0|            message: None,
   98|      0|        }
   99|      0|    }
  100|       |}
  101|       |
  102|       |pub struct GuestErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  103|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  104|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  105|       |}
  106|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GuestErrorBuilder<'a, 'b, A> {
  107|       |    #[inline]
  108|      0|    pub fn add_code(&mut self, code: ErrorCode) {
  109|      0|        self.fbb_
  110|      0|            .push_slot::<ErrorCode>(GuestError::VT_CODE, code, ErrorCode::NoError);
  111|      0|    }
  112|       |    #[inline]
  113|      0|    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
  114|      0|        self.fbb_
  115|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(GuestError::VT_MESSAGE, message);
  116|      0|    }
  117|       |    #[inline]
  118|      0|    pub fn new(
  119|      0|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  120|      0|    ) -> GuestErrorBuilder<'a, 'b, A> {
  121|      0|        let start = _fbb.start_table();
  122|      0|        GuestErrorBuilder {
  123|      0|            fbb_: _fbb,
  124|      0|            start_: start,
  125|      0|        }
  126|      0|    }
  127|       |    #[inline]
  128|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<GuestError<'a>> {
  129|      0|        let o = self.fbb_.end_table(self.start_);
  130|      0|        flatbuffers::WIPOffset::new(o.value())
  131|      0|    }
  132|       |}
  133|       |
  134|       |impl core::fmt::Debug for GuestError<'_> {
  135|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  136|      0|        let mut ds = f.debug_struct("GuestError");
  137|      0|        ds.field("code", &self.code());
  138|      0|        ds.field("message", &self.message());
  139|      0|        ds.finish()
  140|      0|    }
  141|       |}
  142|       |#[inline]
  143|       |/// Verifies that a buffer of bytes contains a `GuestError`
  144|       |/// and returns it.
  145|       |/// Note that verification is still experimental and may not
  146|       |/// catch every error, or be maximally performant. For the
  147|       |/// previous, unchecked, behavior use
  148|       |/// `root_as_guest_error_unchecked`.
  149|      0|pub fn root_as_guest_error(buf: &[u8]) -> Result<GuestError, flatbuffers::InvalidFlatbuffer> {
  150|      0|    flatbuffers::root::<GuestError>(buf)
  151|      0|}
  152|       |#[inline]
  153|       |/// Verifies that a buffer of bytes contains a size prefixed
  154|       |/// `GuestError` and returns it.
  155|       |/// Note that verification is still experimental and may not
  156|       |/// catch every error, or be maximally performant. For the
  157|       |/// previous, unchecked, behavior use
  158|       |/// `size_prefixed_root_as_guest_error_unchecked`.
  159|      0|pub fn size_prefixed_root_as_guest_error(
  160|      0|    buf: &[u8],
  161|      0|) -> Result<GuestError, flatbuffers::InvalidFlatbuffer> {
  162|      0|    flatbuffers::size_prefixed_root::<GuestError>(buf)
  163|      0|}
  164|       |#[inline]
  165|       |/// Verifies, with the given options, that a buffer of bytes
  166|       |/// contains a `GuestError` and returns it.
  167|       |/// Note that verification is still experimental and may not
  168|       |/// catch every error, or be maximally performant. For the
  169|       |/// previous, unchecked, behavior use
  170|       |/// `root_as_guest_error_unchecked`.
  171|      0|pub fn root_as_guest_error_with_opts<'b, 'o>(
  172|      0|    opts: &'o flatbuffers::VerifierOptions,
  173|      0|    buf: &'b [u8],
  174|      0|) -> Result<GuestError<'b>, flatbuffers::InvalidFlatbuffer> {
  175|      0|    flatbuffers::root_with_opts::<GuestError<'b>>(opts, buf)
  176|      0|}
  177|       |#[inline]
  178|       |/// Verifies, with the given verifier options, that a buffer of
  179|       |/// bytes contains a size prefixed `GuestError` and returns
  180|       |/// it. Note that verification is still experimental and may not
  181|       |/// catch every error, or be maximally performant. For the
  182|       |/// previous, unchecked, behavior use
  183|       |/// `root_as_guest_error_unchecked`.
  184|      0|pub fn size_prefixed_root_as_guest_error_with_opts<'b, 'o>(
  185|      0|    opts: &'o flatbuffers::VerifierOptions,
  186|      0|    buf: &'b [u8],
  187|      0|) -> Result<GuestError<'b>, flatbuffers::InvalidFlatbuffer> {
  188|      0|    flatbuffers::size_prefixed_root_with_opts::<GuestError<'b>>(opts, buf)
  189|      0|}
  190|       |#[inline]
  191|       |/// Assumes, without verification, that a buffer of bytes contains a GuestError and returns it.
  192|       |/// # Safety
  193|       |/// Callers must trust the given bytes do indeed contain a valid `GuestError`.
  194|      0|pub unsafe fn root_as_guest_error_unchecked(buf: &[u8]) -> GuestError {
  195|      0|    flatbuffers::root_unchecked::<GuestError>(buf)
  196|      0|}
  197|       |#[inline]
  198|       |/// Assumes, without verification, that a buffer of bytes contains a size prefixed GuestError and returns it.
  199|       |/// # Safety
  200|       |/// Callers must trust the given bytes do indeed contain a valid size prefixed `GuestError`.
  201|      0|pub unsafe fn size_prefixed_root_as_guest_error_unchecked(buf: &[u8]) -> GuestError {
  202|      0|    flatbuffers::size_prefixed_root_unchecked::<GuestError>(buf)
  203|      0|}
  204|       |#[inline]
  205|      0|pub fn finish_guest_error_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  206|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  207|      0|    root: flatbuffers::WIPOffset<GuestError<'a>>,
  208|      0|) {
  209|      0|    fbb.finish(root, None);
  210|      0|}
  211|       |
  212|       |#[inline]
  213|      0|pub fn finish_size_prefixed_guest_error_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  214|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  215|      0|    root: flatbuffers::WIPOffset<GuestError<'a>>,
  216|      0|) {
  217|      0|    fbb.finish_size_prefixed(root, None);
  218|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/guest_log_data_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum GuestLogDataOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct GuestLogData<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for GuestLogData<'a> {
   21|       |    type Inner = GuestLogData<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> GuestLogData<'a> {
   31|       |    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
   33|       |    pub const VT_LEVEL: flatbuffers::VOffsetT = 8;
   34|       |    pub const VT_CALLER: flatbuffers::VOffsetT = 10;
   35|       |    pub const VT_SOURCE_FILE: flatbuffers::VOffsetT = 12;
   36|       |    pub const VT_LINE: flatbuffers::VOffsetT = 14;
   37|       |
   38|       |    #[inline]
   39|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   40|      0|        GuestLogData { _tab: table }
   41|      0|    }
   42|       |    #[allow(unused_mut)]
   43|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   44|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   45|      0|        args: &'args GuestLogDataArgs<'args>,
   46|      0|    ) -> flatbuffers::WIPOffset<GuestLogData<'bldr>> {
   47|      0|        let mut builder = GuestLogDataBuilder::new(_fbb);
   48|      0|        builder.add_line(args.line);
   49|      0|        if let Some(x) = args.source_file {
   50|      0|            builder.add_source_file(x);
   51|      0|        }
   52|      0|        if let Some(x) = args.caller {
   53|      0|            builder.add_caller(x);
   54|      0|        }
   55|      0|        if let Some(x) = args.source {
   56|      0|            builder.add_source(x);
   57|      0|        }
   58|      0|        if let Some(x) = args.message {
   59|      0|            builder.add_message(x);
   60|      0|        }
   61|      0|        builder.add_level(args.level);
   62|      0|        builder.finish()
   63|      0|    }
   64|       |
   65|       |    #[inline]
   66|      0|    pub fn message(&self) -> Option<&'a str> {
   67|      0|        // Safety:
   68|      0|        // Created from valid Table for this object
   69|      0|        // which contains a valid value in this slot
   70|      0|        unsafe {
   71|      0|            self._tab
   72|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(GuestLogData::VT_MESSAGE, None)
   73|      0|        }
   74|      0|    }
   75|       |    #[inline]
   76|      0|    pub fn source(&self) -> Option<&'a str> {
   77|      0|        // Safety:
   78|      0|        // Created from valid Table for this object
   79|      0|        // which contains a valid value in this slot
   80|      0|        unsafe {
   81|      0|            self._tab
   82|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(GuestLogData::VT_SOURCE, None)
   83|      0|        }
   84|      0|    }
   85|       |    #[inline]
   86|      0|    pub fn level(&self) -> LogLevel {
   87|      0|        // Safety:
   88|      0|        // Created from valid Table for this object
   89|      0|        // which contains a valid value in this slot
   90|      0|        unsafe {
   91|      0|            self._tab
   92|      0|                .get::<LogLevel>(GuestLogData::VT_LEVEL, Some(LogLevel::Trace))
   93|      0|                .unwrap()
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn caller(&self) -> Option<&'a str> {
   98|      0|        // Safety:
   99|      0|        // Created from valid Table for this object
  100|      0|        // which contains a valid value in this slot
  101|      0|        unsafe {
  102|      0|            self._tab
  103|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(GuestLogData::VT_CALLER, None)
  104|      0|        }
  105|      0|    }
  106|       |    #[inline]
  107|      0|    pub fn source_file(&self) -> Option<&'a str> {
  108|      0|        // Safety:
  109|      0|        // Created from valid Table for this object
  110|      0|        // which contains a valid value in this slot
  111|      0|        unsafe {
  112|      0|            self._tab
  113|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(GuestLogData::VT_SOURCE_FILE, None)
  114|      0|        }
  115|      0|    }
  116|       |    #[inline]
  117|      0|    pub fn line(&self) -> u32 {
  118|      0|        // Safety:
  119|      0|        // Created from valid Table for this object
  120|      0|        // which contains a valid value in this slot
  121|      0|        unsafe {
  122|      0|            self._tab
  123|      0|                .get::<u32>(GuestLogData::VT_LINE, Some(0))
  124|      0|                .unwrap()
  125|      0|        }
  126|      0|    }
  127|       |}
  128|       |
  129|       |impl flatbuffers::Verifiable for GuestLogData<'_> {
  130|       |    #[inline]
  131|      0|    fn run_verifier(
  132|      0|        v: &mut flatbuffers::Verifier,
  133|      0|        pos: usize,
  134|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  135|       |        use self::flatbuffers::Verifiable;
  136|      0|        v.visit_table(pos)?
  137|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
  138|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
  139|      0|            .visit_field::<LogLevel>("level", Self::VT_LEVEL, false)?
  140|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("caller", Self::VT_CALLER, false)?
  141|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
  142|      0|                "source_file",
  143|      0|                Self::VT_SOURCE_FILE,
  144|      0|                false,
  145|      0|            )?
  146|      0|            .visit_field::<u32>("line", Self::VT_LINE, false)?
  147|      0|            .finish();
  148|      0|        Ok(())
  149|      0|    }
  150|       |}
  151|       |pub struct GuestLogDataArgs<'a> {
  152|       |    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
  153|       |    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
  154|       |    pub level: LogLevel,
  155|       |    pub caller: Option<flatbuffers::WIPOffset<&'a str>>,
  156|       |    pub source_file: Option<flatbuffers::WIPOffset<&'a str>>,
  157|       |    pub line: u32,
  158|       |}
  159|       |impl<'a> Default for GuestLogDataArgs<'a> {
  160|       |    #[inline]
  161|      0|    fn default() -> Self {
  162|      0|        GuestLogDataArgs {
  163|      0|            message: None,
  164|      0|            source: None,
  165|      0|            level: LogLevel::Trace,
  166|      0|            caller: None,
  167|      0|            source_file: None,
  168|      0|            line: 0,
  169|      0|        }
  170|      0|    }
  171|       |}
  172|       |
  173|       |pub struct GuestLogDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  174|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  175|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  176|       |}
  177|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GuestLogDataBuilder<'a, 'b, A> {
  178|       |    #[inline]
  179|      0|    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
  180|      0|        self.fbb_
  181|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(GuestLogData::VT_MESSAGE, message);
  182|      0|    }
  183|       |    #[inline]
  184|      0|    pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b str>) {
  185|      0|        self.fbb_
  186|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(GuestLogData::VT_SOURCE, source);
  187|      0|    }
  188|       |    #[inline]
  189|      0|    pub fn add_level(&mut self, level: LogLevel) {
  190|      0|        self.fbb_
  191|      0|            .push_slot::<LogLevel>(GuestLogData::VT_LEVEL, level, LogLevel::Trace);
  192|      0|    }
  193|       |    #[inline]
  194|      0|    pub fn add_caller(&mut self, caller: flatbuffers::WIPOffset<&'b str>) {
  195|      0|        self.fbb_
  196|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(GuestLogData::VT_CALLER, caller);
  197|      0|    }
  198|       |    #[inline]
  199|      0|    pub fn add_source_file(&mut self, source_file: flatbuffers::WIPOffset<&'b str>) {
  200|      0|        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
  201|      0|            GuestLogData::VT_SOURCE_FILE,
  202|      0|            source_file,
  203|      0|        );
  204|      0|    }
  205|       |    #[inline]
  206|      0|    pub fn add_line(&mut self, line: u32) {
  207|      0|        self.fbb_.push_slot::<u32>(GuestLogData::VT_LINE, line, 0);
  208|      0|    }
  209|       |    #[inline]
  210|      0|    pub fn new(
  211|      0|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  212|      0|    ) -> GuestLogDataBuilder<'a, 'b, A> {
  213|      0|        let start = _fbb.start_table();
  214|      0|        GuestLogDataBuilder {
  215|      0|            fbb_: _fbb,
  216|      0|            start_: start,
  217|      0|        }
  218|      0|    }
  219|       |    #[inline]
  220|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<GuestLogData<'a>> {
  221|      0|        let o = self.fbb_.end_table(self.start_);
  222|      0|        flatbuffers::WIPOffset::new(o.value())
  223|      0|    }
  224|       |}
  225|       |
  226|       |impl core::fmt::Debug for GuestLogData<'_> {
  227|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  228|      0|        let mut ds = f.debug_struct("GuestLogData");
  229|      0|        ds.field("message", &self.message());
  230|      0|        ds.field("source", &self.source());
  231|      0|        ds.field("level", &self.level());
  232|      0|        ds.field("caller", &self.caller());
  233|      0|        ds.field("source_file", &self.source_file());
  234|      0|        ds.field("line", &self.line());
  235|      0|        ds.finish()
  236|      0|    }
  237|       |}
  238|       |#[inline]
  239|       |/// Verifies that a buffer of bytes contains a `GuestLogData`
  240|       |/// and returns it.
  241|       |/// Note that verification is still experimental and may not
  242|       |/// catch every error, or be maximally performant. For the
  243|       |/// previous, unchecked, behavior use
  244|       |/// `root_as_guest_log_data_unchecked`.
  245|      0|pub fn root_as_guest_log_data(buf: &[u8]) -> Result<GuestLogData, flatbuffers::InvalidFlatbuffer> {
  246|      0|    flatbuffers::root::<GuestLogData>(buf)
  247|      0|}
  248|       |#[inline]
  249|       |/// Verifies that a buffer of bytes contains a size prefixed
  250|       |/// `GuestLogData` and returns it.
  251|       |/// Note that verification is still experimental and may not
  252|       |/// catch every error, or be maximally performant. For the
  253|       |/// previous, unchecked, behavior use
  254|       |/// `size_prefixed_root_as_guest_log_data_unchecked`.
  255|      0|pub fn size_prefixed_root_as_guest_log_data(
  256|      0|    buf: &[u8],
  257|      0|) -> Result<GuestLogData, flatbuffers::InvalidFlatbuffer> {
  258|      0|    flatbuffers::size_prefixed_root::<GuestLogData>(buf)
  259|      0|}
  260|       |#[inline]
  261|       |/// Verifies, with the given options, that a buffer of bytes
  262|       |/// contains a `GuestLogData` and returns it.
  263|       |/// Note that verification is still experimental and may not
  264|       |/// catch every error, or be maximally performant. For the
  265|       |/// previous, unchecked, behavior use
  266|       |/// `root_as_guest_log_data_unchecked`.
  267|      0|pub fn root_as_guest_log_data_with_opts<'b, 'o>(
  268|      0|    opts: &'o flatbuffers::VerifierOptions,
  269|      0|    buf: &'b [u8],
  270|      0|) -> Result<GuestLogData<'b>, flatbuffers::InvalidFlatbuffer> {
  271|      0|    flatbuffers::root_with_opts::<GuestLogData<'b>>(opts, buf)
  272|      0|}
  273|       |#[inline]
  274|       |/// Verifies, with the given verifier options, that a buffer of
  275|       |/// bytes contains a size prefixed `GuestLogData` and returns
  276|       |/// it. Note that verification is still experimental and may not
  277|       |/// catch every error, or be maximally performant. For the
  278|       |/// previous, unchecked, behavior use
  279|       |/// `root_as_guest_log_data_unchecked`.
  280|      0|pub fn size_prefixed_root_as_guest_log_data_with_opts<'b, 'o>(
  281|      0|    opts: &'o flatbuffers::VerifierOptions,
  282|      0|    buf: &'b [u8],
  283|      0|) -> Result<GuestLogData<'b>, flatbuffers::InvalidFlatbuffer> {
  284|      0|    flatbuffers::size_prefixed_root_with_opts::<GuestLogData<'b>>(opts, buf)
  285|      0|}
  286|       |#[inline]
  287|       |/// Assumes, without verification, that a buffer of bytes contains a GuestLogData and returns it.
  288|       |/// # Safety
  289|       |/// Callers must trust the given bytes do indeed contain a valid `GuestLogData`.
  290|      0|pub unsafe fn root_as_guest_log_data_unchecked(buf: &[u8]) -> GuestLogData {
  291|      0|    flatbuffers::root_unchecked::<GuestLogData>(buf)
  292|      0|}
  293|       |#[inline]
  294|       |/// Assumes, without verification, that a buffer of bytes contains a size prefixed GuestLogData and returns it.
  295|       |/// # Safety
  296|       |/// Callers must trust the given bytes do indeed contain a valid size prefixed `GuestLogData`.
  297|      0|pub unsafe fn size_prefixed_root_as_guest_log_data_unchecked(buf: &[u8]) -> GuestLogData {
  298|      0|    flatbuffers::size_prefixed_root_unchecked::<GuestLogData>(buf)
  299|      0|}
  300|       |#[inline]
  301|      0|pub fn finish_guest_log_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  302|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  303|      0|    root: flatbuffers::WIPOffset<GuestLogData<'a>>,
  304|      0|) {
  305|      0|    fbb.finish(root, None);
  306|      0|}
  307|       |
  308|       |#[inline]
  309|      0|pub fn finish_size_prefixed_guest_log_data_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  310|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  311|      0|    root: flatbuffers::WIPOffset<GuestLogData<'a>>,
  312|      0|) {
  313|      0|    fbb.finish_size_prefixed(root, None);
  314|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlbool_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlboolOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlbool<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlbool<'a> {
   21|       |    type Inner = hlbool<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlbool<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hlbool { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hlboolArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hlbool<'bldr>> {
   42|      0|        let mut builder = hlboolBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> bool {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe {
   53|      0|            self._tab
   54|      0|                .get::<bool>(hlbool::VT_VALUE, Some(false))
   55|      0|                .unwrap()
   56|      0|        }
   57|      0|    }
   58|       |}
   59|       |
   60|       |impl flatbuffers::Verifiable for hlbool<'_> {
   61|       |    #[inline]
   62|      0|    fn run_verifier(
   63|      0|        v: &mut flatbuffers::Verifier,
   64|      0|        pos: usize,
   65|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   66|       |        use self::flatbuffers::Verifiable;
   67|      0|        v.visit_table(pos)?
   68|      0|            .visit_field::<bool>("value", Self::VT_VALUE, false)?
   69|      0|            .finish();
   70|      0|        Ok(())
   71|      0|    }
   72|       |}
   73|       |pub struct hlboolArgs {
   74|       |    pub value: bool,
   75|       |}
   76|       |impl<'a> Default for hlboolArgs {
   77|       |    #[inline]
   78|      0|    fn default() -> Self {
   79|      0|        hlboolArgs { value: false }
   80|      0|    }
   81|       |}
   82|       |
   83|       |pub struct hlboolBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   84|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   85|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   86|       |}
   87|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlboolBuilder<'a, 'b, A> {
   88|       |    #[inline]
   89|      0|    pub fn add_value(&mut self, value: bool) {
   90|      0|        self.fbb_.push_slot::<bool>(hlbool::VT_VALUE, value, false);
   91|      0|    }
   92|       |    #[inline]
   93|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hlboolBuilder<'a, 'b, A> {
   94|      0|        let start = _fbb.start_table();
   95|      0|        hlboolBuilder {
   96|      0|            fbb_: _fbb,
   97|      0|            start_: start,
   98|      0|        }
   99|      0|    }
  100|       |    #[inline]
  101|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlbool<'a>> {
  102|      0|        let o = self.fbb_.end_table(self.start_);
  103|      0|        flatbuffers::WIPOffset::new(o.value())
  104|      0|    }
  105|       |}
  106|       |
  107|       |impl core::fmt::Debug for hlbool<'_> {
  108|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  109|      0|        let mut ds = f.debug_struct("hlbool");
  110|      0|        ds.field("value", &self.value());
  111|      0|        ds.finish()
  112|      0|    }
  113|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hldouble_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hldoubleOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hldouble<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hldouble<'a> {
   21|       |    type Inner = hldouble<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hldouble<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hldouble { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hldoubleArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hldouble<'bldr>> {
   42|      0|        let mut builder = hldoubleBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> f64 {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe { self._tab.get::<f64>(hldouble::VT_VALUE, Some(0.0)).unwrap() }
   53|      0|    }
   54|       |}
   55|       |
   56|       |impl flatbuffers::Verifiable for hldouble<'_> {
   57|       |    #[inline]
   58|      0|    fn run_verifier(
   59|      0|        v: &mut flatbuffers::Verifier,
   60|      0|        pos: usize,
   61|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   62|       |        use self::flatbuffers::Verifiable;
   63|      0|        v.visit_table(pos)?
   64|      0|            .visit_field::<f64>("value", Self::VT_VALUE, false)?
   65|      0|            .finish();
   66|      0|        Ok(())
   67|      0|    }
   68|       |}
   69|       |pub struct hldoubleArgs {
   70|       |    pub value: f64,
   71|       |}
   72|       |impl<'a> Default for hldoubleArgs {
   73|       |    #[inline]
   74|      0|    fn default() -> Self {
   75|      0|        hldoubleArgs { value: 0.0 }
   76|      0|    }
   77|       |}
   78|       |
   79|       |pub struct hldoubleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   80|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   81|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   82|       |}
   83|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hldoubleBuilder<'a, 'b, A> {
   84|       |    #[inline]
   85|      0|    pub fn add_value(&mut self, value: f64) {
   86|      0|        self.fbb_.push_slot::<f64>(hldouble::VT_VALUE, value, 0.0);
   87|      0|    }
   88|       |    #[inline]
   89|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hldoubleBuilder<'a, 'b, A> {
   90|      0|        let start = _fbb.start_table();
   91|      0|        hldoubleBuilder {
   92|      0|            fbb_: _fbb,
   93|      0|            start_: start,
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hldouble<'a>> {
   98|      0|        let o = self.fbb_.end_table(self.start_);
   99|      0|        flatbuffers::WIPOffset::new(o.value())
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl core::fmt::Debug for hldouble<'_> {
  104|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  105|      0|        let mut ds = f.debug_struct("hldouble");
  106|      0|        ds.field("value", &self.value());
  107|      0|        ds.finish()
  108|      0|    }
  109|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlfloat_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlfloatOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlfloat<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlfloat<'a> {
   21|       |    type Inner = hlfloat<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlfloat<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hlfloat { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hlfloatArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hlfloat<'bldr>> {
   42|      0|        let mut builder = hlfloatBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> f32 {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe { self._tab.get::<f32>(hlfloat::VT_VALUE, Some(0.0)).unwrap() }
   53|      0|    }
   54|       |}
   55|       |
   56|       |impl flatbuffers::Verifiable for hlfloat<'_> {
   57|       |    #[inline]
   58|      0|    fn run_verifier(
   59|      0|        v: &mut flatbuffers::Verifier,
   60|      0|        pos: usize,
   61|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   62|       |        use self::flatbuffers::Verifiable;
   63|      0|        v.visit_table(pos)?
   64|      0|            .visit_field::<f32>("value", Self::VT_VALUE, false)?
   65|      0|            .finish();
   66|      0|        Ok(())
   67|      0|    }
   68|       |}
   69|       |pub struct hlfloatArgs {
   70|       |    pub value: f32,
   71|       |}
   72|       |impl<'a> Default for hlfloatArgs {
   73|       |    #[inline]
   74|      0|    fn default() -> Self {
   75|      0|        hlfloatArgs { value: 0.0 }
   76|      0|    }
   77|       |}
   78|       |
   79|       |pub struct hlfloatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   80|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   81|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   82|       |}
   83|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlfloatBuilder<'a, 'b, A> {
   84|       |    #[inline]
   85|      0|    pub fn add_value(&mut self, value: f32) {
   86|      0|        self.fbb_.push_slot::<f32>(hlfloat::VT_VALUE, value, 0.0);
   87|      0|    }
   88|       |    #[inline]
   89|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hlfloatBuilder<'a, 'b, A> {
   90|      0|        let start = _fbb.start_table();
   91|      0|        hlfloatBuilder {
   92|      0|            fbb_: _fbb,
   93|      0|            start_: start,
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlfloat<'a>> {
   98|      0|        let o = self.fbb_.end_table(self.start_);
   99|      0|        flatbuffers::WIPOffset::new(o.value())
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl core::fmt::Debug for hlfloat<'_> {
  104|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  105|      0|        let mut ds = f.debug_struct("hlfloat");
  106|      0|        ds.field("value", &self.value());
  107|      0|        ds.finish()
  108|      0|    }
  109|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlint_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlintOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlint<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlint<'a> {
   21|       |    type Inner = hlint<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlint<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hlint { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hlintArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hlint<'bldr>> {
   42|      0|        let mut builder = hlintBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> i32 {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe { self._tab.get::<i32>(hlint::VT_VALUE, Some(0)).unwrap() }
   53|      0|    }
   54|       |}
   55|       |
   56|       |impl flatbuffers::Verifiable for hlint<'_> {
   57|       |    #[inline]
   58|      0|    fn run_verifier(
   59|      0|        v: &mut flatbuffers::Verifier,
   60|      0|        pos: usize,
   61|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   62|       |        use self::flatbuffers::Verifiable;
   63|      0|        v.visit_table(pos)?
   64|      0|            .visit_field::<i32>("value", Self::VT_VALUE, false)?
   65|      0|            .finish();
   66|      0|        Ok(())
   67|      0|    }
   68|       |}
   69|       |pub struct hlintArgs {
   70|       |    pub value: i32,
   71|       |}
   72|       |impl<'a> Default for hlintArgs {
   73|       |    #[inline]
   74|      0|    fn default() -> Self {
   75|      0|        hlintArgs { value: 0 }
   76|      0|    }
   77|       |}
   78|       |
   79|       |pub struct hlintBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   80|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   81|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   82|       |}
   83|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlintBuilder<'a, 'b, A> {
   84|       |    #[inline]
   85|      0|    pub fn add_value(&mut self, value: i32) {
   86|      0|        self.fbb_.push_slot::<i32>(hlint::VT_VALUE, value, 0);
   87|      0|    }
   88|       |    #[inline]
   89|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hlintBuilder<'a, 'b, A> {
   90|      0|        let start = _fbb.start_table();
   91|      0|        hlintBuilder {
   92|      0|            fbb_: _fbb,
   93|      0|            start_: start,
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlint<'a>> {
   98|      0|        let o = self.fbb_.end_table(self.start_);
   99|      0|        flatbuffers::WIPOffset::new(o.value())
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl core::fmt::Debug for hlint<'_> {
  104|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  105|      0|        let mut ds = f.debug_struct("hlint");
  106|      0|        ds.field("value", &self.value());
  107|      0|        ds.finish()
  108|      0|    }
  109|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hllong_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hllongOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hllong<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hllong<'a> {
   21|       |    type Inner = hllong<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hllong<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hllong { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hllongArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hllong<'bldr>> {
   42|      0|        let mut builder = hllongBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> i64 {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe { self._tab.get::<i64>(hllong::VT_VALUE, Some(0)).unwrap() }
   53|      0|    }
   54|       |}
   55|       |
   56|       |impl flatbuffers::Verifiable for hllong<'_> {
   57|       |    #[inline]
   58|      0|    fn run_verifier(
   59|      0|        v: &mut flatbuffers::Verifier,
   60|      0|        pos: usize,
   61|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   62|       |        use self::flatbuffers::Verifiable;
   63|      0|        v.visit_table(pos)?
   64|      0|            .visit_field::<i64>("value", Self::VT_VALUE, false)?
   65|      0|            .finish();
   66|      0|        Ok(())
   67|      0|    }
   68|       |}
   69|       |pub struct hllongArgs {
   70|       |    pub value: i64,
   71|       |}
   72|       |impl<'a> Default for hllongArgs {
   73|       |    #[inline]
   74|      0|    fn default() -> Self {
   75|      0|        hllongArgs { value: 0 }
   76|      0|    }
   77|       |}
   78|       |
   79|       |pub struct hllongBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   80|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   81|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   82|       |}
   83|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hllongBuilder<'a, 'b, A> {
   84|       |    #[inline]
   85|      0|    pub fn add_value(&mut self, value: i64) {
   86|      0|        self.fbb_.push_slot::<i64>(hllong::VT_VALUE, value, 0);
   87|      0|    }
   88|       |    #[inline]
   89|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hllongBuilder<'a, 'b, A> {
   90|      0|        let start = _fbb.start_table();
   91|      0|        hllongBuilder {
   92|      0|            fbb_: _fbb,
   93|      0|            start_: start,
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hllong<'a>> {
   98|      0|        let o = self.fbb_.end_table(self.start_);
   99|      0|        flatbuffers::WIPOffset::new(o.value())
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl core::fmt::Debug for hllong<'_> {
  104|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  105|      0|        let mut ds = f.debug_struct("hllong");
  106|      0|        ds.field("value", &self.value());
  107|      0|        ds.finish()
  108|      0|    }
  109|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlsizeprefixedbuffer_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlsizeprefixedbufferOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlsizeprefixedbuffer<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlsizeprefixedbuffer<'a> {
   21|       |    type Inner = hlsizeprefixedbuffer<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlsizeprefixedbuffer<'a> {
   31|       |    pub const VT_SIZE: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
   33|       |
   34|       |    #[inline]
   35|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   36|      0|        hlsizeprefixedbuffer { _tab: table }
   37|      0|    }
   38|       |    #[allow(unused_mut)]
   39|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   40|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   41|      0|        args: &'args hlsizeprefixedbufferArgs<'args>,
   42|      0|    ) -> flatbuffers::WIPOffset<hlsizeprefixedbuffer<'bldr>> {
   43|      0|        let mut builder = hlsizeprefixedbufferBuilder::new(_fbb);
   44|      0|        if let Some(x) = args.value {
   45|      0|            builder.add_value(x);
   46|      0|        }
   47|      0|        builder.add_size(args.size);
   48|      0|        builder.finish()
   49|      0|    }
   50|       |
   51|       |    #[inline]
   52|      0|    pub fn size(&self) -> i32 {
   53|      0|        // Safety:
   54|      0|        // Created from valid Table for this object
   55|      0|        // which contains a valid value in this slot
   56|      0|        unsafe {
   57|      0|            self._tab
   58|      0|                .get::<i32>(hlsizeprefixedbuffer::VT_SIZE, Some(0))
   59|      0|                .unwrap()
   60|      0|        }
   61|      0|    }
   62|       |    #[inline]
   63|      0|    pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
   64|      0|        // Safety:
   65|      0|        // Created from valid Table for this object
   66|      0|        // which contains a valid value in this slot
   67|      0|        unsafe {
   68|      0|            self._tab
   69|      0|                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
   70|      0|                    hlsizeprefixedbuffer::VT_VALUE,
   71|      0|                    None,
   72|      0|                )
   73|      0|        }
   74|      0|    }
   75|       |}
   76|       |
   77|       |impl flatbuffers::Verifiable for hlsizeprefixedbuffer<'_> {
   78|       |    #[inline]
   79|      0|    fn run_verifier(
   80|      0|        v: &mut flatbuffers::Verifier,
   81|      0|        pos: usize,
   82|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   83|       |        use self::flatbuffers::Verifiable;
   84|      0|        v.visit_table(pos)?
   85|      0|            .visit_field::<i32>("size", Self::VT_SIZE, false)?
   86|      0|            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
   87|      0|                "value",
   88|      0|                Self::VT_VALUE,
   89|      0|                false,
   90|      0|            )?
   91|      0|            .finish();
   92|      0|        Ok(())
   93|      0|    }
   94|       |}
   95|       |pub struct hlsizeprefixedbufferArgs<'a> {
   96|       |    pub size: i32,
   97|       |    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
   98|       |}
   99|       |impl<'a> Default for hlsizeprefixedbufferArgs<'a> {
  100|       |    #[inline]
  101|      0|    fn default() -> Self {
  102|      0|        hlsizeprefixedbufferArgs {
  103|      0|            size: 0,
  104|      0|            value: None,
  105|      0|        }
  106|      0|    }
  107|       |}
  108|       |
  109|       |pub struct hlsizeprefixedbufferBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  110|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  111|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  112|       |}
  113|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlsizeprefixedbufferBuilder<'a, 'b, A> {
  114|       |    #[inline]
  115|      0|    pub fn add_size(&mut self, size: i32) {
  116|      0|        self.fbb_
  117|      0|            .push_slot::<i32>(hlsizeprefixedbuffer::VT_SIZE, size, 0);
  118|      0|    }
  119|       |    #[inline]
  120|      0|    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
  121|      0|        self.fbb_
  122|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(hlsizeprefixedbuffer::VT_VALUE, value);
  123|      0|    }
  124|       |    #[inline]
  125|      0|    pub fn new(
  126|      0|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  127|      0|    ) -> hlsizeprefixedbufferBuilder<'a, 'b, A> {
  128|      0|        let start = _fbb.start_table();
  129|      0|        hlsizeprefixedbufferBuilder {
  130|      0|            fbb_: _fbb,
  131|      0|            start_: start,
  132|      0|        }
  133|      0|    }
  134|       |    #[inline]
  135|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlsizeprefixedbuffer<'a>> {
  136|      0|        let o = self.fbb_.end_table(self.start_);
  137|      0|        flatbuffers::WIPOffset::new(o.value())
  138|      0|    }
  139|       |}
  140|       |
  141|       |impl core::fmt::Debug for hlsizeprefixedbuffer<'_> {
  142|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  143|      0|        let mut ds = f.debug_struct("hlsizeprefixedbuffer");
  144|      0|        ds.field("size", &self.size());
  145|      0|        ds.field("value", &self.value());
  146|      0|        ds.finish()
  147|      0|    }
  148|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlstring_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlstringOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlstring<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlstring<'a> {
   21|       |    type Inner = hlstring<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlstring<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hlstring { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hlstringArgs<'args>,
   41|      0|    ) -> flatbuffers::WIPOffset<hlstring<'bldr>> {
   42|      0|        let mut builder = hlstringBuilder::new(_fbb);
   43|      0|        if let Some(x) = args.value {
   44|      0|            builder.add_value(x);
   45|      0|        }
   46|      0|        builder.finish()
   47|      0|    }
   48|       |
   49|       |    #[inline]
   50|      0|    pub fn value(&self) -> Option<&'a str> {
   51|      0|        // Safety:
   52|      0|        // Created from valid Table for this object
   53|      0|        // which contains a valid value in this slot
   54|      0|        unsafe {
   55|      0|            self._tab
   56|      0|                .get::<flatbuffers::ForwardsUOffset<&str>>(hlstring::VT_VALUE, None)
   57|      0|        }
   58|      0|    }
   59|       |}
   60|       |
   61|       |impl flatbuffers::Verifiable for hlstring<'_> {
   62|       |    #[inline]
   63|      0|    fn run_verifier(
   64|      0|        v: &mut flatbuffers::Verifier,
   65|      0|        pos: usize,
   66|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   67|       |        use self::flatbuffers::Verifiable;
   68|      0|        v.visit_table(pos)?
   69|      0|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
   70|      0|            .finish();
   71|      0|        Ok(())
   72|      0|    }
   73|       |}
   74|       |pub struct hlstringArgs<'a> {
   75|       |    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
   76|       |}
   77|       |impl<'a> Default for hlstringArgs<'a> {
   78|       |    #[inline]
   79|      0|    fn default() -> Self {
   80|      0|        hlstringArgs { value: None }
   81|      0|    }
   82|       |}
   83|       |
   84|       |pub struct hlstringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   85|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   86|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   87|       |}
   88|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlstringBuilder<'a, 'b, A> {
   89|       |    #[inline]
   90|      0|    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
   91|      0|        self.fbb_
   92|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(hlstring::VT_VALUE, value);
   93|      0|    }
   94|       |    #[inline]
   95|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hlstringBuilder<'a, 'b, A> {
   96|      0|        let start = _fbb.start_table();
   97|      0|        hlstringBuilder {
   98|      0|            fbb_: _fbb,
   99|      0|            start_: start,
  100|      0|        }
  101|      0|    }
  102|       |    #[inline]
  103|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlstring<'a>> {
  104|      0|        let o = self.fbb_.end_table(self.start_);
  105|      0|        flatbuffers::WIPOffset::new(o.value())
  106|      0|    }
  107|       |}
  108|       |
  109|       |impl core::fmt::Debug for hlstring<'_> {
  110|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  111|      0|        let mut ds = f.debug_struct("hlstring");
  112|      0|        ds.field("value", &self.value());
  113|      0|        ds.finish()
  114|      0|    }
  115|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hluint_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hluintOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hluint<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hluint<'a> {
   21|       |    type Inner = hluint<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hluint<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hluint { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hluintArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hluint<'bldr>> {
   42|      0|        let mut builder = hluintBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> u32 {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe { self._tab.get::<u32>(hluint::VT_VALUE, Some(0)).unwrap() }
   53|      0|    }
   54|       |}
   55|       |
   56|       |impl flatbuffers::Verifiable for hluint<'_> {
   57|       |    #[inline]
   58|      0|    fn run_verifier(
   59|      0|        v: &mut flatbuffers::Verifier,
   60|      0|        pos: usize,
   61|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   62|       |        use self::flatbuffers::Verifiable;
   63|      0|        v.visit_table(pos)?
   64|      0|            .visit_field::<u32>("value", Self::VT_VALUE, false)?
   65|      0|            .finish();
   66|      0|        Ok(())
   67|      0|    }
   68|       |}
   69|       |pub struct hluintArgs {
   70|       |    pub value: u32,
   71|       |}
   72|       |impl<'a> Default for hluintArgs {
   73|       |    #[inline]
   74|      0|    fn default() -> Self {
   75|      0|        hluintArgs { value: 0 }
   76|      0|    }
   77|       |}
   78|       |
   79|       |pub struct hluintBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   80|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   81|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   82|       |}
   83|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hluintBuilder<'a, 'b, A> {
   84|       |    #[inline]
   85|      0|    pub fn add_value(&mut self, value: u32) {
   86|      0|        self.fbb_.push_slot::<u32>(hluint::VT_VALUE, value, 0);
   87|      0|    }
   88|       |    #[inline]
   89|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hluintBuilder<'a, 'b, A> {
   90|      0|        let start = _fbb.start_table();
   91|      0|        hluintBuilder {
   92|      0|            fbb_: _fbb,
   93|      0|            start_: start,
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hluint<'a>> {
   98|      0|        let o = self.fbb_.end_table(self.start_);
   99|      0|        flatbuffers::WIPOffset::new(o.value())
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl core::fmt::Debug for hluint<'_> {
  104|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  105|      0|        let mut ds = f.debug_struct("hluint");
  106|      0|        ds.field("value", &self.value());
  107|      0|        ds.finish()
  108|      0|    }
  109|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlulong_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlulongOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlulong<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlulong<'a> {
   21|       |    type Inner = hlulong<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlulong<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hlulong { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hlulongArgs,
   41|      0|    ) -> flatbuffers::WIPOffset<hlulong<'bldr>> {
   42|      0|        let mut builder = hlulongBuilder::new(_fbb);
   43|      0|        builder.add_value(args.value);
   44|      0|        builder.finish()
   45|      0|    }
   46|       |
   47|       |    #[inline]
   48|      0|    pub fn value(&self) -> u64 {
   49|      0|        // Safety:
   50|      0|        // Created from valid Table for this object
   51|      0|        // which contains a valid value in this slot
   52|      0|        unsafe { self._tab.get::<u64>(hlulong::VT_VALUE, Some(0)).unwrap() }
   53|      0|    }
   54|       |}
   55|       |
   56|       |impl flatbuffers::Verifiable for hlulong<'_> {
   57|       |    #[inline]
   58|      0|    fn run_verifier(
   59|      0|        v: &mut flatbuffers::Verifier,
   60|      0|        pos: usize,
   61|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   62|       |        use self::flatbuffers::Verifiable;
   63|      0|        v.visit_table(pos)?
   64|      0|            .visit_field::<u64>("value", Self::VT_VALUE, false)?
   65|      0|            .finish();
   66|      0|        Ok(())
   67|      0|    }
   68|       |}
   69|       |pub struct hlulongArgs {
   70|       |    pub value: u64,
   71|       |}
   72|       |impl<'a> Default for hlulongArgs {
   73|       |    #[inline]
   74|      0|    fn default() -> Self {
   75|      0|        hlulongArgs { value: 0 }
   76|      0|    }
   77|       |}
   78|       |
   79|       |pub struct hlulongBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   80|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   81|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   82|       |}
   83|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlulongBuilder<'a, 'b, A> {
   84|       |    #[inline]
   85|      0|    pub fn add_value(&mut self, value: u64) {
   86|      0|        self.fbb_.push_slot::<u64>(hlulong::VT_VALUE, value, 0);
   87|      0|    }
   88|       |    #[inline]
   89|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hlulongBuilder<'a, 'b, A> {
   90|      0|        let start = _fbb.start_table();
   91|      0|        hlulongBuilder {
   92|      0|            fbb_: _fbb,
   93|      0|            start_: start,
   94|      0|        }
   95|      0|    }
   96|       |    #[inline]
   97|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlulong<'a>> {
   98|      0|        let o = self.fbb_.end_table(self.start_);
   99|      0|        flatbuffers::WIPOffset::new(o.value())
  100|      0|    }
  101|       |}
  102|       |
  103|       |impl core::fmt::Debug for hlulong<'_> {
  104|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  105|      0|        let mut ds = f.debug_struct("hlulong");
  106|      0|        ds.field("value", &self.value());
  107|      0|        ds.finish()
  108|      0|    }
  109|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlvecbytes_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlvecbytesOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlvecbytes<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlvecbytes<'a> {
   21|       |    type Inner = hlvecbytes<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlvecbytes<'a> {
   31|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        hlvecbytes { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|      0|        args: &'args hlvecbytesArgs<'args>,
   41|      0|    ) -> flatbuffers::WIPOffset<hlvecbytes<'bldr>> {
   42|      0|        let mut builder = hlvecbytesBuilder::new(_fbb);
   43|      0|        if let Some(x) = args.value {
   44|      0|            builder.add_value(x);
   45|      0|        }
   46|      0|        builder.finish()
   47|      0|    }
   48|       |
   49|       |    #[inline]
   50|      0|    pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
   51|      0|        // Safety:
   52|      0|        // Created from valid Table for this object
   53|      0|        // which contains a valid value in this slot
   54|      0|        unsafe {
   55|      0|            self._tab
   56|      0|                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
   57|      0|                    hlvecbytes::VT_VALUE,
   58|      0|                    None,
   59|      0|                )
   60|      0|        }
   61|      0|    }
   62|       |}
   63|       |
   64|       |impl flatbuffers::Verifiable for hlvecbytes<'_> {
   65|       |    #[inline]
   66|      0|    fn run_verifier(
   67|      0|        v: &mut flatbuffers::Verifier,
   68|      0|        pos: usize,
   69|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   70|       |        use self::flatbuffers::Verifiable;
   71|      0|        v.visit_table(pos)?
   72|      0|            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
   73|      0|                "value",
   74|      0|                Self::VT_VALUE,
   75|      0|                false,
   76|      0|            )?
   77|      0|            .finish();
   78|      0|        Ok(())
   79|      0|    }
   80|       |}
   81|       |pub struct hlvecbytesArgs<'a> {
   82|       |    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
   83|       |}
   84|       |impl<'a> Default for hlvecbytesArgs<'a> {
   85|       |    #[inline]
   86|      0|    fn default() -> Self {
   87|      0|        hlvecbytesArgs { value: None }
   88|      0|    }
   89|       |}
   90|       |
   91|       |pub struct hlvecbytesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   92|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   93|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   94|       |}
   95|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlvecbytesBuilder<'a, 'b, A> {
   96|       |    #[inline]
   97|      0|    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
   98|      0|        self.fbb_
   99|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(hlvecbytes::VT_VALUE, value);
  100|      0|    }
  101|       |    #[inline]
  102|      0|    pub fn new(
  103|      0|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  104|      0|    ) -> hlvecbytesBuilder<'a, 'b, A> {
  105|      0|        let start = _fbb.start_table();
  106|      0|        hlvecbytesBuilder {
  107|      0|            fbb_: _fbb,
  108|      0|            start_: start,
  109|      0|        }
  110|      0|    }
  111|       |    #[inline]
  112|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlvecbytes<'a>> {
  113|      0|        let o = self.fbb_.end_table(self.start_);
  114|      0|        flatbuffers::WIPOffset::new(o.value())
  115|      0|    }
  116|       |}
  117|       |
  118|       |impl core::fmt::Debug for hlvecbytes<'_> {
  119|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  120|      0|        let mut ds = f.debug_struct("hlvecbytes");
  121|      0|        ds.field("value", &self.value());
  122|      0|        ds.finish()
  123|      0|    }
  124|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/hlvoid_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum hlvoidOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct hlvoid<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for hlvoid<'a> {
   21|       |    type Inner = hlvoid<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> hlvoid<'a> {
   31|       |    #[inline]
   32|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   33|      0|        hlvoid { _tab: table }
   34|      0|    }
   35|       |    #[allow(unused_mut)]
   36|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   37|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   38|      0|        _args: &'args hlvoidArgs,
   39|      0|    ) -> flatbuffers::WIPOffset<hlvoid<'bldr>> {
   40|      0|        let mut builder = hlvoidBuilder::new(_fbb);
   41|      0|        builder.finish()
   42|      0|    }
   43|       |}
   44|       |
   45|       |impl flatbuffers::Verifiable for hlvoid<'_> {
   46|       |    #[inline]
   47|      0|    fn run_verifier(
   48|      0|        v: &mut flatbuffers::Verifier,
   49|      0|        pos: usize,
   50|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   51|       |        use self::flatbuffers::Verifiable;
   52|      0|        v.visit_table(pos)?.finish();
   53|      0|        Ok(())
   54|      0|    }
   55|       |}
   56|       |pub struct hlvoidArgs {}
   57|       |impl<'a> Default for hlvoidArgs {
   58|       |    #[inline]
   59|      0|    fn default() -> Self {
   60|      0|        hlvoidArgs {}
   61|      0|    }
   62|       |}
   63|       |
   64|       |pub struct hlvoidBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   65|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   66|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   67|       |}
   68|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> hlvoidBuilder<'a, 'b, A> {
   69|       |    #[inline]
   70|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> hlvoidBuilder<'a, 'b, A> {
   71|      0|        let start = _fbb.start_table();
   72|      0|        hlvoidBuilder {
   73|      0|            fbb_: _fbb,
   74|      0|            start_: start,
   75|      0|        }
   76|      0|    }
   77|       |    #[inline]
   78|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<hlvoid<'a>> {
   79|      0|        let o = self.fbb_.end_table(self.start_);
   80|      0|        flatbuffers::WIPOffset::new(o.value())
   81|      0|    }
   82|       |}
   83|       |
   84|       |impl core::fmt::Debug for hlvoid<'_> {
   85|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
   86|      0|        let mut ds = f.debug_struct("hlvoid");
   87|      0|        ds.finish()
   88|      0|    }
   89|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/host_function_definition_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum HostFunctionDefinitionOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct HostFunctionDefinition<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for HostFunctionDefinition<'a> {
   21|       |    type Inner = HostFunctionDefinition<'a>;
   22|       |    #[inline]
   23|     75|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|     75|        Self {
   25|     75|            _tab: flatbuffers::Table::new(buf, loc),
   26|     75|        }
   27|     75|    }
   28|       |}
   29|       |
   30|       |impl<'a> HostFunctionDefinition<'a> {
   31|       |    pub const VT_FUNCTION_NAME: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_PARAMETERS: flatbuffers::VOffsetT = 6;
   33|       |    pub const VT_RETURN_TYPE: flatbuffers::VOffsetT = 8;
   34|       |
   35|       |    #[inline]
   36|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   37|      0|        HostFunctionDefinition { _tab: table }
   38|      0|    }
   39|       |    #[allow(unused_mut)]
   40|    150|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   41|    150|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   42|    150|        args: &'args HostFunctionDefinitionArgs<'args>,
   43|    150|    ) -> flatbuffers::WIPOffset<HostFunctionDefinition<'bldr>> {
   44|    150|        let mut builder = HostFunctionDefinitionBuilder::new(_fbb);
   45|    150|        if let Some(x) = args.parameters {
   46|    150|            builder.add_parameters(x);
   47|    150|        }
                      ^0
   48|    150|        if let Some(x) = args.function_name {
   49|    150|            builder.add_function_name(x);
   50|    150|        }
                      ^0
   51|    150|        builder.add_return_type(args.return_type);
   52|    150|        builder.finish()
   53|    150|    }
   54|       |
   55|       |    #[inline]
   56|     75|    pub fn function_name(&self) -> &'a str {
   57|     75|        // Safety:
   58|     75|        // Created from valid Table for this object
   59|     75|        // which contains a valid value in this slot
   60|     75|        unsafe {
   61|     75|            self._tab
   62|     75|                .get::<flatbuffers::ForwardsUOffset<&str>>(
   63|     75|                    HostFunctionDefinition::VT_FUNCTION_NAME,
   64|     75|                    None,
   65|     75|                )
   66|     75|                .unwrap()
   67|     75|        }
   68|     75|    }
   69|       |    #[inline]
   70|      0|    pub fn key_compare_less_than(&self, o: &HostFunctionDefinition) -> bool {
   71|      0|        self.function_name() < o.function_name()
   72|      0|    }
   73|       |
   74|       |    #[inline]
   75|      0|    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
   76|      0|        let key = self.function_name();
   77|      0|        key.cmp(val)
   78|      0|    }
   79|       |    #[inline]
   80|     75|    pub fn parameters(&self) -> Option<flatbuffers::Vector<'a, ParameterType>> {
   81|     75|        // Safety:
   82|     75|        // Created from valid Table for this object
   83|     75|        // which contains a valid value in this slot
   84|     75|        unsafe {
   85|     75|            self._tab
   86|     75|                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ParameterType>>>(
   87|     75|                    HostFunctionDefinition::VT_PARAMETERS,
   88|     75|                    None,
   89|     75|                )
   90|     75|        }
   91|     75|    }
   92|       |    #[inline]
   93|     75|    pub fn return_type(&self) -> ReturnType {
   94|     75|        // Safety:
   95|     75|        // Created from valid Table for this object
   96|     75|        // which contains a valid value in this slot
   97|     75|        unsafe {
   98|     75|            self._tab
   99|     75|                .get::<ReturnType>(
  100|     75|                    HostFunctionDefinition::VT_RETURN_TYPE,
  101|     75|                    Some(ReturnType::hlint),
  102|     75|                )
  103|     75|                .unwrap()
  104|     75|        }
  105|     75|    }
  106|       |}
  107|       |
  108|       |impl flatbuffers::Verifiable for HostFunctionDefinition<'_> {
  109|       |    #[inline]
  110|     75|    fn run_verifier(
  111|     75|        v: &mut flatbuffers::Verifier,
  112|     75|        pos: usize,
  113|     75|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  114|       |        use self::flatbuffers::Verifiable;
  115|     75|        v.visit_table(pos)?
                                        ^0
  116|     75|            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
  117|     75|                "function_name",
  118|     75|                Self::VT_FUNCTION_NAME,
  119|     75|                true,
  120|     75|            )?
                           ^0
  121|     75|            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ParameterType>>>(
  122|     75|                "parameters",
  123|     75|                Self::VT_PARAMETERS,
  124|     75|                false,
  125|     75|            )?
                           ^0
  126|     75|            .visit_field::<ReturnType>("return_type", Self::VT_RETURN_TYPE, false)?
                                                                                                ^0
  127|     75|            .finish();
  128|     75|        Ok(())
  129|     75|    }
  130|       |}
  131|       |pub struct HostFunctionDefinitionArgs<'a> {
  132|       |    pub function_name: Option<flatbuffers::WIPOffset<&'a str>>,
  133|       |    pub parameters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ParameterType>>>,
  134|       |    pub return_type: ReturnType,
  135|       |}
  136|       |impl<'a> Default for HostFunctionDefinitionArgs<'a> {
  137|       |    #[inline]
  138|      0|    fn default() -> Self {
  139|      0|        HostFunctionDefinitionArgs {
  140|      0|            function_name: None, // required field
  141|      0|            parameters: None,
  142|      0|            return_type: ReturnType::hlint,
  143|      0|        }
  144|      0|    }
  145|       |}
  146|       |
  147|       |pub struct HostFunctionDefinitionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  148|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  149|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  150|       |}
  151|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HostFunctionDefinitionBuilder<'a, 'b, A> {
  152|       |    #[inline]
  153|    150|    pub fn add_function_name(&mut self, function_name: flatbuffers::WIPOffset<&'b str>) {
  154|    150|        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
  155|    150|            HostFunctionDefinition::VT_FUNCTION_NAME,
  156|    150|            function_name,
  157|    150|        );
  158|    150|    }
  159|       |    #[inline]
  160|    150|    pub fn add_parameters(
  161|    150|        &mut self,
  162|    150|        parameters: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ParameterType>>,
  163|    150|    ) {
  164|    150|        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
  165|    150|            HostFunctionDefinition::VT_PARAMETERS,
  166|    150|            parameters,
  167|    150|        );
  168|    150|    }
  169|       |    #[inline]
  170|    150|    pub fn add_return_type(&mut self, return_type: ReturnType) {
  171|    150|        self.fbb_.push_slot::<ReturnType>(
  172|    150|            HostFunctionDefinition::VT_RETURN_TYPE,
  173|    150|            return_type,
  174|    150|            ReturnType::hlint,
  175|    150|        );
  176|    150|    }
  177|       |    #[inline]
  178|    150|    pub fn new(
  179|    150|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  180|    150|    ) -> HostFunctionDefinitionBuilder<'a, 'b, A> {
  181|    150|        let start = _fbb.start_table();
  182|    150|        HostFunctionDefinitionBuilder {
  183|    150|            fbb_: _fbb,
  184|    150|            start_: start,
  185|    150|        }
  186|    150|    }
  187|       |    #[inline]
  188|    150|    pub fn finish(self) -> flatbuffers::WIPOffset<HostFunctionDefinition<'a>> {
  189|    150|        let o = self.fbb_.end_table(self.start_);
  190|    150|        self.fbb_
  191|    150|            .required(o, HostFunctionDefinition::VT_FUNCTION_NAME, "function_name");
  192|    150|        flatbuffers::WIPOffset::new(o.value())
  193|    150|    }
  194|       |}
  195|       |
  196|       |impl core::fmt::Debug for HostFunctionDefinition<'_> {
  197|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  198|      0|        let mut ds = f.debug_struct("HostFunctionDefinition");
  199|      0|        ds.field("function_name", &self.function_name());
  200|      0|        ds.field("parameters", &self.parameters());
  201|      0|        ds.field("return_type", &self.return_type());
  202|      0|        ds.finish()
  203|      0|    }
  204|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/host_function_details_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum HostFunctionDetailsOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct HostFunctionDetails<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for HostFunctionDetails<'a> {
   21|       |    type Inner = HostFunctionDetails<'a>;
   22|       |    #[inline]
   23|     71|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|     71|        Self {
   25|     71|            _tab: flatbuffers::Table::new(buf, loc),
   26|     71|        }
   27|     71|    }
   28|       |}
   29|       |
   30|       |impl<'a> HostFunctionDetails<'a> {
   31|       |    pub const VT_FUNCTIONS: flatbuffers::VOffsetT = 4;
   32|       |
   33|       |    #[inline]
   34|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   35|      0|        HostFunctionDetails { _tab: table }
   36|      0|    }
   37|       |    #[allow(unused_mut)]
   38|    142|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   39|    142|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   40|    142|        args: &'args HostFunctionDetailsArgs<'args>,
   41|    142|    ) -> flatbuffers::WIPOffset<HostFunctionDetails<'bldr>> {
   42|    142|        let mut builder = HostFunctionDetailsBuilder::new(_fbb);
   43|    142|        if let Some(x) = args.functions {
   44|    142|            builder.add_functions(x);
   45|    142|        }
                      ^0
   46|    142|        builder.finish()
   47|    142|    }
   48|       |
   49|       |    #[inline]
   50|     71|    pub fn functions(
   51|     71|        &self,
   52|     71|    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HostFunctionDefinition<'a>>>>
   53|     71|    {
   54|     71|        // Safety:
   55|     71|        // Created from valid Table for this object
   56|     71|        // which contains a valid value in this slot
   57|     71|        unsafe {
   58|     71|            self._tab.get::<flatbuffers::ForwardsUOffset<
   59|     71|                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HostFunctionDefinition>>,
   60|     71|            >>(HostFunctionDetails::VT_FUNCTIONS, None)
   61|     71|        }
   62|     71|    }
   63|       |}
   64|       |
   65|       |impl flatbuffers::Verifiable for HostFunctionDetails<'_> {
   66|       |    #[inline]
   67|     71|    fn run_verifier(
   68|     71|        v: &mut flatbuffers::Verifier,
   69|     71|        pos: usize,
   70|     71|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
   71|       |        use self::flatbuffers::Verifiable;
   72|     71|        v.visit_table(pos)?
                                        ^0
   73|     71|            .visit_field::<flatbuffers::ForwardsUOffset<
   74|     71|                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HostFunctionDefinition>>,
   75|     71|            >>("functions", Self::VT_FUNCTIONS, false)?
                                                                    ^0
   76|     71|            .finish();
   77|     71|        Ok(())
   78|     71|    }
   79|       |}
   80|       |pub struct HostFunctionDetailsArgs<'a> {
   81|       |    pub functions: Option<
   82|       |        flatbuffers::WIPOffset<
   83|       |            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HostFunctionDefinition<'a>>>,
   84|       |        >,
   85|       |    >,
   86|       |}
   87|       |impl<'a> Default for HostFunctionDetailsArgs<'a> {
   88|       |    #[inline]
   89|      0|    fn default() -> Self {
   90|      0|        HostFunctionDetailsArgs { functions: None }
   91|      0|    }
   92|       |}
   93|       |
   94|       |pub struct HostFunctionDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
   95|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
   96|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
   97|       |}
   98|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HostFunctionDetailsBuilder<'a, 'b, A> {
   99|       |    #[inline]
  100|    142|    pub fn add_functions(
  101|    142|        &mut self,
  102|    142|        functions: flatbuffers::WIPOffset<
  103|    142|            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<HostFunctionDefinition<'b>>>,
  104|    142|        >,
  105|    142|    ) {
  106|    142|        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
  107|    142|            HostFunctionDetails::VT_FUNCTIONS,
  108|    142|            functions,
  109|    142|        );
  110|    142|    }
  111|       |    #[inline]
  112|    142|    pub fn new(
  113|    142|        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  114|    142|    ) -> HostFunctionDetailsBuilder<'a, 'b, A> {
  115|    142|        let start = _fbb.start_table();
  116|    142|        HostFunctionDetailsBuilder {
  117|    142|            fbb_: _fbb,
  118|    142|            start_: start,
  119|    142|        }
  120|    142|    }
  121|       |    #[inline]
  122|    142|    pub fn finish(self) -> flatbuffers::WIPOffset<HostFunctionDetails<'a>> {
  123|    142|        let o = self.fbb_.end_table(self.start_);
  124|    142|        flatbuffers::WIPOffset::new(o.value())
  125|    142|    }
  126|       |}
  127|       |
  128|       |impl core::fmt::Debug for HostFunctionDetails<'_> {
  129|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  130|      0|        let mut ds = f.debug_struct("HostFunctionDetails");
  131|      0|        ds.field("functions", &self.functions());
  132|      0|        ds.finish()
  133|      0|    }
  134|       |}
  135|       |#[inline]
  136|       |/// Verifies that a buffer of bytes contains a `HostFunctionDetails`
  137|       |/// and returns it.
  138|       |/// Note that verification is still experimental and may not
  139|       |/// catch every error, or be maximally performant. For the
  140|       |/// previous, unchecked, behavior use
  141|       |/// `root_as_host_function_details_unchecked`.
  142|      0|pub fn root_as_host_function_details(
  143|      0|    buf: &[u8],
  144|      0|) -> Result<HostFunctionDetails, flatbuffers::InvalidFlatbuffer> {
  145|      0|    flatbuffers::root::<HostFunctionDetails>(buf)
  146|      0|}
  147|       |#[inline]
  148|       |/// Verifies that a buffer of bytes contains a size prefixed
  149|       |/// `HostFunctionDetails` and returns it.
  150|       |/// Note that verification is still experimental and may not
  151|       |/// catch every error, or be maximally performant. For the
  152|       |/// previous, unchecked, behavior use
  153|       |/// `size_prefixed_root_as_host_function_details_unchecked`.
  154|      0|pub fn size_prefixed_root_as_host_function_details(
  155|      0|    buf: &[u8],
  156|      0|) -> Result<HostFunctionDetails, flatbuffers::InvalidFlatbuffer> {
  157|      0|    flatbuffers::size_prefixed_root::<HostFunctionDetails>(buf)
  158|      0|}
  159|       |#[inline]
  160|       |/// Verifies, with the given options, that a buffer of bytes
  161|       |/// contains a `HostFunctionDetails` and returns it.
  162|       |/// Note that verification is still experimental and may not
  163|       |/// catch every error, or be maximally performant. For the
  164|       |/// previous, unchecked, behavior use
  165|       |/// `root_as_host_function_details_unchecked`.
  166|      0|pub fn root_as_host_function_details_with_opts<'b, 'o>(
  167|      0|    opts: &'o flatbuffers::VerifierOptions,
  168|      0|    buf: &'b [u8],
  169|      0|) -> Result<HostFunctionDetails<'b>, flatbuffers::InvalidFlatbuffer> {
  170|      0|    flatbuffers::root_with_opts::<HostFunctionDetails<'b>>(opts, buf)
  171|      0|}
  172|       |#[inline]
  173|       |/// Verifies, with the given verifier options, that a buffer of
  174|       |/// bytes contains a size prefixed `HostFunctionDetails` and returns
  175|       |/// it. Note that verification is still experimental and may not
  176|       |/// catch every error, or be maximally performant. For the
  177|       |/// previous, unchecked, behavior use
  178|       |/// `root_as_host_function_details_unchecked`.
  179|      0|pub fn size_prefixed_root_as_host_function_details_with_opts<'b, 'o>(
  180|      0|    opts: &'o flatbuffers::VerifierOptions,
  181|      0|    buf: &'b [u8],
  182|      0|) -> Result<HostFunctionDetails<'b>, flatbuffers::InvalidFlatbuffer> {
  183|      0|    flatbuffers::size_prefixed_root_with_opts::<HostFunctionDetails<'b>>(opts, buf)
  184|      0|}
  185|       |#[inline]
  186|       |/// Assumes, without verification, that a buffer of bytes contains a HostFunctionDetails and returns it.
  187|       |/// # Safety
  188|       |/// Callers must trust the given bytes do indeed contain a valid `HostFunctionDetails`.
  189|      0|pub unsafe fn root_as_host_function_details_unchecked(buf: &[u8]) -> HostFunctionDetails {
  190|      0|    flatbuffers::root_unchecked::<HostFunctionDetails>(buf)
  191|      0|}
  192|       |#[inline]
  193|       |/// Assumes, without verification, that a buffer of bytes contains a size prefixed HostFunctionDetails and returns it.
  194|       |/// # Safety
  195|       |/// Callers must trust the given bytes do indeed contain a valid size prefixed `HostFunctionDetails`.
  196|      0|pub unsafe fn size_prefixed_root_as_host_function_details_unchecked(
  197|      0|    buf: &[u8],
  198|      0|) -> HostFunctionDetails {
  199|      0|    flatbuffers::size_prefixed_root_unchecked::<HostFunctionDetails>(buf)
  200|      0|}
  201|       |#[inline]
  202|      0|pub fn finish_host_function_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  203|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  204|      0|    root: flatbuffers::WIPOffset<HostFunctionDetails<'a>>,
  205|      0|) {
  206|      0|    fbb.finish(root, None);
  207|      0|}
  208|       |
  209|       |#[inline]
  210|      0|pub fn finish_size_prefixed_host_function_details_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
  211|      0|    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  212|      0|    root: flatbuffers::WIPOffset<HostFunctionDetails<'a>>,
  213|      0|) {
  214|      0|    fbb.finish_size_prefixed(root, None);
  215|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/log_level_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_LOG_LEVEL: u8 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_LOG_LEVEL: u8 = 6;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_LOG_LEVEL: [LogLevel; 7] = [
   29|       |    LogLevel::Trace,
   30|       |    LogLevel::Debug,
   31|       |    LogLevel::Information,
   32|       |    LogLevel::Warning,
   33|       |    LogLevel::Error,
   34|       |    LogLevel::Critical,
   35|       |    LogLevel::None,
   36|       |];
   37|       |
   38|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   39|       |#[repr(transparent)]
   40|       |pub struct LogLevel(pub u8);
   41|       |#[allow(non_upper_case_globals)]
   42|       |impl LogLevel {
   43|       |    pub const Trace: Self = Self(0);
   44|       |    pub const Debug: Self = Self(1);
   45|       |    pub const Information: Self = Self(2);
   46|       |    pub const Warning: Self = Self(3);
   47|       |    pub const Error: Self = Self(4);
   48|       |    pub const Critical: Self = Self(5);
   49|       |    pub const None: Self = Self(6);
   50|       |
   51|       |    pub const ENUM_MIN: u8 = 0;
   52|       |    pub const ENUM_MAX: u8 = 6;
   53|       |    pub const ENUM_VALUES: &'static [Self] = &[
   54|       |        Self::Trace,
   55|       |        Self::Debug,
   56|       |        Self::Information,
   57|       |        Self::Warning,
   58|       |        Self::Error,
   59|       |        Self::Critical,
   60|       |        Self::None,
   61|       |    ];
   62|       |    /// Returns the variant's name or "" if unknown.
   63|      0|    pub fn variant_name(self) -> Option<&'static str> {
   64|      0|        match self {
   65|      0|            Self::Trace => Some("Trace"),
   66|      0|            Self::Debug => Some("Debug"),
   67|      0|            Self::Information => Some("Information"),
   68|      0|            Self::Warning => Some("Warning"),
   69|      0|            Self::Error => Some("Error"),
   70|      0|            Self::Critical => Some("Critical"),
   71|      0|            Self::None => Some("None"),
   72|      0|            _ => None,
   73|       |        }
   74|      0|    }
   75|       |}
   76|       |impl core::fmt::Debug for LogLevel {
   77|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
   78|      0|        if let Some(name) = self.variant_name() {
   79|      0|            f.write_str(name)
   80|       |        } else {
   81|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
   82|       |        }
   83|      0|    }
   84|       |}
   85|       |impl<'a> flatbuffers::Follow<'a> for LogLevel {
   86|       |    type Inner = Self;
   87|       |    #[inline]
   88|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   89|      0|        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
   90|      0|        Self(b)
   91|      0|    }
   92|       |}
   93|       |
   94|       |impl flatbuffers::Push for LogLevel {
   95|       |    type Output = LogLevel;
   96|       |    #[inline]
   97|      0|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
   98|      0|        flatbuffers::emplace_scalar::<u8>(dst, self.0);
   99|      0|    }
  100|       |}
  101|       |
  102|       |impl flatbuffers::EndianScalar for LogLevel {
  103|       |    type Scalar = u8;
  104|       |    #[inline]
  105|      0|    fn to_little_endian(self) -> u8 {
  106|      0|        self.0.to_le()
  107|      0|    }
  108|       |    #[inline]
  109|       |    #[allow(clippy::wrong_self_convention)]
  110|      0|    fn from_little_endian(v: u8) -> Self {
  111|      0|        let b = u8::from_le(v);
  112|      0|        Self(b)
  113|      0|    }
  114|       |}
  115|       |
  116|       |impl<'a> flatbuffers::Verifiable for LogLevel {
  117|       |    #[inline]
  118|      0|    fn run_verifier(
  119|      0|        v: &mut flatbuffers::Verifier,
  120|      0|        pos: usize,
  121|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  122|       |        use self::flatbuffers::Verifiable;
  123|      0|        u8::run_verifier(v, pos)
  124|      0|    }
  125|       |}
  126|       |
  127|       |impl flatbuffers::SimpleToVerifyInSlice for LogLevel {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/parameter_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |pub enum ParameterOffset {}
   14|       |#[derive(Copy, Clone, PartialEq)]
   15|       |
   16|       |pub struct Parameter<'a> {
   17|       |    pub _tab: flatbuffers::Table<'a>,
   18|       |}
   19|       |
   20|       |impl<'a> flatbuffers::Follow<'a> for Parameter<'a> {
   21|       |    type Inner = Parameter<'a>;
   22|       |    #[inline]
   23|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   24|      0|        Self {
   25|      0|            _tab: flatbuffers::Table::new(buf, loc),
   26|      0|        }
   27|      0|    }
   28|       |}
   29|       |
   30|       |impl<'a> Parameter<'a> {
   31|       |    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
   32|       |    pub const VT_VALUE: flatbuffers::VOffsetT = 6;
   33|       |
   34|       |    #[inline]
   35|      0|    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
   36|      0|        Parameter { _tab: table }
   37|      0|    }
   38|       |    #[allow(unused_mut)]
   39|      0|    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
   40|      0|        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
   41|      0|        args: &'args ParameterArgs,
   42|      0|    ) -> flatbuffers::WIPOffset<Parameter<'bldr>> {
   43|      0|        let mut builder = ParameterBuilder::new(_fbb);
   44|      0|        if let Some(x) = args.value {
   45|      0|            builder.add_value(x);
   46|      0|        }
   47|      0|        builder.add_value_type(args.value_type);
   48|      0|        builder.finish()
   49|      0|    }
   50|       |
   51|       |    #[inline]
   52|      0|    pub fn value_type(&self) -> ParameterValue {
   53|      0|        // Safety:
   54|      0|        // Created from valid Table for this object
   55|      0|        // which contains a valid value in this slot
   56|      0|        unsafe {
   57|      0|            self._tab
   58|      0|                .get::<ParameterValue>(Parameter::VT_VALUE_TYPE, Some(ParameterValue::NONE))
   59|      0|                .unwrap()
   60|      0|        }
   61|      0|    }
   62|       |    #[inline]
   63|      0|    pub fn value(&self) -> flatbuffers::Table<'a> {
   64|      0|        // Safety:
   65|      0|        // Created from valid Table for this object
   66|      0|        // which contains a valid value in this slot
   67|      0|        unsafe {
   68|      0|            self._tab
   69|      0|                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
   70|      0|                    Parameter::VT_VALUE,
   71|      0|                    None,
   72|      0|                )
   73|      0|                .unwrap()
   74|      0|        }
   75|      0|    }
   76|       |    #[inline]
   77|       |    #[allow(non_snake_case)]
   78|      0|    pub fn value_as_hlint(&self) -> Option<hlint<'a>> {
   79|      0|        if self.value_type() == ParameterValue::hlint {
   80|      0|            let u = self.value();
   81|      0|            // Safety:
   82|      0|            // Created from a valid Table for this object
   83|      0|            // Which contains a valid union in this slot
   84|      0|            Some(unsafe { hlint::init_from_table(u) })
   85|       |        } else {
   86|      0|            None
   87|       |        }
   88|      0|    }
   89|       |
   90|       |    #[inline]
   91|       |    #[allow(non_snake_case)]
   92|      0|    pub fn value_as_hluint(&self) -> Option<hluint<'a>> {
   93|      0|        if self.value_type() == ParameterValue::hluint {
   94|      0|            let u = self.value();
   95|      0|            // Safety:
   96|      0|            // Created from a valid Table for this object
   97|      0|            // Which contains a valid union in this slot
   98|      0|            Some(unsafe { hluint::init_from_table(u) })
   99|       |        } else {
  100|      0|            None
  101|       |        }
  102|      0|    }
  103|       |
  104|       |    #[inline]
  105|       |    #[allow(non_snake_case)]
  106|      0|    pub fn value_as_hllong(&self) -> Option<hllong<'a>> {
  107|      0|        if self.value_type() == ParameterValue::hllong {
  108|      0|            let u = self.value();
  109|      0|            // Safety:
  110|      0|            // Created from a valid Table for this object
  111|      0|            // Which contains a valid union in this slot
  112|      0|            Some(unsafe { hllong::init_from_table(u) })
  113|       |        } else {
  114|      0|            None
  115|       |        }
  116|      0|    }
  117|       |
  118|       |    #[inline]
  119|       |    #[allow(non_snake_case)]
  120|      0|    pub fn value_as_hlulong(&self) -> Option<hlulong<'a>> {
  121|      0|        if self.value_type() == ParameterValue::hlulong {
  122|      0|            let u = self.value();
  123|      0|            // Safety:
  124|      0|            // Created from a valid Table for this object
  125|      0|            // Which contains a valid union in this slot
  126|      0|            Some(unsafe { hlulong::init_from_table(u) })
  127|       |        } else {
  128|      0|            None
  129|       |        }
  130|      0|    }
  131|       |
  132|       |    #[inline]
  133|       |    #[allow(non_snake_case)]
  134|      0|    pub fn value_as_hlfloat(&self) -> Option<hlfloat<'a>> {
  135|      0|        if self.value_type() == ParameterValue::hlfloat {
  136|      0|            let u = self.value();
  137|      0|            // Safety:
  138|      0|            // Created from a valid Table for this object
  139|      0|            // Which contains a valid union in this slot
  140|      0|            Some(unsafe { hlfloat::init_from_table(u) })
  141|       |        } else {
  142|      0|            None
  143|       |        }
  144|      0|    }
  145|       |
  146|       |    #[inline]
  147|       |    #[allow(non_snake_case)]
  148|      0|    pub fn value_as_hldouble(&self) -> Option<hldouble<'a>> {
  149|      0|        if self.value_type() == ParameterValue::hldouble {
  150|      0|            let u = self.value();
  151|      0|            // Safety:
  152|      0|            // Created from a valid Table for this object
  153|      0|            // Which contains a valid union in this slot
  154|      0|            Some(unsafe { hldouble::init_from_table(u) })
  155|       |        } else {
  156|      0|            None
  157|       |        }
  158|      0|    }
  159|       |
  160|       |    #[inline]
  161|       |    #[allow(non_snake_case)]
  162|      0|    pub fn value_as_hlstring(&self) -> Option<hlstring<'a>> {
  163|      0|        if self.value_type() == ParameterValue::hlstring {
  164|      0|            let u = self.value();
  165|      0|            // Safety:
  166|      0|            // Created from a valid Table for this object
  167|      0|            // Which contains a valid union in this slot
  168|      0|            Some(unsafe { hlstring::init_from_table(u) })
  169|       |        } else {
  170|      0|            None
  171|       |        }
  172|      0|    }
  173|       |
  174|       |    #[inline]
  175|       |    #[allow(non_snake_case)]
  176|      0|    pub fn value_as_hlbool(&self) -> Option<hlbool<'a>> {
  177|      0|        if self.value_type() == ParameterValue::hlbool {
  178|      0|            let u = self.value();
  179|      0|            // Safety:
  180|      0|            // Created from a valid Table for this object
  181|      0|            // Which contains a valid union in this slot
  182|      0|            Some(unsafe { hlbool::init_from_table(u) })
  183|       |        } else {
  184|      0|            None
  185|       |        }
  186|      0|    }
  187|       |
  188|       |    #[inline]
  189|       |    #[allow(non_snake_case)]
  190|      0|    pub fn value_as_hlvecbytes(&self) -> Option<hlvecbytes<'a>> {
  191|      0|        if self.value_type() == ParameterValue::hlvecbytes {
  192|      0|            let u = self.value();
  193|      0|            // Safety:
  194|      0|            // Created from a valid Table for this object
  195|      0|            // Which contains a valid union in this slot
  196|      0|            Some(unsafe { hlvecbytes::init_from_table(u) })
  197|       |        } else {
  198|      0|            None
  199|       |        }
  200|      0|    }
  201|       |}
  202|       |
  203|       |impl flatbuffers::Verifiable for Parameter<'_> {
  204|       |    #[inline]
  205|      0|    fn run_verifier(
  206|      0|        v: &mut flatbuffers::Verifier,
  207|      0|        pos: usize,
  208|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  209|       |        use self::flatbuffers::Verifiable;
  210|      0|        v.visit_table(pos)?
  211|      0|            .visit_union::<ParameterValue, _>(
  212|      0|                "value_type",
  213|      0|                Self::VT_VALUE_TYPE,
  214|      0|                "value",
  215|      0|                Self::VT_VALUE,
  216|      0|                true,
  217|      0|                |key, v, pos| match key {
  218|      0|                    ParameterValue::hlint => v
  219|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlint>>(
  220|      0|                            "ParameterValue::hlint",
  221|      0|                            pos,
  222|      0|                        ),
  223|      0|                    ParameterValue::hluint => v
  224|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hluint>>(
  225|      0|                            "ParameterValue::hluint",
  226|      0|                            pos,
  227|      0|                        ),
  228|      0|                    ParameterValue::hllong => v
  229|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hllong>>(
  230|      0|                            "ParameterValue::hllong",
  231|      0|                            pos,
  232|      0|                        ),
  233|      0|                    ParameterValue::hlulong => v
  234|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlulong>>(
  235|      0|                            "ParameterValue::hlulong",
  236|      0|                            pos,
  237|      0|                        ),
  238|      0|                    ParameterValue::hlfloat => v
  239|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlfloat>>(
  240|      0|                            "ParameterValue::hlfloat",
  241|      0|                            pos,
  242|      0|                        ),
  243|      0|                    ParameterValue::hldouble => v
  244|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hldouble>>(
  245|      0|                            "ParameterValue::hldouble",
  246|      0|                            pos,
  247|      0|                        ),
  248|      0|                    ParameterValue::hlstring => v
  249|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlstring>>(
  250|      0|                            "ParameterValue::hlstring",
  251|      0|                            pos,
  252|      0|                        ),
  253|      0|                    ParameterValue::hlbool => v
  254|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlbool>>(
  255|      0|                            "ParameterValue::hlbool",
  256|      0|                            pos,
  257|      0|                        ),
  258|      0|                    ParameterValue::hlvecbytes => v
  259|      0|                        .verify_union_variant::<flatbuffers::ForwardsUOffset<hlvecbytes>>(
  260|      0|                            "ParameterValue::hlvecbytes",
  261|      0|                            pos,
  262|      0|                        ),
  263|      0|                    _ => Ok(()),
  264|      0|                },
  265|      0|            )?
  266|      0|            .finish();
  267|      0|        Ok(())
  268|      0|    }
  269|       |}
  270|       |pub struct ParameterArgs {
  271|       |    pub value_type: ParameterValue,
  272|       |    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
  273|       |}
  274|       |impl<'a> Default for ParameterArgs {
  275|       |    #[inline]
  276|      0|    fn default() -> Self {
  277|      0|        ParameterArgs {
  278|      0|            value_type: ParameterValue::NONE,
  279|      0|            value: None, // required field
  280|      0|        }
  281|      0|    }
  282|       |}
  283|       |
  284|       |pub struct ParameterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  285|       |    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  286|       |    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
  287|       |}
  288|       |impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterBuilder<'a, 'b, A> {
  289|       |    #[inline]
  290|      0|    pub fn add_value_type(&mut self, value_type: ParameterValue) {
  291|      0|        self.fbb_.push_slot::<ParameterValue>(
  292|      0|            Parameter::VT_VALUE_TYPE,
  293|      0|            value_type,
  294|      0|            ParameterValue::NONE,
  295|      0|        );
  296|      0|    }
  297|       |    #[inline]
  298|      0|    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
  299|      0|        self.fbb_
  300|      0|            .push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_VALUE, value);
  301|      0|    }
  302|       |    #[inline]
  303|      0|    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterBuilder<'a, 'b, A> {
  304|      0|        let start = _fbb.start_table();
  305|      0|        ParameterBuilder {
  306|      0|            fbb_: _fbb,
  307|      0|            start_: start,
  308|      0|        }
  309|      0|    }
  310|       |    #[inline]
  311|      0|    pub fn finish(self) -> flatbuffers::WIPOffset<Parameter<'a>> {
  312|      0|        let o = self.fbb_.end_table(self.start_);
  313|      0|        self.fbb_.required(o, Parameter::VT_VALUE, "value");
  314|      0|        flatbuffers::WIPOffset::new(o.value())
  315|      0|    }
  316|       |}
  317|       |
  318|       |impl core::fmt::Debug for Parameter<'_> {
  319|      0|    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
  320|      0|        let mut ds = f.debug_struct("Parameter");
  321|      0|        ds.field("value_type", &self.value_type());
  322|      0|        match self.value_type() {
  323|       |            ParameterValue::hlint => {
  324|      0|                if let Some(x) = self.value_as_hlint() {
  325|      0|                    ds.field("value", &x)
  326|       |                } else {
  327|      0|                    ds.field(
  328|      0|                        "value",
  329|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  330|      0|                    )
  331|       |                }
  332|       |            }
  333|       |            ParameterValue::hluint => {
  334|      0|                if let Some(x) = self.value_as_hluint() {
  335|      0|                    ds.field("value", &x)
  336|       |                } else {
  337|      0|                    ds.field(
  338|      0|                        "value",
  339|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  340|      0|                    )
  341|       |                }
  342|       |            }
  343|       |            ParameterValue::hllong => {
  344|      0|                if let Some(x) = self.value_as_hllong() {
  345|      0|                    ds.field("value", &x)
  346|       |                } else {
  347|      0|                    ds.field(
  348|      0|                        "value",
  349|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  350|      0|                    )
  351|       |                }
  352|       |            }
  353|       |            ParameterValue::hlulong => {
  354|      0|                if let Some(x) = self.value_as_hlulong() {
  355|      0|                    ds.field("value", &x)
  356|       |                } else {
  357|      0|                    ds.field(
  358|      0|                        "value",
  359|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  360|      0|                    )
  361|       |                }
  362|       |            }
  363|       |            ParameterValue::hlfloat => {
  364|      0|                if let Some(x) = self.value_as_hlfloat() {
  365|      0|                    ds.field("value", &x)
  366|       |                } else {
  367|      0|                    ds.field(
  368|      0|                        "value",
  369|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  370|      0|                    )
  371|       |                }
  372|       |            }
  373|       |            ParameterValue::hldouble => {
  374|      0|                if let Some(x) = self.value_as_hldouble() {
  375|      0|                    ds.field("value", &x)
  376|       |                } else {
  377|      0|                    ds.field(
  378|      0|                        "value",
  379|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  380|      0|                    )
  381|       |                }
  382|       |            }
  383|       |            ParameterValue::hlstring => {
  384|      0|                if let Some(x) = self.value_as_hlstring() {
  385|      0|                    ds.field("value", &x)
  386|       |                } else {
  387|      0|                    ds.field(
  388|      0|                        "value",
  389|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  390|      0|                    )
  391|       |                }
  392|       |            }
  393|       |            ParameterValue::hlbool => {
  394|      0|                if let Some(x) = self.value_as_hlbool() {
  395|      0|                    ds.field("value", &x)
  396|       |                } else {
  397|      0|                    ds.field(
  398|      0|                        "value",
  399|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  400|      0|                    )
  401|       |                }
  402|       |            }
  403|       |            ParameterValue::hlvecbytes => {
  404|      0|                if let Some(x) = self.value_as_hlvecbytes() {
  405|      0|                    ds.field("value", &x)
  406|       |                } else {
  407|      0|                    ds.field(
  408|      0|                        "value",
  409|      0|                        &"InvalidFlatbuffer: Union discriminant does not match value.",
  410|      0|                    )
  411|       |                }
  412|       |            }
  413|       |            _ => {
  414|      0|                let x: Option<()> = None;
  415|      0|                ds.field("value", &x)
  416|       |            }
  417|       |        };
  418|      0|        ds.finish()
  419|      0|    }
  420|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/parameter_type_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_PARAMETER_TYPE: u8 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_PARAMETER_TYPE: u8 = 8;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_PARAMETER_TYPE: [ParameterType; 9] = [
   29|       |    ParameterType::hlint,
   30|       |    ParameterType::hluint,
   31|       |    ParameterType::hllong,
   32|       |    ParameterType::hlulong,
   33|       |    ParameterType::hlfloat,
   34|       |    ParameterType::hldouble,
   35|       |    ParameterType::hlstring,
   36|       |    ParameterType::hlbool,
   37|       |    ParameterType::hlvecbytes,
   38|       |];
   39|       |
   40|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   41|       |#[repr(transparent)]
   42|       |pub struct ParameterType(pub u8);
   43|       |#[allow(non_upper_case_globals)]
   44|       |impl ParameterType {
   45|       |    pub const hlint: Self = Self(0);
   46|       |    pub const hluint: Self = Self(1);
   47|       |    pub const hllong: Self = Self(2);
   48|       |    pub const hlulong: Self = Self(3);
   49|       |    pub const hlfloat: Self = Self(4);
   50|       |    pub const hldouble: Self = Self(5);
   51|       |    pub const hlstring: Self = Self(6);
   52|       |    pub const hlbool: Self = Self(7);
   53|       |    pub const hlvecbytes: Self = Self(8);
   54|       |
   55|       |    pub const ENUM_MIN: u8 = 0;
   56|       |    pub const ENUM_MAX: u8 = 8;
   57|       |    pub const ENUM_VALUES: &'static [Self] = &[
   58|       |        Self::hlint,
   59|       |        Self::hluint,
   60|       |        Self::hllong,
   61|       |        Self::hlulong,
   62|       |        Self::hlfloat,
   63|       |        Self::hldouble,
   64|       |        Self::hlstring,
   65|       |        Self::hlbool,
   66|       |        Self::hlvecbytes,
   67|       |    ];
   68|       |    /// Returns the variant's name or "" if unknown.
   69|      0|    pub fn variant_name(self) -> Option<&'static str> {
   70|      0|        match self {
   71|      0|            Self::hlint => Some("hlint"),
   72|      0|            Self::hluint => Some("hluint"),
   73|      0|            Self::hllong => Some("hllong"),
   74|      0|            Self::hlulong => Some("hlulong"),
   75|      0|            Self::hlfloat => Some("hlfloat"),
   76|      0|            Self::hldouble => Some("hldouble"),
   77|      0|            Self::hlstring => Some("hlstring"),
   78|      0|            Self::hlbool => Some("hlbool"),
   79|      0|            Self::hlvecbytes => Some("hlvecbytes"),
   80|      0|            _ => None,
   81|       |        }
   82|      0|    }
   83|       |}
   84|       |impl core::fmt::Debug for ParameterType {
   85|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
   86|      0|        if let Some(name) = self.variant_name() {
   87|      0|            f.write_str(name)
   88|       |        } else {
   89|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
   90|       |        }
   91|      0|    }
   92|       |}
   93|       |impl<'a> flatbuffers::Follow<'a> for ParameterType {
   94|       |    type Inner = Self;
   95|       |    #[inline]
   96|     72|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
   97|     72|        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
   98|     72|        Self(b)
   99|     72|    }
  100|       |}
  101|       |
  102|       |impl flatbuffers::Push for ParameterType {
  103|       |    type Output = ParameterType;
  104|       |    #[inline]
  105|    144|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
  106|    144|        flatbuffers::emplace_scalar::<u8>(dst, self.0);
  107|    144|    }
  108|       |}
  109|       |
  110|       |impl flatbuffers::EndianScalar for ParameterType {
  111|       |    type Scalar = u8;
  112|       |    #[inline]
  113|      0|    fn to_little_endian(self) -> u8 {
  114|      0|        self.0.to_le()
  115|      0|    }
  116|       |    #[inline]
  117|       |    #[allow(clippy::wrong_self_convention)]
  118|      0|    fn from_little_endian(v: u8) -> Self {
  119|      0|        let b = u8::from_le(v);
  120|      0|        Self(b)
  121|      0|    }
  122|       |}
  123|       |
  124|       |impl<'a> flatbuffers::Verifiable for ParameterType {
  125|       |    #[inline]
  126|      0|    fn run_verifier(
  127|      0|        v: &mut flatbuffers::Verifier,
  128|      0|        pos: usize,
  129|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  130|       |        use self::flatbuffers::Verifiable;
  131|      0|        u8::run_verifier(v, pos)
  132|      0|    }
  133|       |}
  134|       |
  135|       |impl flatbuffers::SimpleToVerifyInSlice for ParameterType {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/parameter_value_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_PARAMETER_VALUE: u8 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_PARAMETER_VALUE: u8 = 9;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_PARAMETER_VALUE: [ParameterValue; 10] = [
   29|       |    ParameterValue::NONE,
   30|       |    ParameterValue::hlint,
   31|       |    ParameterValue::hluint,
   32|       |    ParameterValue::hllong,
   33|       |    ParameterValue::hlulong,
   34|       |    ParameterValue::hlfloat,
   35|       |    ParameterValue::hldouble,
   36|       |    ParameterValue::hlstring,
   37|       |    ParameterValue::hlbool,
   38|       |    ParameterValue::hlvecbytes,
   39|       |];
   40|       |
   41|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   42|       |#[repr(transparent)]
   43|       |pub struct ParameterValue(pub u8);
   44|       |#[allow(non_upper_case_globals)]
   45|       |impl ParameterValue {
   46|       |    pub const NONE: Self = Self(0);
   47|       |    pub const hlint: Self = Self(1);
   48|       |    pub const hluint: Self = Self(2);
   49|       |    pub const hllong: Self = Self(3);
   50|       |    pub const hlulong: Self = Self(4);
   51|       |    pub const hlfloat: Self = Self(5);
   52|       |    pub const hldouble: Self = Self(6);
   53|       |    pub const hlstring: Self = Self(7);
   54|       |    pub const hlbool: Self = Self(8);
   55|       |    pub const hlvecbytes: Self = Self(9);
   56|       |
   57|       |    pub const ENUM_MIN: u8 = 0;
   58|       |    pub const ENUM_MAX: u8 = 9;
   59|       |    pub const ENUM_VALUES: &'static [Self] = &[
   60|       |        Self::NONE,
   61|       |        Self::hlint,
   62|       |        Self::hluint,
   63|       |        Self::hllong,
   64|       |        Self::hlulong,
   65|       |        Self::hlfloat,
   66|       |        Self::hldouble,
   67|       |        Self::hlstring,
   68|       |        Self::hlbool,
   69|       |        Self::hlvecbytes,
   70|       |    ];
   71|       |    /// Returns the variant's name or "" if unknown.
   72|      0|    pub fn variant_name(self) -> Option<&'static str> {
   73|      0|        match self {
   74|      0|            Self::NONE => Some("NONE"),
   75|      0|            Self::hlint => Some("hlint"),
   76|      0|            Self::hluint => Some("hluint"),
   77|      0|            Self::hllong => Some("hllong"),
   78|      0|            Self::hlulong => Some("hlulong"),
   79|      0|            Self::hlfloat => Some("hlfloat"),
   80|      0|            Self::hldouble => Some("hldouble"),
   81|      0|            Self::hlstring => Some("hlstring"),
   82|      0|            Self::hlbool => Some("hlbool"),
   83|      0|            Self::hlvecbytes => Some("hlvecbytes"),
   84|      0|            _ => None,
   85|       |        }
   86|      0|    }
   87|       |}
   88|       |impl core::fmt::Debug for ParameterValue {
   89|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
   90|      0|        if let Some(name) = self.variant_name() {
   91|      0|            f.write_str(name)
   92|       |        } else {
   93|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
   94|       |        }
   95|      0|    }
   96|       |}
   97|       |impl<'a> flatbuffers::Follow<'a> for ParameterValue {
   98|       |    type Inner = Self;
   99|       |    #[inline]
  100|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
  101|      0|        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
  102|      0|        Self(b)
  103|      0|    }
  104|       |}
  105|       |
  106|       |impl flatbuffers::Push for ParameterValue {
  107|       |    type Output = ParameterValue;
  108|       |    #[inline]
  109|      0|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
  110|      0|        flatbuffers::emplace_scalar::<u8>(dst, self.0);
  111|      0|    }
  112|       |}
  113|       |
  114|       |impl flatbuffers::EndianScalar for ParameterValue {
  115|       |    type Scalar = u8;
  116|       |    #[inline]
  117|      0|    fn to_little_endian(self) -> u8 {
  118|      0|        self.0.to_le()
  119|      0|    }
  120|       |    #[inline]
  121|       |    #[allow(clippy::wrong_self_convention)]
  122|      0|    fn from_little_endian(v: u8) -> Self {
  123|      0|        let b = u8::from_le(v);
  124|      0|        Self(b)
  125|      0|    }
  126|       |}
  127|       |
  128|       |impl<'a> flatbuffers::Verifiable for ParameterValue {
  129|       |    #[inline]
  130|      0|    fn run_verifier(
  131|      0|        v: &mut flatbuffers::Verifier,
  132|      0|        pos: usize,
  133|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  134|       |        use self::flatbuffers::Verifiable;
  135|      0|        u8::run_verifier(v, pos)
  136|      0|    }
  137|       |}
  138|       |
  139|       |impl flatbuffers::SimpleToVerifyInSlice for ParameterValue {}
  140|       |pub struct ParameterValueUnionTableOffset {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/return_type_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_RETURN_TYPE: u8 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_RETURN_TYPE: u8 = 9;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_RETURN_TYPE: [ReturnType; 10] = [
   29|       |    ReturnType::hlint,
   30|       |    ReturnType::hluint,
   31|       |    ReturnType::hllong,
   32|       |    ReturnType::hlulong,
   33|       |    ReturnType::hlfloat,
   34|       |    ReturnType::hldouble,
   35|       |    ReturnType::hlstring,
   36|       |    ReturnType::hlbool,
   37|       |    ReturnType::hlvoid,
   38|       |    ReturnType::hlsizeprefixedbuffer,
   39|       |];
   40|       |
   41|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   42|       |#[repr(transparent)]
   43|       |pub struct ReturnType(pub u8);
   44|       |#[allow(non_upper_case_globals)]
   45|       |impl ReturnType {
   46|       |    pub const hlint: Self = Self(0);
   47|       |    pub const hluint: Self = Self(1);
   48|       |    pub const hllong: Self = Self(2);
   49|       |    pub const hlulong: Self = Self(3);
   50|       |    pub const hlfloat: Self = Self(4);
   51|       |    pub const hldouble: Self = Self(5);
   52|       |    pub const hlstring: Self = Self(6);
   53|       |    pub const hlbool: Self = Self(7);
   54|       |    pub const hlvoid: Self = Self(8);
   55|       |    pub const hlsizeprefixedbuffer: Self = Self(9);
   56|       |
   57|       |    pub const ENUM_MIN: u8 = 0;
   58|       |    pub const ENUM_MAX: u8 = 9;
   59|       |    pub const ENUM_VALUES: &'static [Self] = &[
   60|       |        Self::hlint,
   61|       |        Self::hluint,
   62|       |        Self::hllong,
   63|       |        Self::hlulong,
   64|       |        Self::hlfloat,
   65|       |        Self::hldouble,
   66|       |        Self::hlstring,
   67|       |        Self::hlbool,
   68|       |        Self::hlvoid,
   69|       |        Self::hlsizeprefixedbuffer,
   70|       |    ];
   71|       |    /// Returns the variant's name or "" if unknown.
   72|      0|    pub fn variant_name(self) -> Option<&'static str> {
   73|      0|        match self {
   74|      0|            Self::hlint => Some("hlint"),
   75|      0|            Self::hluint => Some("hluint"),
   76|      0|            Self::hllong => Some("hllong"),
   77|      0|            Self::hlulong => Some("hlulong"),
   78|      0|            Self::hlfloat => Some("hlfloat"),
   79|      0|            Self::hldouble => Some("hldouble"),
   80|      0|            Self::hlstring => Some("hlstring"),
   81|      0|            Self::hlbool => Some("hlbool"),
   82|      0|            Self::hlvoid => Some("hlvoid"),
   83|      0|            Self::hlsizeprefixedbuffer => Some("hlsizeprefixedbuffer"),
   84|      0|            _ => None,
   85|       |        }
   86|      0|    }
   87|       |}
   88|       |impl core::fmt::Debug for ReturnType {
   89|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
   90|      0|        if let Some(name) = self.variant_name() {
   91|      0|            f.write_str(name)
   92|       |        } else {
   93|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
   94|       |        }
   95|      0|    }
   96|       |}
   97|       |impl<'a> flatbuffers::Follow<'a> for ReturnType {
   98|       |    type Inner = Self;
   99|       |    #[inline]
  100|      3|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
  101|      3|        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
  102|      3|        Self(b)
  103|      3|    }
  104|       |}
  105|       |
  106|       |impl flatbuffers::Push for ReturnType {
  107|       |    type Output = ReturnType;
  108|       |    #[inline]
  109|      6|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
  110|      6|        flatbuffers::emplace_scalar::<u8>(dst, self.0);
  111|      6|    }
  112|       |}
  113|       |
  114|       |impl flatbuffers::EndianScalar for ReturnType {
  115|       |    type Scalar = u8;
  116|       |    #[inline]
  117|      0|    fn to_little_endian(self) -> u8 {
  118|      0|        self.0.to_le()
  119|      0|    }
  120|       |    #[inline]
  121|       |    #[allow(clippy::wrong_self_convention)]
  122|      0|    fn from_little_endian(v: u8) -> Self {
  123|      0|        let b = u8::from_le(v);
  124|      0|        Self(b)
  125|      0|    }
  126|       |}
  127|       |
  128|       |impl<'a> flatbuffers::Verifiable for ReturnType {
  129|       |    #[inline]
  130|      3|    fn run_verifier(
  131|      3|        v: &mut flatbuffers::Verifier,
  132|      3|        pos: usize,
  133|      3|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  134|       |        use self::flatbuffers::Verifiable;
  135|      3|        u8::run_verifier(v, pos)
  136|      3|    }
  137|       |}
  138|       |
  139|       |impl flatbuffers::SimpleToVerifyInSlice for ReturnType {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/flatbuffers/hyperlight/generated/return_value_generated.rs:
    1|       |// automatically generated by the FlatBuffers compiler, do not modify
    2|       |// @generated
    3|       |extern crate alloc;
    4|       |extern crate flatbuffers;
    5|       |use alloc::boxed::Box;
    6|       |use alloc::string::{String, ToString};
    7|       |use alloc::vec::Vec;
    8|       |use core::cmp::Ordering;
    9|       |use core::mem;
   10|       |
   11|       |use self::flatbuffers::{EndianScalar, Follow};
   12|       |use super::*;
   13|       |#[deprecated(
   14|       |    since = "2.0.0",
   15|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   16|       |)]
   17|       |pub const ENUM_MIN_RETURN_VALUE: u8 = 0;
   18|       |#[deprecated(
   19|       |    since = "2.0.0",
   20|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   21|       |)]
   22|       |pub const ENUM_MAX_RETURN_VALUE: u8 = 10;
   23|       |#[deprecated(
   24|       |    since = "2.0.0",
   25|       |    note = "Use associated constants instead. This will no longer be generated in 2021."
   26|       |)]
   27|       |#[allow(non_camel_case_types)]
   28|       |pub const ENUM_VALUES_RETURN_VALUE: [ReturnValue; 11] = [
   29|       |    ReturnValue::NONE,
   30|       |    ReturnValue::hlint,
   31|       |    ReturnValue::hluint,
   32|       |    ReturnValue::hllong,
   33|       |    ReturnValue::hlulong,
   34|       |    ReturnValue::hlfloat,
   35|       |    ReturnValue::hldouble,
   36|       |    ReturnValue::hlstring,
   37|       |    ReturnValue::hlbool,
   38|       |    ReturnValue::hlvoid,
   39|       |    ReturnValue::hlsizeprefixedbuffer,
   40|       |];
   41|       |
   42|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
   43|       |#[repr(transparent)]
   44|       |pub struct ReturnValue(pub u8);
   45|       |#[allow(non_upper_case_globals)]
   46|       |impl ReturnValue {
   47|       |    pub const NONE: Self = Self(0);
   48|       |    pub const hlint: Self = Self(1);
   49|       |    pub const hluint: Self = Self(2);
   50|       |    pub const hllong: Self = Self(3);
   51|       |    pub const hlulong: Self = Self(4);
   52|       |    pub const hlfloat: Self = Self(5);
   53|       |    pub const hldouble: Self = Self(6);
   54|       |    pub const hlstring: Self = Self(7);
   55|       |    pub const hlbool: Self = Self(8);
   56|       |    pub const hlvoid: Self = Self(9);
   57|       |    pub const hlsizeprefixedbuffer: Self = Self(10);
   58|       |
   59|       |    pub const ENUM_MIN: u8 = 0;
   60|       |    pub const ENUM_MAX: u8 = 10;
   61|       |    pub const ENUM_VALUES: &'static [Self] = &[
   62|       |        Self::NONE,
   63|       |        Self::hlint,
   64|       |        Self::hluint,
   65|       |        Self::hllong,
   66|       |        Self::hlulong,
   67|       |        Self::hlfloat,
   68|       |        Self::hldouble,
   69|       |        Self::hlstring,
   70|       |        Self::hlbool,
   71|       |        Self::hlvoid,
   72|       |        Self::hlsizeprefixedbuffer,
   73|       |    ];
   74|       |    /// Returns the variant's name or "" if unknown.
   75|      0|    pub fn variant_name(self) -> Option<&'static str> {
   76|      0|        match self {
   77|      0|            Self::NONE => Some("NONE"),
   78|      0|            Self::hlint => Some("hlint"),
   79|      0|            Self::hluint => Some("hluint"),
   80|      0|            Self::hllong => Some("hllong"),
   81|      0|            Self::hlulong => Some("hlulong"),
   82|      0|            Self::hlfloat => Some("hlfloat"),
   83|      0|            Self::hldouble => Some("hldouble"),
   84|      0|            Self::hlstring => Some("hlstring"),
   85|      0|            Self::hlbool => Some("hlbool"),
   86|      0|            Self::hlvoid => Some("hlvoid"),
   87|      0|            Self::hlsizeprefixedbuffer => Some("hlsizeprefixedbuffer"),
   88|      0|            _ => None,
   89|       |        }
   90|      0|    }
   91|       |}
   92|       |impl core::fmt::Debug for ReturnValue {
   93|      0|    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
   94|      0|        if let Some(name) = self.variant_name() {
   95|      0|            f.write_str(name)
   96|       |        } else {
   97|      0|            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
   98|       |        }
   99|      0|    }
  100|       |}
  101|       |impl<'a> flatbuffers::Follow<'a> for ReturnValue {
  102|       |    type Inner = Self;
  103|       |    #[inline]
  104|      0|    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
  105|      0|        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
  106|      0|        Self(b)
  107|      0|    }
  108|       |}
  109|       |
  110|       |impl flatbuffers::Push for ReturnValue {
  111|       |    type Output = ReturnValue;
  112|       |    #[inline]
  113|      0|    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
  114|      0|        flatbuffers::emplace_scalar::<u8>(dst, self.0);
  115|      0|    }
  116|       |}
  117|       |
  118|       |impl flatbuffers::EndianScalar for ReturnValue {
  119|       |    type Scalar = u8;
  120|       |    #[inline]
  121|      0|    fn to_little_endian(self) -> u8 {
  122|      0|        self.0.to_le()
  123|      0|    }
  124|       |    #[inline]
  125|       |    #[allow(clippy::wrong_self_convention)]
  126|      0|    fn from_little_endian(v: u8) -> Self {
  127|      0|        let b = u8::from_le(v);
  128|      0|        Self(b)
  129|      0|    }
  130|       |}
  131|       |
  132|       |impl<'a> flatbuffers::Verifiable for ReturnValue {
  133|       |    #[inline]
  134|      0|    fn run_verifier(
  135|      0|        v: &mut flatbuffers::Verifier,
  136|      0|        pos: usize,
  137|      0|    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
  138|       |        use self::flatbuffers::Verifiable;
  139|      0|        u8::run_verifier(v, pos)
  140|      0|    }
  141|       |}
  142|       |
  143|       |impl flatbuffers::SimpleToVerifyInSlice for ReturnValue {}
  144|       |pub struct ReturnValueUnionTableOffset {}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/outb.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use core::convert::TryFrom;
   18|       |
   19|       |use anyhow::{Error, anyhow};
   20|       |
   21|       |/// Exception codes for the x86 architecture.
   22|       |/// These are helpful to identify the type of exception that occurred
   23|       |/// together with OutBAction::Abort.
   24|       |#[repr(u8)]
   25|       |#[derive(Debug, Clone, Copy)]
   26|       |pub enum Exception {
   27|       |    DivideByZero = 0,
   28|       |    Debug = 1,
   29|       |    NonMaskableInterrupt = 2,
   30|       |    Breakpoint = 3,
   31|       |    Overflow = 4,
   32|       |    BoundRangeExceeded = 5,
   33|       |    InvalidOpcode = 6,
   34|       |    DeviceNotAvailable = 7,
   35|       |    DoubleFault = 8,
   36|       |    CoprocessorSegmentOverrun = 9,
   37|       |    InvalidTSS = 10,
   38|       |    SegmentNotPresent = 11,
   39|       |    StackSegmentFault = 12,
   40|       |    GeneralProtectionFault = 13,
   41|       |    PageFault = 14,
   42|       |    Reserved = 15,
   43|       |    X87FloatingPointException = 16,
   44|       |    AlignmentCheck = 17,
   45|       |    MachineCheck = 18,
   46|       |    SIMDFloatingPointException = 19,
   47|       |    VirtualizationException = 20,
   48|       |    SecurityException = 30,
   49|       |    NoException = 0xFF,
   50|       |}
   51|       |
   52|       |impl TryFrom<u8> for Exception {
   53|       |    type Error = Error;
   54|       |
   55|      0|    fn try_from(value: u8) -> Result<Self, Self::Error> {
   56|       |        use Exception::*;
   57|      0|        let exception = match value {
   58|      0|            0 => DivideByZero,
   59|      0|            1 => Debug,
   60|      0|            2 => NonMaskableInterrupt,
   61|      0|            3 => Breakpoint,
   62|      0|            4 => Overflow,
   63|      0|            5 => BoundRangeExceeded,
   64|      0|            6 => InvalidOpcode,
   65|      0|            7 => DeviceNotAvailable,
   66|      0|            8 => DoubleFault,
   67|      0|            9 => CoprocessorSegmentOverrun,
   68|      0|            10 => InvalidTSS,
   69|      0|            11 => SegmentNotPresent,
   70|      0|            12 => StackSegmentFault,
   71|      0|            13 => GeneralProtectionFault,
   72|      0|            14 => PageFault,
   73|      0|            15 => Reserved,
   74|      0|            16 => X87FloatingPointException,
   75|      0|            17 => AlignmentCheck,
   76|      0|            18 => MachineCheck,
   77|      0|            19 => SIMDFloatingPointException,
   78|      0|            20 => VirtualizationException,
   79|      0|            30 => SecurityException,
   80|      0|            0x7F => NoException,
   81|      0|            _ => return Err(anyhow!("Unknown exception code: {:#x}", value)),
   82|       |        };
   83|       |
   84|      0|        Ok(exception)
   85|      0|    }
   86|       |}
   87|       |
   88|       |/// Supported actions when issuing an OUTB actions by Hyperlight.
   89|       |/// - Log: for logging,
   90|       |/// - CallFunction: makes a call to a host function,
   91|       |/// - Abort: aborts the execution of the guest,
   92|       |/// - DebugPrint: prints a message to the host
   93|       |/// - TraceRecordStack: records the stack trace of the guest
   94|       |/// - TraceMemoryAlloc: records memory allocation events
   95|       |/// - TraceMemoryFree: records memory deallocation events
   96|       |/// - TraceRecord: records a trace event in the guest
   97|       |pub enum OutBAction {
   98|       |    Log = 99,
   99|       |    CallFunction = 101,
  100|       |    Abort = 102,
  101|       |    DebugPrint = 103,
  102|       |    #[cfg(feature = "unwind_guest")]
  103|       |    TraceRecordStack = 104,
  104|       |    #[cfg(feature = "mem_profile")]
  105|       |    TraceMemoryAlloc = 105,
  106|       |    #[cfg(feature = "mem_profile")]
  107|       |    TraceMemoryFree = 106,
  108|       |    #[cfg(feature = "trace_guest")]
  109|       |    TraceRecord = 107,
  110|       |}
  111|       |
  112|       |impl TryFrom<u16> for OutBAction {
  113|       |    type Error = anyhow::Error;
  114|      0|    fn try_from(val: u16) -> anyhow::Result<Self> {
  115|      0|        match val {
  116|      0|            99 => Ok(OutBAction::Log),
  117|      0|            101 => Ok(OutBAction::CallFunction),
  118|      0|            102 => Ok(OutBAction::Abort),
  119|      0|            103 => Ok(OutBAction::DebugPrint),
  120|       |            #[cfg(feature = "unwind_guest")]
  121|       |            104 => Ok(OutBAction::TraceRecordStack),
  122|       |            #[cfg(feature = "mem_profile")]
  123|       |            105 => Ok(OutBAction::TraceMemoryAlloc),
  124|       |            #[cfg(feature = "mem_profile")]
  125|       |            106 => Ok(OutBAction::TraceMemoryFree),
  126|       |            #[cfg(feature = "trace_guest")]
  127|       |            107 => Ok(OutBAction::TraceRecord),
  128|      0|            _ => Err(anyhow::anyhow!("Invalid OutBAction value: {}", val)),
  129|       |        }
  130|      0|    }
  131|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_common/src/resource.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! Shared operations around resources
   18|       |
   19|       |// "Needless" lifetimes are useful for clarity
   20|       |#![allow(clippy::needless_lifetimes)]
   21|       |
   22|       |use alloc::sync::Arc;
   23|       |
   24|       |#[cfg(feature = "std")]
   25|       |extern crate std;
   26|       |use core::marker::{PhantomData, Send};
   27|       |use core::ops::Deref;
   28|       |#[cfg(feature = "std")]
   29|       |use std::sync::{RwLock, RwLockReadGuard};
   30|       |
   31|       |#[cfg(not(feature = "std"))]
   32|       |use spin::{RwLock, RwLockReadGuard};
   33|       |
   34|       |/// The semantics of component model resources are, pleasingly,
   35|       |/// roughly compatible with those of Rust references, so we would like
   36|       |/// to use the more-or-less directly in interfaces generated by
   37|       |/// hyperlight_component_macro. Less pleasingly, it's not terribly
   38|       |/// easy to show the semantic agreement statically.
   39|       |///
   40|       |/// In particular, if the host calls into the guest and gives it a
   41|       |/// borrow of a resource, reentrant host function calls that use that
   42|       |/// borrow need to be able to resolve the original reference and use
   43|       |/// it in an appropriately scoped manner, but it is not simple to do
   44|       |/// this, because the core Hyperlight machinery doesn't offer an easy
   45|       |/// way to augment the host's context for the span of time of a guest
   46|       |/// function call.  This may be worth revisiting at some time, but in
   47|       |/// the meantime, it's easier to just do it dynamically.
   48|       |///
   49|       |/// # Safety
   50|       |/// Informally: this only creates SharedRead references, so having a
   51|       |/// bunch of them going at once is fine.  Safe Rust in the host can't
   52|       |/// use any earlier borrows (potentially invalidating these) until
   53|       |/// borrow passed into [`ResourceEntry::lend`] has expired.  Because
   54|       |/// that borrow outlives the [`LentResourceGuard`], it will not expire
   55|       |/// until that destructor is called. That destructor ensures that (a)
   56|       |/// there are no outstanding [`BorrowedResourceGuard`]s alive (since
   57|       |/// they would be holding the read side of the [`RwLock`] if they
   58|       |/// were), and that (b) the shared flag has been set to false, so
   59|       |/// [`ResourceEntry::borrow`] will never create another borrow
   60|       |pub enum ResourceEntry<T> {
   61|       |    Empty,
   62|       |    Owned(T),
   63|       |    Borrowed(Arc<RwLock<bool>>, *const T),
   64|       |}
   65|       |unsafe impl<T: Send> Send for ResourceEntry<T> {}
   66|       |
   67|       |pub struct LentResourceGuard<'a> {
   68|       |    flag: Arc<RwLock<bool>>,
   69|       |    already_revoked: bool,
   70|       |    _phantom: core::marker::PhantomData<&'a mut ()>,
   71|       |}
   72|       |impl<'a> LentResourceGuard<'a> {
   73|      0|    pub fn revoke_nonblocking(&mut self) -> bool {
   74|       |        #[cfg(feature = "std")]
   75|      0|        let Ok(mut flag) = self.flag.try_write() else {
   76|      0|            return false;
   77|       |        };
   78|       |        #[cfg(not(feature = "std"))]
   79|       |        let Some(mut flag) = self.flag.try_write() else {
   80|       |            return false;
   81|       |        };
   82|      0|        *flag = false;
   83|      0|        self.already_revoked = true;
   84|      0|        true
   85|      0|    }
   86|       |}
   87|       |impl<'a> Drop for LentResourceGuard<'a> {
   88|      0|    fn drop(&mut self) {
   89|      0|        if !self.already_revoked {
   90|       |            #[allow(unused_mut)] // it isn't actually unused
   91|      0|            let mut guard = self.flag.write();
   92|      0|            #[cfg(feature = "std")]
   93|      0|            // If a mutex that is just protecting us from our own
   94|      0|            // mistakes is poisoned, something is so seriously
   95|      0|            // wrong that dying is a sensible response.
   96|      0|            #[allow(clippy::unwrap_used)]
   97|      0|            {
   98|      0|                *guard.unwrap() = false;
   99|      0|            }
  100|       |            #[cfg(not(feature = "std"))]
  101|       |            {
  102|       |                *guard = false;
  103|       |            }
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |pub struct BorrowedResourceGuard<'a, T> {
  108|       |    _flag: Option<RwLockReadGuard<'a, bool>>,
  109|       |    reference: &'a T,
  110|       |}
  111|       |impl<'a, T> Deref for BorrowedResourceGuard<'a, T> {
  112|       |    type Target = T;
  113|      0|    fn deref(&self) -> &T {
  114|      0|        self.reference
  115|      0|    }
  116|       |}
  117|       |impl<T> ResourceEntry<T> {
  118|      0|    pub fn give(x: T) -> ResourceEntry<T> {
  119|      0|        ResourceEntry::Owned(x)
  120|      0|    }
  121|      0|    pub fn lend<'a>(x: &'a T) -> (LentResourceGuard<'a>, ResourceEntry<T>) {
  122|      0|        let flag = Arc::new(RwLock::new(true));
  123|      0|        (
  124|      0|            LentResourceGuard {
  125|      0|                flag: flag.clone(),
  126|      0|                already_revoked: false,
  127|      0|                _phantom: PhantomData {},
  128|      0|            },
  129|      0|            ResourceEntry::Borrowed(flag, x as *const T),
  130|      0|        )
  131|      0|    }
  132|      0|    pub fn borrow<'a>(&'a self) -> Option<BorrowedResourceGuard<'a, T>> {
  133|      0|        match self {
  134|      0|            ResourceEntry::Empty => None,
  135|      0|            ResourceEntry::Owned(t) => Some(BorrowedResourceGuard {
  136|      0|                _flag: None,
  137|      0|                reference: t,
  138|      0|            }),
  139|      0|            ResourceEntry::Borrowed(flag, t) => {
  140|      0|                let guard = flag.read();
  141|      0|                // If a mutex that is just protecting us from our own
  142|      0|                // mistakes is poisoned, something is so seriously
  143|      0|                // wrong that dying is a sensible response.
  144|      0|                #[allow(clippy::unwrap_used)]
  145|      0|                let flag = {
  146|      0|                    #[cfg(feature = "std")]
  147|      0|                    {
  148|      0|                        guard.unwrap()
  149|      0|                    }
  150|      0|                    #[cfg(not(feature = "std"))]
  151|      0|                    {
  152|      0|                        guard
  153|      0|                    }
  154|      0|                };
  155|      0|                if *flag {
  156|      0|                    Some(BorrowedResourceGuard {
  157|      0|                        _flag: Some(flag),
  158|      0|                        reference: unsafe { &**t },
  159|      0|                    })
  160|       |                } else {
  161|      0|                    None
  162|       |                }
  163|       |            }
  164|       |        }
  165|      0|    }
  166|      0|    pub fn take(&mut self) -> Option<T> {
  167|      0|        match core::mem::replace(self, ResourceEntry::Empty) {
  168|      0|            ResourceEntry::Owned(t) => Some(t),
  169|      0|            _ => None,
  170|       |        }
  171|      0|    }
  172|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_macro/src/lib.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! # Component-model bindgen macros
   18|       |//!
   19|       |//! These macros make it easy to use Wasm Component Model types
   20|       |//! (e.g. those described by WIT) to describe the interface between a
   21|       |//! Hyperlight host and guest.
   22|       |//!
   23|       |//! For both host and guest bindings, bindings generation takes in a
   24|       |//! binary-encoded wasm component, which should have roughly the
   25|       |//! structure of a binary-encoded WIT (in particular, component
   26|       |//! import/export kebab-names should have `wit:package/name` namespace
   27|       |//! structure, and the same two-level convention for wrapping a
   28|       |//! component type into an actual component should be adhered to). If
   29|       |//! you are using WIT as the input, it is easy to build such a file
   30|       |//! via `wasm-tools component wit -w -o file.wasm file.wit`.
   31|       |//!
   32|       |//! Both macros can take the path to such a file as a parameter, or,
   33|       |//! if one is not provided, will fall back to using the path in the
   34|       |//! environment variable `$WIT_WORLD`. A relative path provided either way
   35|       |//! will be resolved relative to `$CARGO_MANIFEST_DIR`.
   36|       |//!
   37|       |//! ## Debugging
   38|       |//!
   39|       |//! The generated code can be examined by setting the environment
   40|       |//! variable `$HYPERLIGHT_COMPONENT_MACRO_DEBUG=/path/to/file.rs`,
   41|       |//! which will result in the generated code being written to that
   42|       |//! file, which is then included back into the Rust source.
   43|       |//!
   44|       |//! The macros also can be configured to output a great deal of debug
   45|       |//! information about the internal elaboration and codegen
   46|       |//! phases. This is logged via the `log` and `env_logger` crates, so
   47|       |//! setting `RUST_LOG=debug` before running the compiler should
   48|       |//! suffice to produce this output.
   49|       |
   50|       |extern crate proc_macro;
   51|       |
   52|       |use hyperlight_component_util::*;
   53|       |
   54|       |/// Create host bindings for the wasm component type in the file
   55|       |/// passed in (or `$WIT_WORLD`, if nothing is passed in). This will
   56|       |/// produce all relevant types and trait implementations for the
   57|       |/// component type, as well as functions allowing the component to be
   58|       |/// instantiated inside a sandbox.
   59|       |///
   60|       |/// This includes both a primitive `register_host_functions`, which can
   61|       |/// be used to directly register the host functions on any sandbox
   62|       |/// (and which can easily be used with Hyperlight-Wasm), as well as an
   63|       |/// `instantiate()` method on the component trait that makes
   64|       |/// instantiating the sandbox particularly ergonomic in core
   65|       |/// Hyperlight.
   66|       |#[proc_macro]
   67|      1|pub fn host_bindgen(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
   68|      1|    let _ = env_logger::try_init();
   69|      1|    let path: Option<syn::LitStr> = syn::parse_macro_input!(input as Option<syn::LitStr>);
   70|      1|    let path = path
   71|      1|        .map(|x| x.value().into())
   72|      1|        .unwrap_or_else(|| std::env::var_os("WIT_WORLD").unwrap());
                                         ^0
   73|      1|    util::read_wit_type_from_file(path, |kebab_name, ct| {
   74|      1|        let decls = emit::run_state(false, false, |s| {
   75|      1|            rtypes::emit_toplevel(s, &kebab_name, ct);
   76|      1|            host::emit_toplevel(s, &kebab_name, ct);
   77|      1|        });
   78|      1|        util::emit_decls(decls).into()
   79|      1|    })
   80|      1|}
   81|       |
   82|       |/// Create the hyperlight_guest_init() function (which should be
   83|       |/// called in hyperlight_main()) for the wasm component type in the
   84|       |/// file passed in (or `$WIT_WORLD`, if nothing is passed in). This
   85|       |/// function registers Hyperlight functions for component exports
   86|       |/// (which are implemented by calling into the trait provided) and
   87|       |/// implements the relevant traits for a trivial Host type (by calling
   88|       |/// into the Hyperlight host).
   89|       |#[proc_macro]
   90|      0|pub fn guest_bindgen(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
   91|      0|    let _ = env_logger::try_init();
   92|      0|    let path: Option<syn::LitStr> = syn::parse_macro_input!(input as Option<syn::LitStr>);
   93|      0|    let path = path
   94|      0|        .map(|x| x.value().into())
   95|      0|        .unwrap_or_else(|| std::env::var_os("WIT_WORLD").unwrap());
   96|      0|    util::read_wit_type_from_file(path, |kebab_name, ct| {
   97|      0|        let decls = emit::run_state(true, false, |s| {
   98|      0|            // Emit type/trait definitions for all instances in the world
   99|      0|            rtypes::emit_toplevel(s, &kebab_name, ct);
  100|      0|            // Emit the host/guest function registrations
  101|      0|            guest::emit_toplevel(s, &kebab_name, ct);
  102|      0|        });
  103|      0|        // Use util::emit_decls() to choose between emitting the token
  104|      0|        // stream directly and emitting an include!() pointing at a
  105|      0|        // temporary file, depending on whether the user has requested
  106|      0|        // a debug temporary file be created.
  107|      0|        util::emit_decls(decls).into()
  108|      0|    })
  109|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/component.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! Just enough component parsing support to get at the actual types
   18|       |
   19|       |use wasmparser::Payload::{
   20|       |    ComponentAliasSection, ComponentExportSection, ComponentTypeSection, Version,
   21|       |};
   22|       |use wasmparser::{
   23|       |    ComponentAlias, ComponentExternalKind, ComponentOuterAliasKind, ComponentType,
   24|       |    ComponentTypeRef, Payload,
   25|       |};
   26|       |
   27|       |use crate::etypes::{Component, Ctx, Defined};
   28|       |
   29|       |/// From [`wasmparser::ComponentExport`], elaborate a deftype_e as per
   30|       |/// the specification.
   31|      4|fn raw_type_export_type<'p, 'a, 'c>(
   32|      4|    ctx: &'c Ctx<'p, 'a>,
   33|      4|    ce: &'c wasmparser::ComponentExport<'a>,
   34|      4|) -> &'c Defined<'a> {
   35|      0|    match ce.ty {
   36|      0|        Some(ComponentTypeRef::Component(n)) => match ctx.types.get(n as usize) {
   37|      0|            Some(t) => t,
   38|       |            None => {
   39|      0|                panic!("malformed component type export: ascription does not refer to a type");
   40|       |            }
   41|       |        },
   42|       |        Some(_) => {
   43|      0|            panic!(
   44|      0|                "malformed component type export: ascription does not refer to a component type"
   45|      0|            );
   46|       |        }
   47|      4|        None => match ctx.types.get(ce.index as usize) {
   48|      4|            Some(t) => t,
   49|       |            None => {
   50|      0|                panic!("malformed component type export: does not refer to a type");
   51|       |            }
   52|       |        },
   53|       |    }
   54|      4|}
   55|       |
   56|       |/// Find the last exported type in a component, since in wasm-encoded
   57|       |/// WIT this is typically the main world to use.  This is a very
   58|       |/// special case that just lets us pull a type out of a value-level
   59|       |///
   60|       |/// Precondition: The given iterator is
   61|       |/// - a component, whose
   62|       |/// - encoding version is 0xd exactly, and who
   63|       |/// - does not contain any value-level aliases, and whose
   64|       |/// - final export is a component type
   65|       |///
   66|       |/// Anything that is a "binary-encoded WIT" produced by a recent
   67|       |/// toolchain should satisfy this. On violation, this function will
   68|       |/// panic with an error message.
   69|       |///
   70|       |/// The reason we look for the last export is that the WIT binary
   71|       |/// encoding encodes any instance type imported/exported from the main
   72|       |/// component (a/k/a WIT world) as a type export, followed by a final
   73|       |/// type export for the type of the main component/world.
   74|       |///
   75|       |/// TODO: Allow the user to specify a specific export to use (or a WIT
   76|       |/// world name), since current WIT tooling can generate encoded
   77|       |/// packages with multiple component types in them.
   78|       |///
   79|       |/// TODO: Encode even more assumptions about WIT package structure
   80|       |/// (which are already there in rtypes/host/guest) and allow looking
   81|       |/// for a specific named world, instead of simply grabbing the last
   82|       |/// export.
   83|      1|pub fn read_component_single_exported_type<'a>(
   84|      1|    items: impl Iterator<Item = wasmparser::Result<Payload<'a>>>,
   85|      1|) -> Component<'a> {
   86|      1|    let mut ctx = Ctx::new(None, false);
   87|      1|    let mut last_idx = None;
   88|     13|    for x in items {
                      ^12
   89|     12|        match x {
   90|      1|            Ok(Version { num, encoding, .. }) => {
   91|      1|                if encoding != wasmparser::Encoding::Component {
   92|      0|                    panic!("wasm file is not a component")
   93|      1|                }
   94|      1|                if num != 0xd {
   95|      0|                    panic!("unknown component encoding version 0x{:x}\n", num);
   96|      1|                }
   97|       |            }
   98|      4|            Ok(ComponentTypeSection(ts)) => {
   99|      8|                for t in ts {
                                  ^4
  100|      4|                    match t {
  101|      4|                        Ok(ComponentType::Component(ct)) => {
  102|      4|                            let ct_ = ctx.elab_component(&ct);
  103|      4|                            ctx.types.push(Defined::Component(ct_.unwrap()));
  104|      4|                        }
  105|      0|                        _ => panic!("non-component type"),
  106|       |                    }
  107|       |                }
  108|       |            }
  109|      4|            Ok(ComponentExportSection(es)) => {
  110|      8|                for e in es {
                                  ^4
  111|      4|                    match e {
  112|      0|                        Err(_) => panic!("invalid export section"),
  113|      4|                        Ok(ce) => {
  114|      4|                            if ce.kind == ComponentExternalKind::Type {
  115|      4|                                last_idx = Some(ctx.types.len());
  116|      4|                                ctx.types.push(raw_type_export_type(&ctx, &ce).clone());
  117|      4|                            }
                                          ^0
  118|       |                        }
  119|       |                    }
  120|       |                }
  121|       |            }
  122|      0|            Ok(ComponentAliasSection(r#as)) => {
  123|      0|                for a in r#as {
  124|      0|                    match a {
  125|       |                        Ok(ComponentAlias::InstanceExport {
  126|       |                            kind: ComponentExternalKind::Type,
  127|       |                            ..
  128|       |                        })
  129|       |                        | Ok(ComponentAlias::Outer {
  130|       |                            kind: ComponentOuterAliasKind::Type,
  131|       |                            ..
  132|       |                        }) => {
  133|      0|                            panic!("Component outer type aliases are not supported")
  134|       |                        }
  135|       |                        // Anything else doesn't affect the index
  136|       |                        // space that we are interested in, so we can
  137|       |                        // safely ignore
  138|      0|                        _ => {}
  139|       |                    }
  140|       |                }
  141|       |            }
  142|       |
  143|       |            // No other component section should be terribly relevant
  144|       |            // for us.  We would not generally expect to find them in
  145|       |            // a file that just represents a type like this, but it
  146|       |            // seems like there are/may be a whole bunch of debugging
  147|       |            // custom sections, etc that might show up, so for now
  148|       |            // let's just ignore anything.
  149|      3|            _ => {}
  150|       |        }
  151|       |    }
  152|      1|    match last_idx {
  153|      0|        None => panic!("no exported type"),
  154|      1|        Some(n) => match ctx.types.into_iter().nth(n) {
  155|      1|            Some(Defined::Component(c)) => c,
  156|      0|            _ => panic!("final export is not component"),
  157|       |        },
  158|       |    }
  159|      1|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/elaborate.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! Component type elaboration
   18|       |//!
   19|       |//! This is a pretty direct port of the relevant sections of the OCaml
   20|       |//! reference interpreter, except that the approach to substitutions has
   21|       |//! been changed significantly. (Although the core capture-avoiding
   22|       |//! substitution routines are of course the same, the ways in which
   23|       |//! substitutions are represented/constructed are quite different; see
   24|       |//! substitute.rs for more details of the approach here).
   25|       |
   26|       |use wasmparser::{
   27|       |    ComponentAlias, ComponentDefinedType, ComponentFuncType, ComponentOuterAliasKind,
   28|       |    ComponentType, ComponentTypeDeclaration, ComponentTypeRef, ComponentValType,
   29|       |    CompositeInnerType, CoreType, InstanceTypeDeclaration, ModuleTypeDeclaration, OuterAliasKind,
   30|       |    PrimitiveValType, TypeBounds, TypeRef,
   31|       |};
   32|       |
   33|       |use crate::etypes::{
   34|       |    BoundedTyvar, Component, CoreDefined, CoreExportDecl, CoreExternDesc, CoreModule,
   35|       |    CoreOrComponentExternDesc, Ctx, Defined, ExternDecl, ExternDesc, FloatWidth, Func, Handleable,
   36|       |    Instance, IntWidth, Name, Param, QualifiedInstance, RecordField, Resource, ResourceId,
   37|       |    TypeBound, Tyvar, Value, VariantCase,
   38|       |};
   39|       |use crate::substitute::{self, Substitution, Unvoidable};
   40|       |use crate::tv::ResolvedTyvar;
   41|       |use crate::wf;
   42|       |
   43|       |mod basic_conversions {
   44|       |    //! Basic utility conversions between various spec and wasmparser
   45|       |    //! representations of extern kind/sorts
   46|       |
   47|       |    use wasmparser::{ComponentExternalKind, ExternalKind};
   48|       |
   49|       |    use crate::etypes::{CoreExternDesc, ExternDesc};
   50|       |    use crate::structure::{CoreSort, Sort};
   51|       |
   52|      0|    pub(super) fn sort_matches_core_ed(sort: Sort, ed: &CoreExternDesc) {
   53|      0|        match (sort, ed) {
   54|      0|            (Sort::Core(CoreSort::Func), CoreExternDesc::Func(_)) => (),
   55|      0|            (Sort::Core(CoreSort::Table), CoreExternDesc::Table(_)) => (),
   56|      0|            (Sort::Core(CoreSort::Memory), CoreExternDesc::Memory(_)) => (),
   57|      0|            (Sort::Core(CoreSort::Global), CoreExternDesc::Global(_)) => (),
   58|      0|            _ => panic!("sort does not match core extern descriptor"),
   59|       |        }
   60|      0|    }
   61|       |
   62|      0|    pub(super) fn external_kind(k: ExternalKind) -> Sort {
   63|      0|        match k {
   64|      0|            ExternalKind::Func => Sort::Core(CoreSort::Func),
   65|      0|            ExternalKind::Table => Sort::Core(CoreSort::Table),
   66|      0|            ExternalKind::Memory => Sort::Core(CoreSort::Memory),
   67|      0|            ExternalKind::Global => Sort::Core(CoreSort::Global),
   68|      0|            ExternalKind::Tag => panic!("core type tags are not supported"),
   69|       |        }
   70|      0|    }
   71|       |
   72|      0|    pub(super) fn sort_matches_ed<'a>(sort: Sort, ed: &ExternDesc<'a>) {
   73|      0|        match (sort, ed) {
   74|      0|            (Sort::Core(CoreSort::Module), ExternDesc::CoreModule(_)) => (),
   75|      0|            (Sort::Func, ExternDesc::Func(_)) => (),
   76|      0|            (Sort::Type, ExternDesc::Type(_)) => (),
   77|      0|            (Sort::Instance, ExternDesc::Instance(_)) => (),
   78|      0|            (Sort::Component, ExternDesc::Component(_)) => (),
   79|      0|            _ => panic!("sort does not match extern descriptor"),
   80|       |        }
   81|      0|    }
   82|       |
   83|      0|    pub(super) fn component_external_kind(k: ComponentExternalKind) -> Sort {
   84|      0|        match k {
   85|      0|            ComponentExternalKind::Module => Sort::Core(CoreSort::Module),
   86|      0|            ComponentExternalKind::Func => Sort::Func,
   87|      0|            ComponentExternalKind::Value => Sort::Value,
   88|      0|            ComponentExternalKind::Type => Sort::Type,
   89|      0|            ComponentExternalKind::Instance => Sort::Instance,
   90|      0|            ComponentExternalKind::Component => Sort::Component,
   91|       |        }
   92|      0|    }
   93|       |}
   94|       |use basic_conversions::*;
   95|       |
   96|       |#[derive(Debug)]
   97|       |#[allow(dead_code)]
   98|       |/// Elaboration-specific errors
   99|       |pub enum Error<'a> {
  100|       |    /// Innerizing an outer alias failed; this usually means that the
  101|       |    /// outer alias refers to a resource type or something like that.
  102|       |    InvalidOuterAlias(substitute::InnerizeError),
  103|       |    /// Innerizing an outer alias resulted in an ill-formed type; this
  104|       |    /// often also means that the outer alias refers to a resource
  105|       |    /// type or similar.
  106|       |    IllFormedOuterAlias(wf::Error<'a>),
  107|       |    /// The component type declarator should never have a resource
  108|       |    /// type in it, even though this is allowed by the grammar, since
  109|       |    /// there is no export (or instantiation) to generatively give it
  110|       |    /// identity.
  111|       |    ResourceInDeclarator,
  112|       |    /// A the typeidx inside an own/borrow handle should always point
  113|       |    /// to a resource type (either a bare resource, or, more usually,
  114|       |    /// an imported/exported type variable that is bounded by `(sub
  115|       |    /// resource)`.
  116|       |    HandleToNonResource,
  117|       |    /// Complex valtypes are allowed to use indirect type indices to
  118|       |    /// refer to another type, but the type index space is also used
  119|       |    /// for instance types, bare resource types, etc.  A malformed
  120|       |    /// complex value type which refers to a non-value type will
  121|       |    /// result in this error.
  122|       |    ValTypeRefToNonVal(Defined<'a>),
  123|       |    /// The finalisation/closing of a component or instance type
  124|       |    /// failed. This usually means that an exported type is referring
  125|       |    /// to a non-exported type variable or something along those
  126|       |    /// lines, which makes it impossible for the exported type to be
  127|       |    /// lifted out of the context.
  128|       |    ClosingError(substitute::ClosingError),
  129|       |    /// A finished component or instance type was ill-formed
  130|       |    IllFormed(wf::Error<'a>),
  131|       |}
  132|       |impl<'a> From<substitute::ClosingError> for Error<'a> {
  133|      0|    fn from(e: substitute::ClosingError) -> Error<'a> {
  134|      0|        Error::ClosingError(e)
  135|      0|    }
  136|       |}
  137|       |
  138|       |/// # Elaboration
  139|       |///
  140|       |/// Most of this is a very direct translation of the specification
  141|       |/// (section 3.4 Type Elaboration).
  142|       |impl<'p, 'a> Ctx<'p, 'a> {
  143|      5|    pub fn elab_component<'c>(
  144|      5|        &'c mut self,
  145|      5|        decls: &[ComponentTypeDeclaration<'a>],
  146|      5|    ) -> Result<Component<'a>, Error<'a>> {
  147|      5|        let mut ctx = Ctx::new(Some(self), false);
  148|      5|        let mut imports = Vec::new();
  149|      5|        let mut exports = Vec::new();
  150|     21|        for decl in decls {
                          ^16
  151|     16|            let (import, export) = ctx.elab_component_decl(decl)?;
                                                                              ^0
  152|     16|            if let Some(import) = import {
                                      ^2
  153|      2|                imports.push(import);
  154|     14|            }
  155|     16|            if let Some(export) = export {
                                      ^6
  156|      6|                exports.push(export);
  157|     10|            }
  158|       |        }
  159|      5|        ctx.finish_component(&imports, &exports)
  160|      5|    }
  161|       |
  162|      0|    fn elab_core_module_decl<'c>(
  163|      0|        &'c mut self,
  164|      0|        decl: &ModuleTypeDeclaration<'a>,
  165|      0|    ) -> (Option<wasmparser::Import<'a>>, Option<CoreExportDecl<'a>>) {
  166|      0|        match decl {
  167|      0|            ModuleTypeDeclaration::Import(i) => (Some(*i), None),
  168|      0|            ModuleTypeDeclaration::Type(rg) => {
  169|      0|                let ct = self.elab_core_type_rec(rg);
  170|      0|                self.core.types.push(ct);
  171|      0|                (None, None)
  172|       |            }
  173|       |            ModuleTypeDeclaration::OuterAlias {
  174|       |                kind: OuterAliasKind::Type,
  175|      0|                count,
  176|      0|                index,
  177|      0|            } => {
  178|      0|                let ct = self.parents().nth(*count as usize).unwrap().core.types[*index as usize]
  179|      0|                    .clone();
  180|      0|                self.core.types.push(ct);
  181|      0|                (None, None)
  182|       |            }
  183|      0|            ModuleTypeDeclaration::Export { name, ty } => (
  184|      0|                None,
  185|      0|                Some(CoreExportDecl {
  186|      0|                    name: Name { name },
  187|      0|                    desc: match ty {
  188|      0|                        TypeRef::Func(n) => match &self.core.types[*n as usize] {
  189|      0|                            CoreDefined::Func(ft) => CoreExternDesc::Func(ft.clone()),
  190|      0|                            _ => panic!(
  191|      0|                                "internal invariant violation: WasmParser function TypeRef refers to non-function"
  192|      0|                            ),
  193|       |                        },
  194|      0|                        TypeRef::Table(tt) => CoreExternDesc::Table(*tt),
  195|      0|                        TypeRef::Memory(mt) => CoreExternDesc::Memory(*mt),
  196|      0|                        TypeRef::Global(gt) => CoreExternDesc::Global(*gt),
  197|      0|                        TypeRef::Tag(_) => panic!("core type tags are not supported"),
  198|       |                    },
  199|       |                }),
  200|       |            ),
  201|       |        }
  202|      0|    }
  203|       |
  204|      0|    fn elab_core_module<'c>(&'c mut self, decls: &[ModuleTypeDeclaration<'a>]) -> CoreModule<'a> {
  205|      0|        let mut ctx = Ctx::new(Some(self), false);
  206|      0|        let mut imports = Vec::new();
  207|      0|        let mut exports = Vec::new();
  208|      0|        for decl in decls {
  209|      0|            let (import, export) = ctx.elab_core_module_decl(decl);
  210|      0|            if let Some(import) = import {
  211|      0|                imports.push(import)
  212|      0|            }
  213|      0|            if let Some(export) = export {
  214|      0|                exports.push(export)
  215|      0|            }
  216|       |        }
  217|      0|        CoreModule {
  218|      0|            _imports: imports,
  219|      0|            _exports: exports,
  220|      0|        }
  221|      0|    }
  222|       |
  223|      0|    fn elab_core_type_rec<'c>(&'c mut self, rg: &wasmparser::RecGroup) -> CoreDefined<'a> {
  224|      0|        match &rg.types().nth(0).unwrap().composite_type.inner {
  225|      0|            CompositeInnerType::Func(ft) => CoreDefined::Func(ft.clone()),
  226|      0|            _ => panic!("GC core types are not presently supported"),
  227|       |        }
  228|      0|    }
  229|       |
  230|      0|    fn elab_core_type<'c>(&'c mut self, ct: &wasmparser::CoreType<'a>) -> CoreDefined<'a> {
  231|      0|        match ct {
  232|      0|            CoreType::Rec(rg) => self.elab_core_type_rec(rg),
  233|      0|            CoreType::Module(ds) => CoreDefined::Module(self.elab_core_module(ds)),
  234|       |        }
  235|      0|    }
  236|       |
  237|       |    /// This tries to handle pretty much everything involved in alias
  238|       |    /// resolution and well-formedness checking. Since both core and
  239|       |    /// component aliases are largely similar, it can handle both and
  240|       |    /// has to return a union of core/component extern descriptors
  241|       |    /// that does not exist in the spec.
  242|      0|    fn resolve_alias<'c>(
  243|      0|        &'c mut self,
  244|      0|        alias: &ComponentAlias<'a>,
  245|      0|    ) -> Result<CoreOrComponentExternDesc<'a>, Error<'a>> {
  246|      0|        match alias {
  247|       |            ComponentAlias::InstanceExport {
  248|      0|                kind,
  249|      0|                instance_index,
  250|      0|                name,
  251|      0|            } => {
  252|      0|                let it = &self.instances[*instance_index as usize];
  253|      0|                let ed = &it
  254|      0|                    .exports
  255|      0|                    .iter()
  256|      0|                    .find(|e| e.kebab_name == *name)
  257|      0|                    .unwrap()
  258|      0|                    .desc;
  259|      0|                let sort = component_external_kind(*kind);
  260|      0|                sort_matches_ed(sort, ed);
  261|      0|                Ok(CoreOrComponentExternDesc::Component(ed.clone()))
  262|       |            }
  263|       |            ComponentAlias::CoreInstanceExport {
  264|      0|                kind,
  265|      0|                instance_index,
  266|      0|                name,
  267|      0|            } => {
  268|      0|                let it = &self.core.instances[*instance_index as usize];
  269|      0|                let ed = &it
  270|      0|                    .exports
  271|      0|                    .iter()
  272|      0|                    .find(|e| e.name.name == *name)
  273|      0|                    .unwrap()
  274|      0|                    .desc;
  275|      0|                let sort = external_kind(*kind);
  276|      0|                sort_matches_core_ed(sort, ed);
  277|      0|                Ok(CoreOrComponentExternDesc::Core(ed.clone()))
  278|       |            }
  279|      0|            ComponentAlias::Outer { kind, count, index } => {
  280|      0|                if *kind != ComponentOuterAliasKind::Type {
  281|      0|                    panic!("In types, only outer type aliases are allowed");
  282|      0|                }
  283|      0|                // Walk through each of the contexts between us and
  284|      0|                // the targeted type, so that we can innerize each one
  285|      0|                let mut ctxs = self.parents().take(*count as usize + 1).collect::<Vec<_>>();
  286|      0|                ctxs.reverse();
  287|      0|                let mut target_type = ctxs[0].types[*index as usize].clone();
  288|      0|                let mut ob_crossed = false;
  289|      0|                for ctxs_ in ctxs.windows(2) {
  290|      0|                    ob_crossed |= ctxs_[1].outer_boundary;
  291|      0|                    let sub = substitute::Innerize::new(ctxs_[0], ctxs_[1].outer_boundary);
  292|      0|                    target_type = sub
  293|      0|                        .defined(&target_type)
  294|      0|                        .map_err(Error::InvalidOuterAlias)?;
  295|       |                }
  296|      0|                if ob_crossed {
  297|      0|                    self.wf_defined(wf::DefinedTypePosition::export(), &target_type)
  298|      0|                        .map_err(Error::IllFormedOuterAlias)?;
  299|      0|                }
  300|      0|                Ok(CoreOrComponentExternDesc::Component(ExternDesc::Type(
  301|      0|                    target_type,
  302|      0|                )))
  303|       |            }
  304|       |        }
  305|      0|    }
  306|       |
  307|       |    /// Add a core extern descriptor to the context: whatever it
  308|       |    /// describes is added to the relevant index space
  309|      0|    fn add_core_ed<'c>(&'c mut self, ed: CoreExternDesc) {
  310|      0|        match ed {
  311|      0|            CoreExternDesc::Func(ft) => self.core.funcs.push(ft),
  312|      0|            CoreExternDesc::Table(tt) => self.core.tables.push(tt),
  313|      0|            CoreExternDesc::Memory(mt) => self.core.mems.push(mt),
  314|      0|            CoreExternDesc::Global(gt) => self.core.globals.push(gt),
  315|       |        }
  316|      0|    }
  317|       |
  318|       |    /// Add an extern descriptor to the context: whatever it describes
  319|       |    /// is added to the relevant index space. Note that this does not
  320|       |    /// handle stripping the type variables off of an instance type
  321|       |    /// (since `ExternDesc::Instance` doesn't have them); that should
  322|       |    /// have been done earlier. See for example the export instance
  323|       |    /// declarator case below, which converts the bound variables on
  324|       |    /// the instance type to context evars, and fixes them up in the
  325|       |    /// instance type, before calling add_ed.
  326|    146|    fn add_ed<'c>(&'c mut self, ed: &ExternDesc<'a>) {
  327|    146|        match ed {
  328|      0|            ExternDesc::CoreModule(cmd) => self.core.modules.push(cmd.clone()),
  329|    121|            ExternDesc::Func(ft) => self.funcs.push(ft.clone()),
  330|     17|            ExternDesc::Type(dt) => self.types.push(dt.clone()),
  331|      7|            ExternDesc::Instance(it) => self.instances.push(it.clone()),
  332|      1|            ExternDesc::Component(ct) => self.components.push(ct.clone()),
  333|       |        }
  334|    146|    }
  335|       |
  336|      0|    fn add_core_or_component_ed<'c>(&'c mut self, ed: CoreOrComponentExternDesc<'a>) {
  337|      0|        match ed {
  338|      0|            CoreOrComponentExternDesc::Core(ced) => self.add_core_ed(ced),
  339|      0|            CoreOrComponentExternDesc::Component(ed) => self.add_ed(&ed),
  340|       |        }
  341|      0|    }
  342|       |
  343|    312|    fn elab_value<'c>(&'c mut self, ctr: &ComponentValType) -> Result<Value<'a>, Error<'a>> {
  344|    312|        match ctr {
  345|    154|            ComponentValType::Type(n) => match &self.types[*n as usize] {
  346|    124|                Defined::Value(vt) => Ok(vt.clone()),
  347|     30|                dt @ Defined::Handleable(Handleable::Var(tv)) => match self.resolve_tyvar(tv) {
  348|     30|                    ResolvedTyvar::Definite(Defined::Value(vt)) => {
  349|     30|                        Ok(Value::Var(Some(tv.clone()), Box::new(vt)))
  350|       |                    }
  351|      0|                    _ => Err(Error::ValTypeRefToNonVal(dt.clone())),
  352|       |                },
  353|      0|                dt => Err(Error::ValTypeRefToNonVal(dt.clone())),
  354|       |            },
  355|    158|            ComponentValType::Primitive(pt) => Ok(match pt {
  356|      8|                PrimitiveValType::Bool => Value::Bool,
  357|      9|                PrimitiveValType::S8 => Value::S(IntWidth::I8),
  358|     18|                PrimitiveValType::U8 => Value::U(IntWidth::I8),
  359|      9|                PrimitiveValType::S16 => Value::S(IntWidth::I16),
  360|      6|                PrimitiveValType::U16 => Value::U(IntWidth::I16),
  361|      9|                PrimitiveValType::S32 => Value::S(IntWidth::I32),
  362|     12|                PrimitiveValType::U32 => Value::U(IntWidth::I32),
  363|      9|                PrimitiveValType::S64 => Value::S(IntWidth::I64),
  364|     15|                PrimitiveValType::U64 => Value::U(IntWidth::I64),
  365|      9|                PrimitiveValType::F32 => Value::F(FloatWidth::F32),
  366|      9|                PrimitiveValType::F64 => Value::F(FloatWidth::F64),
  367|     16|                PrimitiveValType::Char => Value::Char,
  368|     29|                PrimitiveValType::String => Value::String,
  369|      0|                PrimitiveValType::ErrorContext => panic!("async not yet supported"),
  370|       |            }),
  371|       |        }
  372|    312|    }
  373|       |
  374|     76|    fn elab_defined_value<'c>(
  375|     76|        &'c mut self,
  376|     76|        vt: &ComponentDefinedType<'a>,
  377|     76|    ) -> Result<Value<'a>, Error<'a>> {
  378|     76|        match vt {
  379|      0|            ComponentDefinedType::Primitive(pvt) => {
  380|      0|                self.elab_value(&ComponentValType::Primitive(*pvt))
  381|       |            }
  382|      3|            ComponentDefinedType::Record(rfs) => {
  383|      3|                let rfs = rfs
  384|      3|                    .iter()
  385|      6|                    .map(|(name, ty)| {
  386|      6|                        Ok::<_, Error<'a>>(RecordField {
  387|      6|                            name: Name { name },
  388|      6|                            ty: self.elab_value(ty)?,
                                                                 ^0
  389|       |                        })
  390|      6|                    })
  391|      3|                    .collect::<Result<Vec<_>, Error<'a>>>()?;
                                                                         ^0
  392|      3|                Ok(Value::Record(rfs))
  393|       |            }
  394|      3|            ComponentDefinedType::Variant(vcs) => {
  395|      3|                let vcs = vcs
  396|      3|                    .iter()
  397|      9|                    .map(|vc| {
  398|      9|                        Ok(VariantCase {
  399|      9|                            name: Name { name: vc.name },
  400|      9|                            ty: vc.ty.as_ref().map(|ty| self.elab_value(ty)).transpose()?,
                                                                      ^6                              ^0
  401|      9|                            refines: vc.refines,
  402|       |                        })
  403|      9|                    })
  404|      3|                    .collect::<Result<Vec<_>, Error<'a>>>()?;
                                                                         ^0
  405|      3|                Ok(Value::Variant(vcs))
  406|       |            }
  407|      6|            ComponentDefinedType::List(vt) => Ok(Value::List(Box::new(self.elab_value(vt)?))),
                                                                                                       ^0
  408|      3|            ComponentDefinedType::Tuple(vts) => Ok(Value::Tuple(
  409|      3|                vts.iter()
  410|      6|                    .map(|vt| self.elab_value(vt))
  411|      3|                    .collect::<Result<Vec<_>, Error<'a>>>()?,
                                                                         ^0
  412|       |            )),
  413|      6|            ComponentDefinedType::Flags(ns) => {
  414|    105|                Ok(Value::Flags(ns.iter().map(|n| Name { name: n }).collect()))
                                                                                ^6
  415|       |            }
  416|      3|            ComponentDefinedType::Enum(ns) => {
  417|      9|                Ok(Value::Enum(ns.iter().map(|n| Name { name: n }).collect()))
                                                                               ^3
  418|       |            }
  419|      3|            ComponentDefinedType::Option(vt) => Ok(Value::Option(Box::new(self.elab_value(vt)?))),
                                                                                                           ^0
  420|      3|            ComponentDefinedType::Result { ok, err } => Ok(Value::Result(
  421|      3|                Box::new(ok.map(|ok| self.elab_value(&ok)).transpose()?),
                                                                                    ^0
  422|      3|                Box::new(err.map(|err| self.elab_value(&err)).transpose()?),
                                                                                       ^0
  423|       |            )),
  424|      2|            ComponentDefinedType::Own(n) => match &self.types[*n as usize] {
  425|      2|                Defined::Handleable(h) => Ok(Value::Own(h.clone())),
  426|      0|                _ => Err(Error::HandleToNonResource),
  427|       |            },
  428|      2|            ComponentDefinedType::Borrow(n) => match &self.types[*n as usize] {
  429|      2|                Defined::Handleable(h) => Ok(Value::Borrow(h.clone())),
  430|      0|                _ => Err(Error::HandleToNonResource),
  431|       |            },
  432|     42|            ComponentDefinedType::FixedSizeList(vt, size) => {
  433|     42|                Ok(Value::FixList(Box::new(self.elab_value(vt)?), *size))
                                                                            ^0
  434|       |            }
  435|       |            ComponentDefinedType::Future(_) | ComponentDefinedType::Stream(_) => {
  436|      0|                panic!("async not yet supported")
  437|       |            }
  438|       |        }
  439|     76|    }
  440|       |
  441|    121|    fn elab_func<'c>(&'c mut self, ft: &ComponentFuncType<'a>) -> Result<Func<'a>, Error<'a>> {
  442|    121|        Ok(Func {
  443|    121|            params: ft
  444|    121|                .params
  445|    121|                .iter()
  446|    123|                .map(|(n, vt)| {
  447|    123|                    Ok(Param {
  448|    123|                        name: Name { name: n },
  449|    123|                        ty: self.elab_value(vt)?,
                                                             ^0
  450|       |                    })
  451|    123|                })
  452|    121|                .collect::<Result<Vec<_>, Error<'a>>>()?,
                                                                     ^0
  453|    121|            result: ft
  454|    121|                .result
  455|    121|                .as_ref()
  456|    121|                .map(|vt| self.elab_value(vt))
                                        ^114
  457|    121|                .transpose()?,
                                          ^0
  458|       |        })
  459|    121|    }
  460|       |
  461|       |    /// Elaborate an extern descriptor. This returns any evars that
  462|       |    /// are implied by the descriptor separately, to simplify
  463|       |    /// converting them to context e/u vars, which is usually what you
  464|       |    /// want to do.
  465|    146|    fn elab_extern_desc<'c>(
  466|    146|        &'c mut self,
  467|    146|        ed: &ComponentTypeRef,
  468|    146|    ) -> Result<(Vec<BoundedTyvar<'a>>, ExternDesc<'a>), Error<'a>> {
  469|    146|        match ed {
  470|      0|            ComponentTypeRef::Module(i) => match &self.core.types[*i as usize] {
  471|      0|                CoreDefined::Module(mt) => Ok((vec![], ExternDesc::CoreModule(mt.clone()))),
  472|       |                _ => {
  473|      0|                    panic!("internal invariant violation: bad sort for ComponentTypeRef to Module")
  474|       |                }
  475|       |            },
  476|    121|            ComponentTypeRef::Func(i) => match &self.types[*i as usize] {
  477|    121|                Defined::Func(ft) => Ok((vec![], ExternDesc::Func(ft.clone()))),
  478|      0|                _ => panic!("internal invariant violation: bad sort for ComponentTypeRef to Func"),
  479|       |            },
  480|      0|            ComponentTypeRef::Value(_) => panic!("First-class values are not yet supported"),
  481|     17|            ComponentTypeRef::Type(tb) => {
  482|     17|                let bound = match tb {
  483|     15|                    TypeBounds::Eq(i) => TypeBound::Eq(self.types[*i as usize].clone()),
  484|      2|                    TypeBounds::SubResource => TypeBound::SubResource,
  485|       |                };
  486|     17|                let dt = Defined::Handleable(Handleable::Var(Tyvar::Bound(0)));
  487|     17|                Ok((vec![BoundedTyvar::new(bound)], ExternDesc::Type(dt)))
  488|       |            }
  489|      7|            ComponentTypeRef::Instance(i) => match &self.types[*i as usize] {
  490|      7|                Defined::Instance(qit) => Ok((
  491|      7|                    qit.evars.clone(),
  492|      7|                    ExternDesc::Instance(qit.unqualified.clone()),
  493|      7|                )),
  494|      0|                _ => panic!(
  495|      0|                    "internal invariant violation: bad sort for ComponentTypeRef to Instance"
  496|      0|                ),
  497|       |            },
  498|      1|            ComponentTypeRef::Component(i) => match &self.types[*i as usize] {
  499|      1|                Defined::Component(ct) => Ok((vec![], ExternDesc::Component(ct.clone()))),
  500|      0|                _ => panic!(
  501|      0|                    "internal invariant violation: bad sort for ComponentTypeRef to Component"
  502|      0|                ),
  503|       |            },
  504|       |        }
  505|    146|    }
  506|       |
  507|    335|    fn elab_instance_decl<'c>(
  508|    335|        &'c mut self,
  509|    335|        decl: &InstanceTypeDeclaration<'a>,
  510|    335|    ) -> Result<Option<ExternDecl<'a>>, Error<'a>> {
  511|    335|        match decl {
  512|      0|            InstanceTypeDeclaration::CoreType(ct) => {
  513|      0|                let ct = self.elab_core_type(ct);
  514|      0|                self.core.types.push(ct);
  515|      0|                Ok(None)
  516|       |            }
  517|    197|            InstanceTypeDeclaration::Type(t) => {
  518|    197|                let t = self.elab_defined(t)?;
                                                          ^0
  519|    197|                if let Defined::Handleable(_) = t {
  520|      0|                    return Err(Error::ResourceInDeclarator);
  521|    197|                }
  522|    197|                self.types.push(t);
  523|    197|                Ok(None)
  524|       |            }
  525|      0|            InstanceTypeDeclaration::Alias(a) => {
  526|      0|                let ed = self.resolve_alias(a)?;
  527|      0|                self.add_core_or_component_ed(ed);
  528|      0|                Ok(None)
  529|       |            }
  530|    138|            InstanceTypeDeclaration::Export { name, ty } => {
  531|    138|                let (vs, ed) = self.elab_extern_desc(ty)?;
                                                                      ^0
  532|    138|                let sub = self.bound_to_evars(Some(name.0), &vs);
  533|    138|                let ed = sub.extern_desc(&ed).not_void();
  534|    138|                self.add_ed(&ed);
  535|    138|                Ok(Some(ExternDecl {
  536|    138|                    kebab_name: name.0,
  537|    138|                    desc: ed,
  538|    138|                }))
  539|       |            }
  540|       |        }
  541|    335|    }
  542|       |
  543|      7|    fn elab_instance<'c>(
  544|      7|        &'c mut self,
  545|      7|        decls: &[InstanceTypeDeclaration<'a>],
  546|      7|    ) -> Result<QualifiedInstance<'a>, Error<'a>> {
  547|      7|        let mut ctx = Ctx::new(Some(self), false);
  548|      7|        let mut exports = Vec::new();
  549|    342|        for decl in decls {
                          ^335
  550|    335|            let export = ctx.elab_instance_decl(decl)?;
                                                                   ^0
  551|    335|            if let Some(export) = export {
                                      ^138
  552|    138|                exports.push(export);
  553|    197|            }
  554|       |        }
  555|      7|        ctx.finish_instance(&exports)
  556|      7|    }
  557|       |
  558|       |    /// Convert instance variables in the context into bound variables
  559|       |    /// in the type. This is pulled out separately from raising the
  560|       |    /// resulting type so that it can be shared between
  561|       |    /// [`Ctx::finish_instance`] and [`Ctx::finish_component`], which
  562|       |    /// have different requirements in that respect.
  563|     12|    fn finish_instance_evars(
  564|     12|        self,
  565|     12|        exports: &[ExternDecl<'a>],
  566|     12|    ) -> Result<QualifiedInstance<'a>, Error<'a>> {
  567|     12|        let mut evars = Vec::new();
  568|     12|        let mut sub = substitute::Closing::new(false);
  569|     40|        for (bound, _) in self.evars {
                           ^28
  570|     28|            let bound = sub.bounded_tyvar(&bound)?;
                                                               ^0
  571|     28|            evars.push(bound);
  572|     28|            sub.next_e();
  573|       |        }
  574|     12|        let unqualified = sub.instance(&Instance {
  575|     12|            exports: exports.to_vec(),
  576|     12|        })?;
                        ^0
  577|     12|        Ok(QualifiedInstance { evars, unqualified })
  578|     12|    }
  579|       |
  580|       |    /// The equivalent of the \oplus in the spec.  This has to deal
  581|       |    /// with more bookkeeping because of our variable representation:
  582|       |    /// the free variables in the exports need to be converted to
  583|       |    /// bound variables, and any free variables referring to upper
  584|       |    /// contexts need to have their parent/outer index reduced by one
  585|       |    /// to deal with this context ending.
  586|      7|    fn finish_instance(
  587|      7|        self,
  588|      7|        exports: &[ExternDecl<'a>],
  589|      7|    ) -> Result<QualifiedInstance<'a>, Error<'a>> {
  590|      7|        // When we do the well-formedness check in a minute, we need
  591|      7|        // to use the parent ctx, because the closing substitution has
  592|      7|        // already been applied.
  593|      7|        let fallback_parent = Ctx::new(None, false);
  594|      7|        let parent_ctx = self.parent.unwrap_or(&fallback_parent);
  595|       |
  596|      7|        let qi = self.finish_instance_evars(exports)?;
                                                                  ^0
  597|      7|        let raise_u_sub = substitute::Closing::new(true);
  598|      7|        let it = raise_u_sub.qualified_instance(&qi)?;
                                                                  ^0
  599|      7|        parent_ctx
  600|      7|            .wf_qualified_instance(wf::DefinedTypePosition::internal(), &it)
  601|      7|            .map_err(Error::IllFormed)?;
                                                    ^0
  602|      7|        Ok(it)
  603|      7|    }
  604|       |
  605|     16|    fn elab_component_decl<'c>(
  606|     16|        &'c mut self,
  607|     16|        decl: &ComponentTypeDeclaration<'a>,
  608|     16|    ) -> Result<(Option<ExternDecl<'a>>, Option<ExternDecl<'a>>), Error<'a>> {
  609|     16|        match decl {
  610|      0|            ComponentTypeDeclaration::CoreType(ct) => {
  611|      0|                let ct = self.elab_core_type(ct);
  612|      0|                self.core.types.push(ct);
  613|      0|                Ok((None, None))
  614|       |            }
  615|      8|            ComponentTypeDeclaration::Type(t) => {
  616|      8|                let t = self.elab_defined(t)?;
                                                          ^0
  617|      8|                if let Defined::Handleable(_) = t {
  618|      0|                    return Err(Error::ResourceInDeclarator);
  619|      8|                }
  620|      8|                self.types.push(t);
  621|      8|                Ok((None, None))
  622|       |            }
  623|      0|            ComponentTypeDeclaration::Alias(a) => {
  624|      0|                let ed = self.resolve_alias(a)?;
  625|      0|                self.add_core_or_component_ed(ed);
  626|      0|                Ok((None, None))
  627|       |            }
  628|      6|            ComponentTypeDeclaration::Export { name, ty, .. } => {
  629|      6|                let (vs, ed) = self.elab_extern_desc(ty)?;
                                                                      ^0
  630|      6|                let sub = self.bound_to_evars(Some(name.0), &vs);
  631|      6|                let ed = sub.extern_desc(&ed).not_void();
  632|      6|                self.add_ed(&ed);
  633|      6|                Ok((
  634|      6|                    None,
  635|      6|                    Some(ExternDecl {
  636|      6|                        kebab_name: name.0,
  637|      6|                        desc: ed,
  638|      6|                    }),
  639|      6|                ))
  640|       |            }
  641|      2|            ComponentTypeDeclaration::Import(i) => {
  642|      2|                let (vs, ed) = self.elab_extern_desc(&i.ty)?;
                                                                         ^0
  643|      2|                let sub = self.bound_to_uvars(Some(i.name.0), &vs, true);
  644|      2|                let ed = sub.extern_desc(&ed).not_void();
  645|      2|                self.add_ed(&ed);
  646|      2|                Ok((
  647|      2|                    Some(ExternDecl {
  648|      2|                        kebab_name: i.name.0,
  649|      2|                        desc: ed,
  650|      2|                    }),
  651|      2|                    None,
  652|      2|                ))
  653|       |            }
  654|       |        }
  655|     16|    }
  656|       |
  657|       |    /// Similar to [`Ctx::finish_instance`], but for components; this
  658|       |    /// has to cover uvars as well as evars.
  659|      5|    fn finish_component(
  660|      5|        self,
  661|      5|        imports: &[ExternDecl<'a>],
  662|      5|        exports: &[ExternDecl<'a>],
  663|      5|    ) -> Result<Component<'a>, Error<'a>> {
  664|      5|        // When we do the well-formedness check in a minute, we need
  665|      5|        // to use the parent ctx, because the closing substitution has
  666|      5|        // already been applied.
  667|      5|        let fallback_parent = Ctx::new(None, false);
  668|      5|        let parent_ctx = self.parent.unwrap_or(&fallback_parent);
  669|      5|
  670|      5|        let mut uvars = Vec::new();
  671|      5|        let mut sub = substitute::Closing::new(true);
  672|     11|        for (bound, imported) in &self.uvars {
                           ^6
  673|      6|            let bound = sub.bounded_tyvar(bound)?;
                                                              ^0
  674|      6|            uvars.push(bound);
  675|      6|            sub.next_u(*imported);
  676|       |        }
  677|      5|        let imports = imports
  678|      5|            .iter()
  679|      5|            .map(|ed| sub.extern_decl(ed).map_err(Into::into))
                                    ^2
  680|      5|            .collect::<Result<Vec<ExternDecl<'a>>, Error<'a>>>()?;
                                                                              ^0
  681|      5|        let instance = sub.qualified_instance(&self.finish_instance_evars(exports)?)?;
                                                                                                ^0^0
  682|      5|        let ct = Component {
  683|      5|            uvars,
  684|      5|            imports,
  685|      5|            instance,
  686|      5|        };
  687|      5|        parent_ctx
  688|      5|            .wf_component(wf::DefinedTypePosition::internal(), &ct)
  689|      5|            .map_err(Error::IllFormed)?;
                                                    ^0
  690|      5|        Ok(ct)
  691|      5|    }
  692|       |
  693|    205|    fn elab_defined<'c>(&'c mut self, dt: &ComponentType<'a>) -> Result<Defined<'a>, Error<'a>> {
  694|    205|        match dt {
  695|     76|            ComponentType::Defined(vt) => Ok(Defined::Value(self.elab_defined_value(vt)?)),
                                                                                                     ^0
  696|    121|            ComponentType::Func(ft) => Ok(Defined::Func(self.elab_func(ft)?)),
                                                                                        ^0
  697|      1|            ComponentType::Component(cds) => Ok(Defined::Component(self.elab_component(cds)?)),
                                                                                                         ^0
  698|      7|            ComponentType::Instance(ids) => Ok(Defined::Instance(self.elab_instance(ids)?)),
                                                                                                      ^0
  699|      0|            ComponentType::Resource { dtor, .. } => {
  700|      0|                let rid = ResourceId {
  701|      0|                    id: self.rtypes.len() as u32,
  702|      0|                };
  703|      0|                self.rtypes.push(Resource { _dtor: *dtor });
  704|      0|                Ok(Defined::Handleable(Handleable::Resource(rid)))
  705|       |            }
  706|       |        }
  707|    205|    }
  708|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/emit.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! A bunch of utilities used by the actual code emit functions
   18|       |use std::collections::{BTreeMap, BTreeSet, VecDeque};
   19|       |use std::vec::Vec;
   20|       |
   21|       |use proc_macro2::TokenStream;
   22|       |use quote::{format_ident, quote};
   23|       |use syn::Ident;
   24|       |
   25|       |use crate::etypes::{BoundedTyvar, Defined, Handleable, ImportExport, TypeBound, Tyvar};
   26|       |
   27|       |/// A representation of a trait definition that we will eventually
   28|       |/// emit. This is used to allow easily adding onto the trait each time
   29|       |/// we see an extern decl.
   30|       |#[derive(Debug, Default)]
   31|       |pub struct Trait {
   32|       |    /// A set of supertrait constraints, each associated with a
   33|       |    /// bindings module path
   34|       |    pub supertraits: BTreeMap<Vec<Ident>, TokenStream>,
   35|       |    /// Keep track for each type variable of:
   36|       |    /// - The identifier that we use for it in the generated source
   37|       |    /// - Whether it comes from a component type variable, and if so,
   38|       |    ///   which one. (Most do; the I: Imports on the main component
   39|       |    ///   trait is the main one that doesn't).
   40|       |    /// - Whether there are any bounds on it
   41|       |    pub tvs: BTreeMap<Ident, (Option<u32>, TokenStream)>,
   42|       |    /// Raw tokens of the contents of the trait
   43|       |    pub items: TokenStream,
   44|       |}
   45|       |impl Trait {
   46|      0|    pub fn new() -> Self {
   47|      0|        Self {
   48|      0|            supertraits: BTreeMap::new(),
   49|      0|            tvs: BTreeMap::new(),
   50|      0|            items: TokenStream::new(),
   51|      0|        }
   52|      0|    }
   53|       |    /// Collect the component tyvar indices that correspond to the
   54|       |    /// type variables on this trait.
   55|       |    ///
   56|       |    /// Precondition: all of the type
   57|       |    /// variables on this trait do correspond to component variables.
   58|      5|    pub fn tv_idxs(&self) -> Vec<u32> {
   59|      5|        self.tvs.iter().map(|(_, (n, _))| n.unwrap()).collect()
                                                        ^0
   60|      5|    }
   61|       |    /// See [`State::adjust_vars`].
   62|      4|    pub fn adjust_vars(&mut self, n: u32) {
   63|      4|        for (_, (v, _)) in self.tvs.iter_mut() {
                               ^0
   64|      0|            if let Some(v) = v.as_mut() {
   65|      0|                *v += n;
   66|      0|            }
   67|       |        }
   68|      4|    }
   69|       |    /// Build a token stream of all type variables and trait bounds on
   70|       |    /// them, e.g. what you would put "inside" the <> in trait T<...>.
   71|      1|    pub fn tv_toks_inner(&mut self) -> TokenStream {
   72|      1|        let tvs = self
   73|      1|            .tvs
   74|      1|            .iter()
   75|      1|            .map(|(k, (_, v))| {
   76|      1|                let colon = if v.is_empty() {
   77|      0|                    quote! {}
   78|       |                } else {
   79|      1|                    quote! { : }
   80|       |                };
   81|      1|                quote! { #k #colon #v }
   82|      1|            })
   83|      1|            .collect::<Vec<_>>();
   84|      1|        quote! { #(#tvs),* }
   85|      1|    }
   86|       |    /// Build a token stream for the type variable part of the trait
   87|       |    /// declaration
   88|      6|    pub fn tv_toks(&mut self) -> TokenStream {
   89|      6|        if !self.tvs.is_empty() {
   90|      1|            let toks = self.tv_toks_inner();
   91|      1|            quote! { <#toks> }
   92|       |        } else {
   93|      5|            quote! {}
   94|       |        }
   95|      6|    }
   96|       |    /// Build a token stream for this entire trait definition
   97|      6|    pub fn into_tokens(&mut self, n: Ident) -> TokenStream {
   98|      6|        let trait_colon = if !self.supertraits.is_empty() {
   99|      1|            quote! { : }
  100|       |        } else {
  101|      5|            quote! {}
  102|       |        };
  103|      6|        let supertraits = self
  104|      6|            .supertraits
  105|      6|            .iter()
  106|      6|            .map(|(is, ts)| {
  107|      1|                quote! { #(#is)::*#ts }
  108|      6|            })
                          ^1
  109|      6|            .collect::<Vec<_>>();
  110|      6|        let tvs = self.tv_toks();
  111|      6|        let items = &self.items;
  112|      6|        quote! {
  113|      6|            pub trait #n #tvs #trait_colon #(#supertraits)+* { #items }
  114|      6|        }
  115|      6|    }
  116|       |}
  117|       |
  118|       |/// A representation of a module definition that we will eventually
  119|       |/// emit. This is used to allow easily adding onto the module each time
  120|       |/// we see a relevant decl.
  121|       |#[derive(Debug, Default)]
  122|       |pub struct Mod {
  123|       |    pub submods: BTreeMap<Ident, Mod>,
  124|       |    pub items: TokenStream,
  125|       |    pub traits: BTreeMap<Ident, Trait>,
  126|       |    pub impls: BTreeMap<(Vec<Ident>, Ident), TokenStream>,
  127|       |}
  128|       |impl Mod {
  129|     69|    pub fn empty() -> Self {
  130|     69|        Self {
  131|     69|            submods: BTreeMap::new(),
  132|     69|            items: TokenStream::new(),
  133|     69|            traits: BTreeMap::new(),
  134|     69|            impls: BTreeMap::new(),
  135|     69|        }
  136|     69|    }
  137|       |    /// Get a reference to a sub-module, creating it if necessary
  138|     68|    pub fn submod<'a>(&'a mut self, i: Ident) -> &'a mut Self {
  139|     68|        self.submods.entry(i).or_insert(Self::empty())
  140|     68|    }
  141|       |    /// Get an immutable reference to a sub-module
  142|       |    ///
  143|       |    /// Precondition: the named submodule must already exist
  144|     14|    pub fn submod_immut<'a>(&'a self, i: Ident) -> &'a Self {
  145|     14|        &self.submods[&i]
  146|     14|    }
  147|       |    /// Get a reference to a trait definition in this module, creating
  148|       |    /// it if necessary
  149|     24|    pub fn r#trait<'a>(&'a mut self, i: Ident) -> &'a mut Trait {
  150|     24|        self.traits.entry(i).or_default()
  151|     24|    }
  152|       |    /// Get an immutable reference to a trait definition in this module
  153|       |    ///
  154|       |    /// Precondition: the named trait must already exist
  155|      3|    pub fn trait_immut<'a>(&'a self, i: Ident) -> &'a Trait {
  156|      3|        &self.traits[&i]
  157|      3|    }
  158|       |    /// Get a reference to an impl block that is in this module,
  159|       |    /// creating it if necessary.
  160|       |    ///
  161|       |    /// Currently, we don't track much information about these, so
  162|       |    /// it's just a mutable token stream.
  163|      0|    pub fn r#impl<'a>(&'a mut self, t: Vec<Ident>, i: Ident) -> &'a mut TokenStream {
  164|      0|        self.impls.entry((t, i)).or_default()
  165|      0|    }
  166|       |    /// See [`State::adjust_vars`].
  167|      5|    pub fn adjust_vars(&mut self, n: u32) {
  168|      5|        self.submods
  169|      5|            .iter_mut()
  170|      5|            .map(|(_, m)| m.adjust_vars(n))
                                        ^4
  171|      5|            .for_each(drop);
  172|      5|        self.traits
  173|      5|            .iter_mut()
  174|      5|            .map(|(_, t)| t.adjust_vars(n))
                                        ^4
  175|      5|            .for_each(drop);
  176|      5|    }
  177|       |    /// Build a token stream for this entire module
  178|      5|    pub fn into_tokens(self) -> TokenStream {
  179|      5|        let mut tt = TokenStream::new();
  180|      9|        for (k, v) in self.submods {
                           ^4
  181|      4|            let vt = v.into_tokens();
  182|      4|            tt.extend(quote! {
  183|      4|                pub mod #k { #vt }
  184|      4|            });
  185|      4|        }
  186|     11|        for (n, mut t) in self.traits {
                           ^6
  187|      6|            tt.extend(t.into_tokens(n));
  188|      6|        }
  189|      5|        tt.extend(self.items);
  190|      5|        for ((ns, i), t) in self.impls {
                            ^0
  191|      0|            tt.extend(quote! {
  192|      0|                impl #(#ns)::* for #i { #t }
  193|      0|            })
  194|       |        }
  195|      5|        tt
  196|      5|    }
  197|       |}
  198|       |
  199|       |/// A whole grab-bag of useful state to have while emitting Rust
  200|       |#[derive(Debug)]
  201|       |pub struct State<'a, 'b> {
  202|       |    /// A pointer to a [`Mod`] that everything we emit will end up in
  203|       |    pub root_mod: &'a mut Mod,
  204|       |    /// A cursor to the current submodule (under [`State::root_mod`]),
  205|       |    /// where decls that we are looking at right now should end up
  206|       |    pub mod_cursor: Vec<Ident>,
  207|       |    /// If we are currently processing decls that should end up inside
  208|       |    /// a trait (representing an instance or a resource), this names
  209|       |    /// the trait where they should end up.
  210|       |    pub cur_trait: Option<Ident>,
  211|       |    /// We use a "helper module" for auxiliary definitions: for
  212|       |    /// example, an instance represented by `InstanceTrait` would end
  213|       |    /// up with nominal definitions for its nontrivial types in
  214|       |    /// `instance_trait::Type`.  This keeps track of the name of that
  215|       |    /// module, if it presently exists.
  216|       |    pub cur_helper_mod: Option<Ident>,
  217|       |    /// Whether the trait/type definition that we are currently
  218|       |    /// emitting is in the helper module or the main module
  219|       |    /// corresponding directly to the wit package. This is important
  220|       |    /// to get references to other types correct.
  221|       |    pub is_helper: bool,
  222|       |    /// All the bound variables in the component type that we are
  223|       |    /// currently processing
  224|       |    pub bound_vars: &'a mut VecDeque<BoundedTyvar<'b>>,
  225|       |    /// An offset into bound_vars from which any variable indices we
  226|       |    /// see in the source component type will be resolved; used to
  227|       |    /// deal with the fact that when we recurse down into a type in
  228|       |    /// the Eq bound of a type variable, its variables are offset from
  229|       |    /// ours (since we use de Bruijn indices).
  230|       |    pub var_offset: usize,
  231|       |    /// A path through instance import/export names from the root
  232|       |    /// component type to the type we are currently processing. This
  233|       |    /// is used with [`crate::etypes::TyvarOrigin`] to decide whether
  234|       |    /// a type variable we encounter is "locally defined", i.e. should
  235|       |    /// have a type definition emitted for it in this module.
  236|       |    pub origin: Vec<ImportExport<'b>>,
  237|       |    /// A set of type variables that we encountered while emitting the
  238|       |    /// type bound for a type variable.
  239|       |    pub cur_needs_vars: Option<&'a mut BTreeSet<u32>>,
  240|       |    /// A map from type variables to the type variables used in their
  241|       |    /// bounds, used to ensure that we are parametrized over the
  242|       |    /// things we need to be
  243|       |    pub vars_needs_vars: &'a mut VecDeque<BTreeSet<u32>>,
  244|       |    /// The Rust type parameter used to represent the type that
  245|       |    /// implements the imports of a component
  246|       |    pub import_param_var: Option<Ident>,
  247|       |    /// The Rust type parameter used to represent the current Rust
  248|       |    /// state type
  249|       |    pub self_param_var: Option<Ident>,
  250|       |    /// Whether we are emitting an implementation of the component
  251|       |    /// interfaces, or just the types of the interface
  252|       |    pub is_impl: bool,
  253|       |    /// A namespace path and a name representing the Rust trait
  254|       |    /// generated for the root component that we started codegen from
  255|       |    pub root_component_name: Option<(TokenStream, &'a str)>,
  256|       |    /// Whether we are generating code for the Hyperlight host or the
  257|       |    /// Hyperlight guest
  258|       |    pub is_guest: bool,
  259|       |    /// A temporary hack to enable some special cases used by the
  260|       |    /// wasmtime guest emit. When that is refactored to use the host
  261|       |    /// guest emit, this can go away.
  262|       |    pub is_wasmtime_guest: bool,
  263|       |}
  264|       |
  265|       |/// Create a State with all of its &mut references pointing to
  266|       |/// sensible things, run a function that emits code into the state,
  267|       |/// and then generate a token stream representing everything emitted
  268|      1|pub fn run_state<'b, F: for<'a> FnMut(&mut State<'a, 'b>)>(
  269|      1|    is_guest: bool,
  270|      1|    is_wasmtime_guest: bool,
  271|      1|    mut f: F,
  272|      1|) -> TokenStream {
  273|      1|    let mut root_mod = Mod::empty();
  274|      1|    let mut bound_vars = std::collections::VecDeque::new();
  275|      1|    let mut vars_needs_vars = std::collections::VecDeque::new();
  276|      1|    {
  277|      1|        let mut state = State::new(
  278|      1|            &mut root_mod,
  279|      1|            &mut bound_vars,
  280|      1|            &mut vars_needs_vars,
  281|      1|            is_guest,
  282|      1|            is_wasmtime_guest,
  283|      1|        );
  284|      1|        f(&mut state);
  285|      1|    }
  286|      1|    root_mod.into_tokens()
  287|      1|}
  288|       |
  289|       |impl<'a, 'b> State<'a, 'b> {
  290|      1|    pub fn new(
  291|      1|        root_mod: &'a mut Mod,
  292|      1|        bound_vars: &'a mut VecDeque<BoundedTyvar<'b>>,
  293|      1|        vars_needs_vars: &'a mut VecDeque<BTreeSet<u32>>,
  294|      1|        is_guest: bool,
  295|      1|        is_wasmtime_guest: bool,
  296|      1|    ) -> Self {
  297|      1|        Self {
  298|      1|            root_mod,
  299|      1|            mod_cursor: Vec::new(),
  300|      1|            cur_trait: None,
  301|      1|            cur_helper_mod: None,
  302|      1|            is_helper: false,
  303|      1|            bound_vars,
  304|      1|            var_offset: 0,
  305|      1|            origin: Vec::new(),
  306|      1|            cur_needs_vars: None,
  307|      1|            vars_needs_vars,
  308|      1|            import_param_var: None,
  309|      1|            self_param_var: None,
  310|      1|            is_impl: false,
  311|      1|            root_component_name: None,
  312|      1|            is_guest,
  313|      1|            is_wasmtime_guest,
  314|      1|        }
  315|      1|    }
  316|    102|    pub fn clone<'c>(&'c mut self) -> State<'c, 'b> {
  317|    102|        State {
  318|    102|            root_mod: self.root_mod,
  319|    102|            mod_cursor: self.mod_cursor.clone(),
  320|    102|            cur_trait: self.cur_trait.clone(),
  321|    102|            cur_helper_mod: self.cur_helper_mod.clone(),
  322|    102|            is_helper: self.is_helper,
  323|    102|            bound_vars: self.bound_vars,
  324|    102|            var_offset: self.var_offset,
  325|    102|            origin: self.origin.clone(),
  326|    102|            cur_needs_vars: self.cur_needs_vars.as_deref_mut(),
  327|    102|            vars_needs_vars: self.vars_needs_vars,
  328|    102|            import_param_var: self.import_param_var.clone(),
  329|    102|            self_param_var: self.self_param_var.clone(),
  330|    102|            is_impl: self.is_impl,
  331|    102|            root_component_name: self.root_component_name.clone(),
  332|    102|            is_guest: self.is_guest,
  333|    102|            is_wasmtime_guest: self.is_wasmtime_guest,
  334|    102|        }
  335|    102|    }
  336|       |    /// Obtain a reference to the [`Mod`] that we are currently
  337|       |    /// generating code in, creating it if necessary
  338|     24|    pub fn cur_mod<'c>(&'c mut self) -> &'c mut Mod {
  339|     24|        let mut m: &'c mut Mod = self.root_mod;
  340|     72|        for i in &self.mod_cursor {
                          ^48
  341|     48|            m = m.submod(i.clone());
  342|     48|        }
  343|     24|        if self.is_helper {
  344|      8|            m = m.submod(self.cur_helper_mod.clone().unwrap());
  345|     16|        }
  346|     24|        m
  347|     24|    }
  348|       |    /// Obtain an immutable reference to the [`Mod`] that we are
  349|       |    /// currently generating code in.
  350|       |    ///
  351|       |    /// Precondition: the module must already exist
  352|      7|    pub fn cur_mod_immut<'c>(&'c self) -> &'c Mod {
  353|      7|        let mut m: &'c Mod = self.root_mod;
  354|     21|        for i in &self.mod_cursor {
                          ^14
  355|     14|            m = m.submod_immut(i.clone());
  356|     14|        }
  357|      7|        if self.is_helper {
  358|      0|            m = m.submod_immut(self.cur_helper_mod.clone().unwrap());
  359|      7|        }
  360|      7|        m
  361|      7|    }
  362|       |    /// Copy the state, changing its module cursor to emit code into a
  363|       |    /// different module
  364|     10|    pub fn with_cursor<'c>(&'c mut self, cursor: Vec<Ident>) -> State<'c, 'b> {
  365|     10|        let mut s = self.clone();
  366|     10|        s.mod_cursor = cursor;
  367|     10|        s
  368|     10|    }
  369|       |    /// Copy the state, replacing its [`State::cur_needs_vars`] reference,
  370|       |    /// allowing a caller to capture the vars referenced by any emit
  371|       |    /// run with the resultant state
  372|     10|    pub fn with_needs_vars<'c>(&'c mut self, needs_vars: &'c mut BTreeSet<u32>) -> State<'c, 'b> {
  373|     10|        let mut s = self.clone();
  374|     10|        s.cur_needs_vars = Some(needs_vars);
  375|     10|        s
  376|     10|    }
  377|       |    /// Record that an emit sequence needed a var, given an absolute
  378|       |    /// index for the var (i.e. ignoring [`State::var_offset`])
  379|      0|    pub fn need_noff_var(&mut self, n: u32) {
  380|      0|        self.cur_needs_vars.as_mut().map(|vs| vs.insert(n));
  381|      0|    }
  382|       |    /// Use the [`State::cur_needs_vars`] map to populate
  383|       |    /// [`State::vars_needs_vars`] for a var that we presumably just
  384|       |    /// finished emitting a bound for
  385|      5|    pub fn record_needs_vars(&mut self, n: u32) {
  386|      5|        let un = n as usize;
  387|      5|        if self.vars_needs_vars.len() < un + 1 {
  388|      1|            self.vars_needs_vars.resize(un + 1, BTreeSet::new());
  389|      4|        }
  390|      5|        let Some(ref mut cnvs) = self.cur_needs_vars else {
  391|      0|            return;
  392|       |        };
  393|      5|        log::debug!("debug varref: recording {:?} for var {:?}", cnvs.iter(), un);
                                  ^0
  394|      5|        self.vars_needs_vars[un].extend(cnvs.iter());
  395|      5|    }
  396|       |    /// Get a list of all the variables needed by a var, given its absolute
  397|       |    /// index (i.e. ignoring [`State::var_offset`])
  398|     45|    pub fn get_noff_var_refs(&mut self, n: u32) -> BTreeSet<u32> {
  399|     45|        let un = n as usize;
  400|     45|        if self.vars_needs_vars.len() < un + 1 {
  401|      0|            return BTreeSet::new();
  402|     45|        };
  403|     45|        log::debug!(
  404|      0|            "debug varref: looking up {:?} for var {:?}",
  405|      0|            self.vars_needs_vars[un].iter(),
  406|       |            un
  407|       |        );
  408|     45|        self.vars_needs_vars[un].clone()
  409|     45|    }
  410|       |    /// Find the exported name which gave rise to a component type
  411|       |    /// variable, given its absolute index (i.e. ignoring
  412|       |    /// [`State::var_offset`])
  413|      0|    pub fn noff_var_id(&self, n: u32) -> Ident {
  414|      0|        let Some(n) = self.bound_vars[n as usize].origin.last_name() else {
  415|      0|            panic!("missing origin on tyvar in rust emit")
  416|       |        };
  417|      0|        kebab_to_type(n)
  418|      0|    }
  419|       |    /// Copy the state, changing it to emit into the helper module of
  420|       |    /// the current trait
  421|      8|    pub fn helper<'c>(&'c mut self) -> State<'c, 'b> {
  422|      8|        let mut s = self.clone();
  423|      8|        s.is_helper = true;
  424|      8|        s
  425|      8|    }
  426|       |    /// Construct a namespace token stream that can be emitted in the
  427|       |    /// current module to refer to a name in the root module
  428|     35|    pub fn root_path(&self) -> TokenStream {
  429|     35|        if self.is_impl {
  430|     31|            return TokenStream::new();
  431|      4|        }
  432|      4|        let mut s = self
  433|      4|            .mod_cursor
  434|      4|            .iter()
  435|      8|            .map(|_| quote! { super })
  436|      4|            .collect::<Vec<_>>();
  437|      4|        if self.is_helper {
  438|      0|            s.push(quote! { super });
  439|      4|        }
  440|      4|        quote! { #(#s::)* }
  441|     35|    }
  442|       |    /// Construct a namespace token stream that can be emitted in the
  443|       |    /// current module to refer to a name in the helper module
  444|     12|    pub fn helper_path(&self) -> TokenStream {
  445|     12|        if self.is_impl {
  446|      2|            let c = &self.mod_cursor;
  447|      2|            let helper = self.cur_helper_mod.clone().unwrap();
  448|      2|            let h = if !self.is_helper {
  449|      2|                quote! { #helper:: }
  450|       |            } else {
  451|      0|                TokenStream::new()
  452|       |            };
  453|      2|            quote! { #(#c::)*#h }
  454|     10|        } else if self.is_helper {
  455|      0|            quote! { self:: }
  456|       |        } else {
  457|     10|            let helper = self.cur_helper_mod.clone().unwrap();
  458|     10|            quote! { #helper:: }
  459|       |        }
  460|     12|    }
  461|       |    /// Emit a namespace token stream that can be emitted in the root
  462|       |    /// module to refer to the current trait
  463|     43|    pub fn cur_trait_path(&self) -> TokenStream {
  464|     43|        let tns = &self.mod_cursor;
  465|     43|        let tid = self.cur_trait.clone().unwrap();
  466|     43|        quote! { #(#tns::)* #tid }
  467|     43|    }
  468|       |    /// Add a supertrait constraint referring to a trait in the helper
  469|       |    /// module; primarily used to add a constraint for the trait
  470|       |    /// representing a resource type.
  471|      1|    pub fn add_helper_supertrait(&mut self, r: Ident) {
  472|      1|        let (Some(t), Some(hm)) = (self.cur_trait.clone(), &self.cur_helper_mod.clone()) else {
  473|      0|            panic!("invariant violation")
  474|       |        };
  475|      1|        self.cur_mod()
  476|      1|            .r#trait(t)
  477|      1|            .supertraits
  478|      1|            .insert(vec![hm.clone(), r], TokenStream::new());
  479|      1|    }
  480|       |    /// Obtain a reference to the [`Trait`] that we are currently
  481|       |    /// generating code in, creating it if necessary.
  482|       |    ///
  483|       |    /// Precondition: we are currently generating code in a trait
  484|       |    /// (i.e. [`State::cur_trait`] is not [`None`])
  485|     17|    pub fn cur_trait<'c>(&'c mut self) -> &'c mut Trait {
  486|     17|        let n = self.cur_trait.as_ref().unwrap().clone();
  487|     17|        self.cur_mod().r#trait(n)
  488|     17|    }
  489|       |    /// Obtain an immutable reference to the [`Trait`] that we are
  490|       |    /// currently generating code in.
  491|       |    ///
  492|       |    /// Precondition: we are currently generating code in a trait
  493|       |    /// (i.e. [`State::cur_trait`] is not [`None`]), and that trait has
  494|       |    /// already been created
  495|      3|    pub fn cur_trait_immut<'c>(&'c self) -> &'c Trait {
  496|      3|        let n = self.cur_trait.as_ref().unwrap().clone();
  497|      3|        self.cur_mod_immut().trait_immut(n)
  498|      3|    }
  499|       |    /// Obtain a reference to the trait at the given module path and
  500|       |    /// name from the root module, creating it and any named modules
  501|       |    /// if necessary
  502|      6|    pub fn r#trait<'c>(&'c mut self, namespace: &'c [Ident], name: Ident) -> &'c mut Trait {
  503|      6|        let mut m: &'c mut Mod = self.root_mod;
  504|     18|        for i in namespace {
                          ^12
  505|     12|            m = m.submod(i.clone());
  506|     12|        }
  507|      6|        m.r#trait(name)
  508|      6|    }
  509|       |    /// Add an import/export to [`State::origin`], reflecting that we are now
  510|       |    /// looking at code underneath it
  511|     52|    pub fn push_origin<'c>(&'c mut self, is_export: bool, name: &'b str) -> State<'c, 'b> {
  512|     52|        let mut s = self.clone();
  513|     52|        s.origin.push(if is_export {
  514|     50|            ImportExport::Export(name)
  515|       |        } else {
  516|      2|            ImportExport::Import(name)
  517|       |        });
  518|     52|        s
  519|     52|    }
  520|       |    /// Find out if a [`Defined`] type is actually a reference to a
  521|       |    /// locally defined type variable, returning its index and bound
  522|       |    /// if it is
  523|      6|    pub fn is_var_defn(&self, t: &Defined<'b>) -> Option<(u32, TypeBound<'b>)> {
  524|      6|        match t {
  525|      6|            Defined::Handleable(Handleable::Var(tv)) => match tv {
  526|      6|                Tyvar::Bound(n) => {
  527|      6|                    let bv = &self.bound_vars[self.var_offset + (*n as usize)];
  528|      6|                    log::debug!("checking an origin {:?} {:?}", bv.origin, self.origin);
                                              ^0
  529|      6|                    if bv.origin.matches(self.origin.iter()) {
  530|      6|                        Some((*n, bv.bound.clone()))
  531|       |                    } else {
  532|      0|                        None
  533|       |                    }
  534|       |                }
  535|      0|                Tyvar::Free(_) => panic!("free tyvar in finished type"),
  536|       |            },
  537|      0|            _ => None,
  538|       |        }
  539|      6|    }
  540|       |    /// Find out if a variable is locally-defined given its absolute
  541|       |    /// index, returning its origin and bound if it is
  542|     45|    pub fn is_noff_var_local<'c>(
  543|     45|        &'c self,
  544|     45|        n: u32,
  545|     45|    ) -> Option<(Vec<ImportExport<'c>>, TypeBound<'a>)> {
  546|     45|        let bv = &self.bound_vars[n as usize];
  547|     45|        bv.origin
  548|     45|            .is_local(self.origin.iter())
  549|     45|            .map(|path| (path, bv.bound.clone()))
  550|     45|    }
  551|       |    /// Obtain an immutable reference to the trait at the specified
  552|       |    /// namespace path, either from the root module (if `absolute`)
  553|       |    /// is true, or from the current module
  554|       |    ///
  555|       |    /// Precondition: all named traits/modules must exist
  556|      5|    pub fn resolve_trait_immut(&self, absolute: bool, path: &[Ident]) -> &Trait {
  557|      5|        log::debug!("resolving trait {:?} {:?}", absolute, path);
                                  ^0
  558|      5|        let mut m = if absolute {
  559|      1|            &*self.root_mod
  560|       |        } else {
  561|      4|            self.cur_mod_immut()
  562|       |        };
  563|      7|        for x in &path[0..path.len() - 1] {
                                ^5
  564|      7|            m = &m.submods[x];
  565|      7|        }
  566|      5|        &m.traits[&path[path.len() - 1]]
  567|      5|    }
  568|       |    /// Shift all of the type variable indices over, because we have
  569|       |    /// gone under some binders.  Used when we switch from looking at
  570|       |    /// a component's import types (where type idxs are de Bruijn into
  571|       |    /// the component's uvar list) to a component's export types
  572|       |    /// (where type idx are de Bruijn first into the evar list and
  573|       |    /// then the uvar list, as we go under the existential binders).
  574|      1|    pub fn adjust_vars(&mut self, n: u32) {
  575|      1|        self.vars_needs_vars
  576|      1|            .iter_mut()
  577|      1|            .enumerate()
  578|      6|            .for_each(|(i, vs)| {
  579|      6|                *vs = vs.iter().map(|v| v + n).collect();
                                                      ^0
  580|      6|                log::debug!("updated {:?} to {:?}", i, *vs);
                                          ^0
  581|      6|            });
  582|      5|        for _ in 0..n {
  583|      5|            self.vars_needs_vars.push_front(BTreeSet::new());
  584|      5|        }
  585|      1|        self.root_mod.adjust_vars(n);
  586|      1|    }
  587|       |    /// Resolve a type variable as far as possible: either this ends
  588|       |    /// up with a definition, in which case, let's get that, or it
  589|       |    /// ends up with a resource type, in which case we return the
  590|       |    /// resource index
  591|     20|    pub fn resolve_tv(&self, n: u32) -> (u32, Option<Defined<'b>>) {
  592|     20|        match &self.bound_vars[self.var_offset + n as usize].bound {
  593|      0|            TypeBound::Eq(Defined::Handleable(Handleable::Var(Tyvar::Bound(nn)))) => {
  594|      0|                self.resolve_tv(n + 1 + nn)
  595|       |            }
  596|     20|            TypeBound::Eq(t) => (n, Some(t.clone())),
  597|      0|            TypeBound::SubResource => (n, None),
  598|       |        }
  599|     20|    }
  600|       |    /// Construct a namespace path referring to the resource trait for
  601|       |    /// a resource with the given name
  602|      0|    pub fn resource_trait_path(&self, r: Ident) -> Vec<Ident> {
  603|      0|        let mut path = self.mod_cursor.clone();
  604|      0|        let helper = self
  605|      0|            .cur_helper_mod
  606|      0|            .as_ref()
  607|      0|            .expect("There should always be a helper mod to hold a resource trait")
  608|      0|            .clone();
  609|      0|        path.push(helper);
  610|      0|        path.push(r);
  611|      0|        path
  612|      0|    }
  613|       |}
  614|       |
  615|       |/// A parsed representation of a WIT name, containing package
  616|       |/// namespaces, an actual name, and possibly a SemVer version
  617|       |#[derive(Debug, Clone)]
  618|       |pub struct WitName<'a> {
  619|       |    pub namespaces: Vec<&'a str>,
  620|       |    pub name: &'a str,
  621|       |    pub _version: Vec<&'a str>,
  622|       |}
  623|       |impl<'a> WitName<'a> {
  624|       |    /// Extract a list of Rust module names corresponding to the WIT
  625|       |    /// namespace/package
  626|     55|    pub fn namespace_idents(&self) -> Vec<Ident> {
  627|     55|        self.namespaces
  628|     55|            .iter()
  629|    110|            .map(|x| kebab_to_namespace(x))
  630|     55|            .collect::<Vec<_>>()
  631|     55|    }
  632|       |    /// Extract a token stream representing the Rust namespace path
  633|       |    /// corresponding to the WIT namespace/package
  634|     38|    pub fn namespace_path(&self) -> TokenStream {
  635|     38|        let ns = self.namespace_idents();
  636|     38|        quote! { #(#ns)::* }
  637|     38|    }
  638|       |}
  639|       |/// Parse a kebab-name as a WIT name
  640|     41|pub fn split_wit_name(n: &str) -> WitName {
  641|     41|    let mut namespaces = Vec::new();
  642|     41|    let mut colon_components = n.split(':').rev();
  643|     41|    let last = colon_components.next().unwrap();
  644|     41|    namespaces.extend(colon_components.rev());
  645|     41|    let mut slash_components = last.split('/').rev();
  646|     41|    let mut versioned_name = slash_components.next().unwrap().split('@');
  647|     41|    let name = versioned_name.next().unwrap();
  648|     41|    namespaces.extend(slash_components.rev());
  649|     41|    WitName {
  650|     41|        namespaces,
  651|     41|        name,
  652|     41|        _version: versioned_name.collect(),
  653|     41|    }
  654|     41|}
  655|       |
  656|    622|fn kebab_to_snake(n: &str) -> Ident {
  657|    622|    if n == "self" {
  658|      2|        return format_ident!("self_");
  659|    620|    }
  660|    620|    let mut ret = String::new();
  661|  4.26k|    for c in n.chars() {
                           ^620
  662|  4.26k|        if c == '-' {
  663|    250|            ret.push('_');
  664|    250|            continue;
  665|  4.01k|        }
  666|  4.01k|        ret.push(c);
  667|       |    }
  668|    620|    format_ident!("r#{}", ret)
  669|    622|}
  670|       |
  671|    120|fn kebab_to_camel(n: &str) -> Ident {
  672|    120|    let mut word_start = true;
  673|    120|    let mut ret = String::new();
  674|  1.12k|    for c in n.chars() {
                           ^120
  675|  1.12k|        if c == '-' {
  676|     46|            word_start = true;
  677|     46|            continue;
  678|  1.07k|        }
  679|  1.07k|        if word_start {
  680|    166|            ret.extend(c.to_uppercase())
  681|       |        } else {
  682|    912|            ret.push(c)
  683|       |        };
  684|  1.07k|        word_start = false;
  685|       |    }
  686|    120|    format_ident!("{}", ret)
  687|    120|}
  688|       |
  689|       |/// Convert a kebab name to something suitable for use as a
  690|       |/// (value-level) variable
  691|    345|pub fn kebab_to_var(n: &str) -> Ident {
  692|    345|    kebab_to_snake(n)
  693|    345|}
  694|       |/// Convert a kebab name to something suitable for use as a
  695|       |/// type constructor
  696|     30|pub fn kebab_to_cons(n: &str) -> Ident {
  697|     30|    kebab_to_camel(n)
  698|     30|}
  699|       |/// Convert a kebab name to something suitable for use as a getter
  700|       |/// function name
  701|      8|pub fn kebab_to_getter(n: &str) -> Ident {
  702|      8|    kebab_to_snake(n)
  703|      8|}
  704|       |/// Convert a kebab name to something suitable for use as a type name
  705|     90|pub fn kebab_to_type(n: &str) -> Ident {
  706|     90|    kebab_to_camel(n)
  707|     90|}
  708|       |/// Convert a kebab name to something suitable for use as a module
  709|       |/// name/namespace path entry
  710|    150|pub fn kebab_to_namespace(n: &str) -> Ident {
  711|    150|    kebab_to_snake(n)
  712|    150|}
  713|       |/// From a kebab name for a Component, derive something suitable for
  714|       |/// use as the name of the imports trait for that component
  715|      4|pub fn kebab_to_imports_name(trait_name: &str) -> Ident {
  716|      4|    format_ident!("{}Imports", kebab_to_type(trait_name))
  717|      4|}
  718|       |/// From a kebab name for a Component, derive something suitable for
  719|       |/// use as the name of the imports trait for that component
  720|      2|pub fn kebab_to_exports_name(trait_name: &str) -> Ident {
  721|      2|    format_ident!("{}Exports", kebab_to_type(trait_name))
  722|      2|}
  723|       |
  724|       |/// The kinds of names that a function associated with a resource in
  725|       |/// WIT can have
  726|       |pub enum ResourceItemName {
  727|       |    Constructor,
  728|       |    Method(Ident),
  729|       |    Static(Ident),
  730|       |}
  731|       |
  732|       |/// The kinds of names that a function in WIT can have
  733|       |pub enum FnName {
  734|       |    Associated(Ident, ResourceItemName),
  735|       |    Plain(Ident),
  736|       |}
  737|       |/// Parse a kebab-name as a WIT function name, figuring out if it is
  738|       |/// associated with a resource
  739|    121|pub fn kebab_to_fn(n: &str) -> FnName {
  740|    121|    if let Some(n) = n.strip_prefix("[constructor]") {
                              ^2
  741|      2|        return FnName::Associated(kebab_to_type(n), ResourceItemName::Constructor);
  742|    119|    }
  743|    119|    if let Some(n) = n.strip_prefix("[method]") {
                              ^2
  744|      2|        let mut i = n.split('.');
  745|      2|        let r = i.next().unwrap();
  746|      2|        let n = i.next().unwrap();
  747|      2|        return FnName::Associated(
  748|      2|            kebab_to_type(r),
  749|      2|            ResourceItemName::Method(kebab_to_snake(n)),
  750|      2|        );
  751|    117|    }
  752|    117|    if let Some(n) = n.strip_prefix("[static]") {
                              ^0
  753|      0|        let mut i = n.split('.');
  754|      0|        let r = i.next().unwrap();
  755|      0|        let n = i.next().unwrap();
  756|      0|        return FnName::Associated(
  757|      0|            kebab_to_type(r),
  758|      0|            ResourceItemName::Static(kebab_to_snake(n)),
  759|      0|        );
  760|    117|    }
  761|    117|    FnName::Plain(kebab_to_snake(n))
  762|    121|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/etypes.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |/// Elaborated component model types
   18|       |///
   19|       |/// This has the basic type definitions for the elaborated types. They
   20|       |/// correspond roughly to the "Elaborated Types" section in the
   21|       |/// specification.
   22|       |use crate::structure::*;
   23|       |
   24|       |#[derive(Debug, Clone, PartialEq, Copy)]
   25|       |pub struct Name<'a> {
   26|       |    pub name: &'a str,
   27|       |}
   28|       |
   29|       |#[derive(Debug, Clone, PartialEq, Copy)]
   30|       |pub enum IntWidth {
   31|       |    I8,
   32|       |    I16,
   33|       |    I32,
   34|       |    I64,
   35|       |}
   36|       |impl IntWidth {
   37|    338|    pub fn width(self) -> u8 {
   38|    338|        match self {
   39|    128|            IntWidth::I8 => 8,
   40|     48|            IntWidth::I16 => 16,
   41|     72|            IntWidth::I32 => 32,
   42|     90|            IntWidth::I64 => 64,
   43|       |        }
   44|    338|    }
   45|       |}
   46|       |
   47|       |#[derive(Debug, Clone, PartialEq, Copy)]
   48|       |pub enum FloatWidth {
   49|       |    F32,
   50|       |    F64,
   51|       |}
   52|       |impl FloatWidth {
   53|     64|    pub fn width(self) -> u8 {
   54|     64|        match self {
   55|     32|            FloatWidth::F32 => 32,
   56|     32|            FloatWidth::F64 => 64,
   57|       |        }
   58|     64|    }
   59|       |}
   60|       |
   61|       |/// recordfield_e in the specification
   62|       |#[derive(Debug, Clone)]
   63|       |pub struct RecordField<'a> {
   64|       |    pub name: Name<'a>,
   65|       |    pub ty: Value<'a>,
   66|       |}
   67|       |
   68|       |/// variantcase_e in the specification
   69|       |#[derive(Debug, Clone)]
   70|       |pub struct VariantCase<'a> {
   71|       |    pub name: Name<'a>,
   72|       |    pub ty: Option<Value<'a>>,
   73|       |    pub refines: Option<u32>,
   74|       |}
   75|       |
   76|       |/// valtype_e in the specification
   77|       |#[derive(Debug, Clone)]
   78|       |pub enum Value<'a> {
   79|       |    Bool,
   80|       |    S(IntWidth),
   81|       |    U(IntWidth),
   82|       |    F(FloatWidth),
   83|       |    Char,
   84|       |    String,
   85|       |    List(Box<Value<'a>>),
   86|       |    FixList(Box<Value<'a>>, u32),
   87|       |    Record(Vec<RecordField<'a>>),
   88|       |    Tuple(Vec<Value<'a>>),
   89|       |    Flags(Vec<Name<'a>>),
   90|       |    Variant(Vec<VariantCase<'a>>),
   91|       |    Enum(Vec<Name<'a>>),
   92|       |    Option(Box<Value<'a>>),
   93|       |    Result(Box<Option<Value<'a>>>, Box<Option<Value<'a>>>),
   94|       |    Own(Handleable),
   95|       |    Borrow(Handleable),
   96|       |    /// This records that a type variable was once here, and is used
   97|       |    /// to enforce export namedness checks.
   98|       |    Var(Option<Tyvar>, Box<Value<'a>>),
   99|       |}
  100|       |
  101|       |/// Global resource identifier
  102|       |#[derive(Debug, Clone, Copy, PartialEq)]
  103|       |pub struct ResourceId {
  104|       |    pub(super) id: u32,
  105|       |}
  106|       |
  107|       |/// To make certain substitutions easier, free type variables are
  108|       |/// divided into Universal and Existential variables.  Each is
  109|       |/// represented by a pair of indices: the first index is an index into
  110|       |/// [`Ctx::parents()`], specifying parent context has the variable
  111|       |/// definition in it, and the second is an index into that context's
  112|       |/// [`Ctx::uvars`] or [`Ctx::evars`].
  113|       |#[derive(Debug, Clone)]
  114|       |pub enum FreeTyvar {
  115|       |    U(u32, u32),
  116|       |    E(u32, u32),
  117|       |}
  118|       |
  119|       |/// We explicitly distinguish between bound type variables, which are
  120|       |/// can only only present on types that are themselves inside a
  121|       |/// [`QualifiedInstance`] or [`Component`], and free type variables
  122|       |/// that are used while constructing or deconstructing such a type in
  123|       |/// a [`Ctx`].
  124|       |#[derive(Debug, Clone)]
  125|       |pub enum Tyvar {
  126|       |    /// A bound type variable as a de Bruijn index (0 is the innermost
  127|       |    /// binder)
  128|       |    Bound(u32),
  129|       |    /// A free type variable, whose bounds/other information are
  130|       |    /// stored in the context
  131|       |    Free(FreeTyvar),
  132|       |}
  133|       |
  134|       |#[derive(Debug, Clone)]
  135|       |pub struct Param<'a> {
  136|       |    pub name: Name<'a>,
  137|       |    pub ty: Value<'a>,
  138|       |}
  139|       |
  140|       |pub type Result<'a> = Option<Value<'a>>;
  141|       |
  142|       |/// functype_e in the specification
  143|       |#[derive(Debug, Clone)]
  144|       |pub struct Func<'a> {
  145|       |    pub params: Vec<Param<'a>>,
  146|       |    pub result: Result<'a>,
  147|       |}
  148|       |
  149|       |/// In the spec, this does not exist, but a validation rule ensures an
  150|       |/// invariant that certain deftype_e s are of this form.
  151|       |#[derive(Debug, Clone)]
  152|       |pub enum Handleable {
  153|       |    Var(Tyvar),
  154|       |    Resource(ResourceId),
  155|       |}
  156|       |
  157|       |/// deftype_e in the specification
  158|       |#[derive(Debug, Clone)]
  159|       |pub enum Defined<'a> {
  160|       |    Handleable(Handleable),
  161|       |    Value(Value<'a>),
  162|       |    Func(Func<'a>),
  163|       |    Instance(QualifiedInstance<'a>),
  164|       |    Component(Component<'a>),
  165|       |}
  166|       |
  167|       |/// typebound_e in the specification
  168|       |#[derive(Debug, Clone)]
  169|       |pub enum TypeBound<'a> {
  170|       |    Eq(Defined<'a>),
  171|       |    SubResource,
  172|       |}
  173|       |
  174|       |/// The name of an import or export of the current
  175|       |/// component/context. Not in the spec; only used for
  176|       |/// [`BoundedTyvar::origin`] below.
  177|       |///
  178|       |/// Any string present in one of these should also be present in an
  179|       |/// [`ExternDecl::kebab_name`] in a relevant place.
  180|       |#[derive(Debug, Clone, PartialEq)]
  181|       |pub enum ImportExport<'a> {
  182|       |    Import(&'a str),
  183|       |    Export(&'a str),
  184|       |}
  185|       |impl<'a> ImportExport<'a> {
  186|     84|    pub fn name(&self) -> &'a str {
  187|     84|        match self {
  188|     12|            ImportExport::Import(s) => s,
  189|     72|            ImportExport::Export(s) => s,
  190|       |        }
  191|     84|    }
  192|      2|    pub fn imported(&self) -> bool {
  193|      2|        match self {
  194|      2|            ImportExport::Import(_) => true,
  195|      0|            ImportExport::Export(_) => false,
  196|       |        }
  197|      2|    }
  198|       |}
  199|       |
  200|       |/// An (optional) path through the imports/exports of a current
  201|       |/// component/context. Not in the spec; only used for
  202|       |/// [`BoundedTyvar::origin`] below.
  203|       |#[derive(Default, Debug, Clone, PartialEq)]
  204|       |pub struct TyvarOrigin<'a> {
  205|       |    /// Note that the most recent (closest) element is last
  206|       |    pub path: Option<Vec<ImportExport<'a>>>,
  207|       |}
  208|       |
  209|       |impl<'a> TyvarOrigin<'a> {
  210|     17|    pub fn new() -> Self {
  211|     17|        TyvarOrigin { path: Some(vec![]) }
  212|     17|    }
  213|     79|    pub fn push(&self, x: Option<ImportExport<'a>>) -> Self {
  214|     79|        match (&self.path, x) {
  215|      0|            (None, _) => TyvarOrigin { path: None },
  216|     45|            (_, None) => self.clone(),
  217|     34|            (Some(xs), Some(x)) => {
  218|     34|                let mut xs = xs.clone();
  219|     34|                xs.push(x);
  220|     34|                TyvarOrigin { path: Some(xs) }
  221|       |            }
  222|       |        }
  223|     79|    }
  224|      6|    pub fn matches<I: Iterator<Item = &'a ImportExport<'a>>>(&self, path: I) -> bool {
  225|      6|        self.path
  226|      6|            .as_ref()
  227|      6|            .map(|p| p.iter().rev().eq(path))
  228|      6|            .unwrap_or(false)
  229|      6|    }
  230|     45|    pub fn is_local<
  231|     45|        I: DoubleEndedIterator<Item = &'a ImportExport<'a>>
  232|     45|            + ExactSizeIterator<Item = &'a ImportExport<'a>>,
  233|     45|    >(
  234|     45|        &self,
  235|     45|        path: I,
  236|     45|    ) -> Option<Vec<ImportExport<'a>>> {
  237|     45|        let other = path.rev().skip(1).rev();
  238|     45|        let path = self.path.as_ref()?;
                                                   ^0
  239|     45|        let path = path.iter();
  240|     45|        let mut path = path.rev();
  241|     59|        for elem in other {
                          ^14
  242|     14|            match path.next() {
  243|      0|                None => break,
  244|     14|                Some(oe) if oe != elem => return None,
                                   ^0              ^0
  245|     14|                _ => (),
  246|       |            }
  247|       |        }
  248|     45|        Some(path.cloned().collect())
  249|     45|    }
  250|      0|    pub fn last_name(&self) -> Option<&'a str> {
  251|      0|        self.path
  252|      0|            .as_ref()
  253|      0|            .and_then(|x| x.first())
  254|      0|            .map(|ie| ie.name())
  255|      0|    }
  256|      1|    pub fn is_imported(&self) -> bool {
  257|      1|        let Some(p) = &self.path else {
  258|      0|            return false;
  259|       |        };
  260|      1|        p[p.len() - 1].imported()
  261|      1|    }
  262|       |}
  263|       |
  264|       |/// boundedtyvar_e in the spec
  265|       |///
  266|       |/// Because we use a de Bruijn representation of type indices, this is
  267|       |/// only the type_bound - which variable it is binding is implicit in
  268|       |/// its position in the list.
  269|       |#[derive(Debug, Clone)]
  270|       |pub struct BoundedTyvar<'a> {
  271|       |    /// This is not important for typechecking, but is used to keep
  272|       |    /// track of where a type variable originated from in order to
  273|       |    /// decide on a canonical name to be used in bindings
  274|       |    /// generation.
  275|       |    pub origin: TyvarOrigin<'a>,
  276|       |    pub bound: TypeBound<'a>,
  277|       |}
  278|       |
  279|       |impl<'a> BoundedTyvar<'a> {
  280|     17|    pub fn new(bound: TypeBound<'a>) -> Self {
  281|     17|        BoundedTyvar {
  282|     17|            origin: TyvarOrigin::new(),
  283|     17|            bound,
  284|     17|        }
  285|     17|    }
  286|     79|    pub fn push_origin(&self, x: Option<ImportExport<'a>>) -> Self {
  287|     79|        BoundedTyvar {
  288|     79|            origin: self.origin.push(x),
  289|     79|            ..self.clone()
  290|     79|        }
  291|     79|    }
  292|       |}
  293|       |
  294|       |/// externdesc_e in the specification
  295|       |#[derive(Debug, Clone)]
  296|       |pub enum ExternDesc<'a> {
  297|       |    CoreModule(CoreModule<'a>),
  298|       |    Func(Func<'a>),
  299|       |    /* TODO: First-class values (when the spec gets them) */
  300|       |    Type(Defined<'a>),
  301|       |    /// This uses an [`Instance`] rather than a [`QualifiedInstance`]
  302|       |    /// because the instance's evars need to be propagated up to the
  303|       |    /// surrounding component/instance (so that e.g. `alias`ing them
  304|       |    /// and using them in another import/export is possible).
  305|       |    Instance(Instance<'a>),
  306|       |    Component(Component<'a>),
  307|       |}
  308|       |
  309|       |/// Merely a convenience for [`Ctx::resolve_alias`]
  310|       |#[derive(Debug, Clone)]
  311|       |pub enum CoreOrComponentExternDesc<'a> {
  312|       |    Core(CoreExternDesc),
  313|       |    Component(ExternDesc<'a>),
  314|       |}
  315|       |
  316|       |/// externdecl_e in the specification
  317|       |#[derive(Debug, Clone)]
  318|       |pub struct ExternDecl<'a> {
  319|       |    pub kebab_name: &'a str,
  320|       |    pub desc: ExternDesc<'a>,
  321|       |}
  322|       |
  323|       |/// `instancetype_e` in the specification.
  324|       |///
  325|       |/// An "opened" instance, whose existential variables are recorded in
  326|       |/// some surrounding context.
  327|       |#[derive(Debug, Clone)]
  328|       |pub struct Instance<'a> {
  329|       |    pub exports: Vec<ExternDecl<'a>>,
  330|       |}
  331|       |
  332|       |/// This is an instance together with its existential variables. This
  333|       |/// concept doesn't exist as a named syntax class in the specification, but
  334|       |/// is the payload of the instance case of `deftype_e` and the output
  335|       |/// of the instance declaration inference judgement.
  336|       |#[derive(Debug, Clone)]
  337|       |pub struct QualifiedInstance<'a> {
  338|       |    /// Existential variables produced by this instance (which may be
  339|       |    /// referred to by [`exports`](Instance::exports)). These are stored in
  340|       |    /// "outside-in" order that matches how they would be written on
  341|       |    /// paper: de Bruijn index Bound(0) in the imports is the last
  342|       |    /// element in the list, and later elements can depend on earlier
  343|       |    /// ones.
  344|       |    pub evars: Vec<BoundedTyvar<'a>>,
  345|       |    pub unqualified: Instance<'a>,
  346|       |}
  347|       |
  348|       |/// componenttype_e in the specification
  349|       |#[derive(Debug, Clone)]
  350|       |pub struct Component<'a> {
  351|       |    /// Universal variables over which this component is parameterized
  352|       |    /// (which may be referred to by `imports`). These are stored in
  353|       |    /// "outside-in" order that matches how they would be written on
  354|       |    /// paper: de Bruijn index Bound(0) in the imports is the last
  355|       |    /// element in the list, and later elements can depend on earlier
  356|       |    /// ones.
  357|       |    pub uvars: Vec<BoundedTyvar<'a>>,
  358|       |    pub imports: Vec<ExternDecl<'a>>,
  359|       |    /// Since we already have [`QualifiedInstance`], we use that to
  360|       |    /// keep track of both the evars and the actual instance, unlike
  361|       |    /// in the spec; this is quite natural, since during inference the
  362|       |    /// evars are generated by the exports. However, they conceptually
  363|       |    /// belong here as much as there: instantiating a component should
  364|       |    /// add them to the context as non-imported uvars and produce an
  365|       |    /// [`Instance`], rather than a [`QualifiedInstance`] directly.
  366|       |    pub instance: QualifiedInstance<'a>,
  367|       |}
  368|       |
  369|       |// core:importdecl in the specification is wasmparser::Import
  370|       |
  371|       |/// core:importdesc in the specification
  372|       |#[derive(Debug, Clone)]
  373|       |pub enum CoreExternDesc {
  374|       |    Func(wasmparser::FuncType),
  375|       |    Table(wasmparser::TableType),
  376|       |    Memory(wasmparser::MemoryType),
  377|       |    Global(wasmparser::GlobalType),
  378|       |}
  379|       |
  380|       |/// core:exportdecl in the specification
  381|       |#[derive(Debug, Clone)]
  382|       |pub struct CoreExportDecl<'a> {
  383|       |    pub name: Name<'a>,
  384|       |    pub desc: CoreExternDesc,
  385|       |}
  386|       |
  387|       |// core:functype is wasmparser::FuncType
  388|       |
  389|       |/// core:instancetype_e in the specification
  390|       |#[derive(Debug, Clone)]
  391|       |pub struct CoreInstance<'a> {
  392|       |    pub exports: Vec<CoreExportDecl<'a>>,
  393|       |}
  394|       |
  395|       |/// core:moduletype_e in the specification
  396|       |#[derive(Debug, Clone)]
  397|       |pub struct CoreModule<'a> {
  398|       |    pub _imports: Vec<wasmparser::Import<'a>>,
  399|       |    pub _exports: Vec<CoreExportDecl<'a>>,
  400|       |}
  401|       |
  402|       |/// core:deftype_e in the specification
  403|       |#[derive(Debug, Clone)]
  404|       |pub enum CoreDefined<'a> {
  405|       |    Func(wasmparser::FuncType),
  406|       |    Module(CoreModule<'a>),
  407|       |}
  408|       |
  409|       |/// gamma_c in the specification
  410|       |#[derive(Default, Debug, Clone)]
  411|       |pub struct CoreCtx<'a> {
  412|       |    pub types: Vec<CoreDefined<'a>>,
  413|       |    pub funcs: Vec<wasmparser::FuncType>,
  414|       |    pub modules: Vec<CoreModule<'a>>,
  415|       |    pub instances: Vec<CoreInstance<'a>>,
  416|       |    pub tables: Vec<wasmparser::TableType>,
  417|       |    pub mems: Vec<wasmparser::MemoryType>,
  418|       |    pub globals: Vec<wasmparser::GlobalType>,
  419|       |}
  420|       |
  421|       |impl<'a> CoreCtx<'a> {
  422|     25|    pub fn new() -> Self {
  423|     25|        CoreCtx {
  424|     25|            types: Vec::new(),
  425|     25|            funcs: Vec::new(),
  426|     25|            modules: Vec::new(),
  427|     25|            instances: Vec::new(),
  428|     25|            tables: Vec::new(),
  429|     25|            mems: Vec::new(),
  430|     25|            globals: Vec::new(),
  431|     25|        }
  432|     25|    }
  433|       |}
  434|       |
  435|       |/// resourcetype_e in the specification
  436|       |#[derive(Debug, Clone)]
  437|       |pub struct Resource {
  438|       |    // One day, there will be a `rep` field here...
  439|       |    pub _dtor: Option<FuncIdx>,
  440|       |}
  441|       |
  442|       |/// gamma in the specification
  443|       |#[derive(Debug, Clone)]
  444|       |pub struct Ctx<'p, 'a> {
  445|       |    pub parent: Option<&'p Ctx<'p, 'a>>,
  446|       |    pub outer_boundary: bool,
  447|       |    pub core: CoreCtx<'a>,
  448|       |    /// Universally-quantified variables, specifying for each the
  449|       |    /// known bound and whether or not it was imported. Uvars can come
  450|       |    /// from imports or component instantiations; only the imported
  451|       |    /// ones can be allowed to escape in the type of a components
  452|       |    /// exports/imports, since only those can be named outside of the
  453|       |    /// component itself.
  454|       |    pub uvars: Vec<(BoundedTyvar<'a>, bool)>,
  455|       |    /// Existentially-quantified variables, specifying for each the
  456|       |    /// known bound and, if it was locally defined, the type which
  457|       |    /// instantiates it.
  458|       |    pub evars: Vec<(BoundedTyvar<'a>, Option<Defined<'a>>)>,
  459|       |    pub rtypes: Vec<Resource>,
  460|       |    pub types: Vec<Defined<'a>>,
  461|       |    pub components: Vec<Component<'a>>,
  462|       |    pub instances: Vec<Instance<'a>>,
  463|       |    pub funcs: Vec<Func<'a>>,
  464|       |}
  465|       |
  466|       |impl<'p, 'a> Ctx<'p, 'a> {
  467|     25|    pub fn new<'c>(parent: Option<&'p Ctx<'c, 'a>>, outer_boundary: bool) -> Self {
  468|     25|        Ctx {
  469|     25|            parent,
  470|     25|            outer_boundary,
  471|     25|            core: CoreCtx::new(),
  472|     25|            uvars: Vec::new(),
  473|     25|            evars: Vec::new(),
  474|     25|            rtypes: Vec::new(),
  475|     25|            types: Vec::new(),
  476|     25|            components: Vec::new(),
  477|     25|            instances: Vec::new(),
  478|     25|            funcs: Vec::new(),
  479|     25|        }
  480|     25|    }
  481|       |}
  482|       |
  483|       |pub struct CtxParentIterator<'i, 'p: 'i, 'a: 'i> {
  484|       |    ctx: Option<&'i Ctx<'p, 'a>>,
  485|       |}
  486|       |impl<'i, 'p, 'a> Iterator for CtxParentIterator<'i, 'p, 'a> {
  487|       |    type Item = &'i Ctx<'p, 'a>;
  488|    205|    fn next(&mut self) -> Option<Self::Item> {
  489|    205|        match self.ctx {
  490|    205|            Some(ctx) => {
  491|    205|                self.ctx = ctx.parent;
  492|    205|                Some(ctx)
  493|       |            }
  494|      0|            None => None,
  495|       |        }
  496|    205|    }
  497|       |}
  498|       |
  499|       |impl<'p, 'a> Ctx<'p, 'a> {
  500|    205|    pub fn parents<'i>(&'i self) -> CtxParentIterator<'i, 'p, 'a> {
  501|    205|        CtxParentIterator { ctx: Some(self) }
  502|    205|    }
  503|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/guest.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |use proc_macro2::TokenStream;
   18|       |use quote::{format_ident, quote};
   19|       |
   20|       |use crate::emit::{
   21|       |    FnName, ResourceItemName, State, WitName, kebab_to_exports_name, kebab_to_fn, kebab_to_getter,
   22|       |    kebab_to_imports_name, kebab_to_namespace, kebab_to_type, kebab_to_var, split_wit_name,
   23|       |};
   24|       |use crate::etypes::{Component, Defined, ExternDecl, ExternDesc, Handleable, Instance, Tyvar};
   25|       |use crate::hl::{
   26|       |    emit_fn_hl_name, emit_hl_marshal_param, emit_hl_marshal_result, emit_hl_unmarshal_param,
   27|       |    emit_hl_unmarshal_result,
   28|       |};
   29|       |use crate::{resource, rtypes};
   30|       |
   31|       |/// Emit (mostly via returning) code to be added to an `impl <instance
   32|       |/// trait> for Host {}` declaration that implements this extern
   33|       |/// declaration in terms of Hyperlight host calls.
   34|       |///
   35|       |/// For functions associated with a resource, this will instead mutate
   36|       |/// `s` to directly add them to the resource trait implementation and
   37|       |/// return an empty token stream.
   38|      0|fn emit_import_extern_decl<'a, 'b, 'c>(
   39|      0|    s: &'c mut State<'a, 'b>,
   40|      0|    ed: &'c ExternDecl<'b>,
   41|      0|) -> TokenStream {
   42|      0|    match &ed.desc {
   43|      0|        ExternDesc::CoreModule(_) => panic!("core module (im/ex)ports are not supported"),
   44|      0|        ExternDesc::Func(ft) => {
   45|      0|            let param_decls = ft
   46|      0|                .params
   47|      0|                .iter()
   48|      0|                .map(|p| rtypes::emit_func_param(s, p))
   49|      0|                .collect::<Vec<_>>();
   50|      0|            let result_decl = rtypes::emit_func_result(s, &ft.result);
   51|      0|            let hln = emit_fn_hl_name(s, ed.kebab_name);
   52|      0|            let ret = format_ident!("ret");
   53|      0|            let marshal = ft
   54|      0|                .params
   55|      0|                .iter()
   56|      0|                .map(|p| {
   57|      0|                    let me = emit_hl_marshal_param(s, kebab_to_var(p.name.name), &p.ty);
   58|      0|                    quote! { args.push(::hyperlight_common::flatbuffer_wrappers::function_types::ParameterValue::VecBytes(#me)); }
   59|      0|                })
   60|      0|                .collect::<Vec<_>>();
   61|      0|            let unmarshal = emit_hl_unmarshal_result(s, ret.clone(), &ft.result);
   62|      0|            let fnname = kebab_to_fn(ed.kebab_name);
   63|      0|            let n = match &fnname {
   64|      0|                FnName::Plain(n) => quote! { #n },
   65|      0|                FnName::Associated(_, m) => match m {
   66|      0|                    ResourceItemName::Constructor => quote! { new },
   67|      0|                    ResourceItemName::Method(mn) => quote! { #mn },
   68|      0|                    ResourceItemName::Static(mn) => quote! { #mn },
   69|       |                },
   70|       |            };
   71|      0|            let decl = quote! {
   72|      0|                fn #n(&mut self, #(#param_decls),*) -> #result_decl {
   73|      0|                    let mut args = ::alloc::vec::Vec::new();
   74|      0|                    #(#marshal)*
   75|      0|                    let #ret = ::hyperlight_guest_bin::host_comm::call_host_function::<::alloc::vec::Vec<u8>>(
   76|      0|                        #hln,
   77|      0|                        Some(args),
   78|      0|                        ::hyperlight_common::flatbuffer_wrappers::function_types::ReturnType::VecBytes,
   79|      0|                    );
   80|      0|                    let ::core::result::Result::Ok(#ret) = #ret else { panic!("bad return from guest {:?}", #ret) };
   81|      0|                    #[allow(clippy::unused_unit)]
   82|      0|                    #unmarshal
   83|      0|                }
   84|      0|            };
   85|      0|            match fnname {
   86|      0|                FnName::Plain(_) => decl,
   87|      0|                FnName::Associated(r, _) => {
   88|      0|                    // if a resource type could depend on another
   89|      0|                    // tyvar, there might be some complexities
   90|      0|                    // here, but that is not the case at the
   91|      0|                    // moment.
   92|      0|                    let path = s.resource_trait_path(r);
   93|      0|                    s.root_mod.r#impl(path, format_ident!("Host")).extend(decl);
   94|      0|                    TokenStream::new()
   95|       |                }
   96|       |            }
   97|       |        }
   98|      0|        ExternDesc::Type(t) => match t {
   99|      0|            Defined::Handleable(Handleable::Var(Tyvar::Bound(b))) => {
  100|       |                // only resources need something emitted
  101|      0|                let (b, None) = s.resolve_tv(*b) else {
  102|      0|                    return quote! {};
  103|       |                };
  104|      0|                let rtid = format_ident!("HostResource{}", s.var_offset + b as usize);
  105|      0|                let path = s.resource_trait_path(kebab_to_type(ed.kebab_name));
  106|      0|                s.root_mod
  107|      0|                    .r#impl(path, format_ident!("Host"))
  108|      0|                    .extend(quote! {
  109|      0|                        type T = #rtid;
  110|      0|                    });
  111|      0|                TokenStream::new()
  112|       |            }
  113|      0|            _ => quote! {},
  114|       |        },
  115|      0|        ExternDesc::Instance(it) => {
  116|      0|            let wn = split_wit_name(ed.kebab_name);
  117|      0|            emit_import_instance(s, wn.clone(), it);
  118|      0|
  119|      0|            let getter = kebab_to_getter(wn.name);
  120|      0|            let tn = kebab_to_type(wn.name);
  121|      0|            quote! {
  122|      0|                type #tn = Self;
  123|      0|                #[allow(refining_impl_trait)]
  124|      0|                fn #getter<'a>(&'a mut self) -> &'a mut Self {
  125|      0|                    self
  126|      0|                }
  127|      0|            }
  128|       |        }
  129|       |        ExternDesc::Component(_) => {
  130|      0|            panic!("nested components not yet supported in rust bindings");
  131|       |        }
  132|       |    }
  133|      0|}
  134|       |
  135|       |/// Emit (via mutating `s`) an `impl <instance trait> for Host {}`
  136|       |/// declaration that implements this imported instance in terms of
  137|       |/// hyperlight host calls
  138|      0|fn emit_import_instance<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, wn: WitName, it: &'c Instance<'b>) {
  139|      0|    let mut s = s.with_cursor(wn.namespace_idents());
  140|      0|    s.cur_helper_mod = Some(kebab_to_namespace(wn.name));
  141|      0|
  142|      0|    let imports = it
  143|      0|        .exports
  144|      0|        .iter()
  145|      0|        .map(|ed| emit_import_extern_decl(&mut s, ed))
  146|      0|        .collect::<Vec<_>>();
  147|      0|
  148|      0|    let ns = wn.namespace_path();
  149|      0|    let nsi = wn.namespace_idents();
  150|      0|    let trait_name = kebab_to_type(wn.name);
  151|      0|    let r#trait = s.r#trait(&nsi, trait_name.clone());
  152|      0|    let tvs = r#trait
  153|      0|        .tvs
  154|      0|        .iter()
  155|      0|        .map(|(_, (tv, _))| tv.unwrap())
  156|      0|        .collect::<Vec<_>>();
  157|      0|    let tvs = tvs
  158|      0|        .iter()
  159|      0|        .map(|tv| rtypes::emit_var_ref(&mut s, &Tyvar::Bound(*tv)))
  160|      0|        .collect::<Vec<_>>();
  161|      0|    s.root_mod.items.extend(quote! {
  162|      0|        impl #ns::#trait_name <#(#tvs),*> for Host {
  163|      0|            #(#imports)*
  164|      0|        }
  165|      0|    });
  166|      0|}
  167|       |
  168|       |/// Emit (via returning) code to register this particular extern
  169|       |/// definition with Hyperlight as a callable function.
  170|      0|fn emit_export_extern_decl<'a, 'b, 'c>(
  171|      0|    s: &'c mut State<'a, 'b>,
  172|      0|    path: Vec<String>,
  173|      0|    ed: &'c ExternDecl<'b>,
  174|      0|) -> TokenStream {
  175|      0|    match &ed.desc {
  176|      0|        ExternDesc::CoreModule(_) => panic!("core module (im/ex)ports are not supported"),
  177|      0|        ExternDesc::Func(ft) => {
  178|      0|            let fname = emit_fn_hl_name(s, ed.kebab_name);
  179|      0|            let n = match kebab_to_fn(ed.kebab_name) {
  180|      0|                FnName::Plain(n) => n,
  181|       |                FnName::Associated(_, _) => {
  182|      0|                    panic!("resources exported from wasm not yet supported")
  183|       |                }
  184|       |            };
  185|      0|            let pts = ft.params.iter().map(|_| quote! { ::hyperlight_common::flatbuffer_wrappers::function_types::ParameterType::VecBytes }).collect::<Vec<_>>();
  186|      0|            let (pds, pus) = ft.params.iter().enumerate()
  187|      0|                .map(|(i, p)| {
  188|      0|                    let id = kebab_to_var(p.name.name);
  189|      0|                    let pd = quote! { let ::hyperlight_common::flatbuffer_wrappers::function_types::ParameterValue::VecBytes(#id) = &fc.parameters.as_ref().unwrap()[#i] else { panic!("invariant violation: host passed non-VecBytes core hyperlight argument"); }; };
  190|      0|                    let pu = emit_hl_unmarshal_param(s, id, &p.ty);
  191|      0|                    (pd, pu)
  192|      0|                })
  193|      0|                .unzip::<_, _, Vec<_>, Vec<_>>();
  194|      0|            let get_instance = path
  195|      0|                .iter()
  196|      0|                .map(|export| {
  197|      0|                    let n = kebab_to_getter(split_wit_name(export).name);
  198|      0|                    // TODO: Check that name resolution here works
  199|      0|                    // properly with nested instances (not yet supported
  200|      0|                    // in WIT, so we need to use a raw component type to
  201|      0|                    // check)
  202|      0|                    quote! {
  203|      0|                        let mut state = state.#n();
  204|      0|                        let state = ::core::borrow::BorrowMut::borrow_mut(&mut state);
  205|      0|                    }
  206|      0|                })
  207|      0|                .collect::<Vec<_>>();
  208|      0|            let ret = format_ident!("ret");
  209|      0|            let marshal_result = emit_hl_marshal_result(s, ret.clone(), &ft.result);
  210|      0|            let trait_path = s.cur_trait_path();
  211|      0|            quote! {
  212|      0|                fn #n<T: Guest>(fc: &::hyperlight_common::flatbuffer_wrappers::function_call::FunctionCall) -> ::hyperlight_guest::error::Result<::alloc::vec::Vec<u8>> {
  213|      0|                    <T as Guest>::with_guest_state(|state| {
  214|      0|                        #(#pds)*
  215|      0|                        #(#get_instance)*
  216|      0|                        let #ret = #trait_path::#n(state, #(#pus,)*);
  217|      0|                        ::core::result::Result::Ok(::hyperlight_common::flatbuffer_wrappers::util::get_flatbuffer_result::<&[u8]>(&#marshal_result))
  218|      0|                    })
  219|      0|                }
  220|      0|                ::hyperlight_guest_bin::guest_function::register::register_function(
  221|      0|                    ::hyperlight_guest_bin::guest_function::definition::GuestFunctionDefinition::new(
  222|      0|                        ::alloc::string::ToString::to_string(#fname),
  223|      0|                        ::alloc::vec![#(#pts),*],
  224|      0|                        ::hyperlight_common::flatbuffer_wrappers::function_types::ReturnType::VecBytes,
  225|      0|                        #n::<T> as usize
  226|      0|                    )
  227|      0|                );
  228|      0|            }
  229|       |        }
  230|       |        ExternDesc::Type(_) => {
  231|       |            // no runtime representation is needed for types
  232|      0|            quote! {}
  233|       |        }
  234|      0|        ExternDesc::Instance(it) => {
  235|      0|            let wn = split_wit_name(ed.kebab_name);
  236|      0|            let mut path = path.clone();
  237|      0|            path.push(ed.kebab_name.to_string());
  238|      0|            emit_export_instance(s, wn.clone(), path, it)
  239|       |        }
  240|       |        ExternDesc::Component(_) => {
  241|      0|            panic!("nested components not yet supported in rust bindings");
  242|       |        }
  243|       |    }
  244|      0|}
  245|       |
  246|       |/// Emit (via returning) code to register each export of the given
  247|       |/// instance with Hyperlight as a callable function.
  248|       |///
  249|       |/// - `path`: the instance path (from the root component) where this
  250|       |///   definition may be found, used to locate the correct component of
  251|       |///   the guest state. This should already have been updated for this
  252|       |///   instance by the caller!
  253|      0|fn emit_export_instance<'a, 'b, 'c>(
  254|      0|    s: &'c mut State<'a, 'b>,
  255|      0|    wn: WitName,
  256|      0|    path: Vec<String>,
  257|      0|    it: &'c Instance<'b>,
  258|      0|) -> TokenStream {
  259|      0|    let mut s = s.with_cursor(wn.namespace_idents());
  260|      0|    s.cur_helper_mod = Some(kebab_to_namespace(wn.name));
  261|      0|    s.cur_trait = Some(kebab_to_type(wn.name));
  262|      0|    let exports = it
  263|      0|        .exports
  264|      0|        .iter()
  265|      0|        .map(|ed| emit_export_extern_decl(&mut s, path.clone(), ed))
  266|      0|        .collect::<Vec<_>>();
  267|      0|    quote! { #(#exports)* }
  268|      0|}
  269|       |
  270|       |/// Emit (via mutating `s`):
  271|       |/// - a resource table for each resource exported by this component
  272|       |/// - impl T for Host for each relevant trait T
  273|       |///
  274|       |/// Emit (via returning):
  275|       |/// - Hyperlight guest function ABI wrapper for each guest function
  276|       |/// - Hyperlight guest function register calls for each guest function
  277|      0|fn emit_component<'a, 'b, 'c>(
  278|      0|    s: &'c mut State<'a, 'b>,
  279|      0|    wn: WitName,
  280|      0|    ct: &'c Component<'b>,
  281|      0|) -> TokenStream {
  282|      0|    let mut s = s.with_cursor(wn.namespace_idents());
  283|      0|    let ns = wn.namespace_path();
  284|      0|    let r#trait = kebab_to_type(wn.name);
  285|      0|    let import_trait = kebab_to_imports_name(wn.name);
  286|      0|    let export_trait = kebab_to_exports_name(wn.name);
  287|      0|    s.import_param_var = Some(format_ident!("I"));
  288|      0|    s.self_param_var = Some(format_ident!("S"));
  289|      0|
  290|      0|    let rtsid = format_ident!("{}Resources", r#trait);
  291|      0|    resource::emit_tables(
  292|      0|        &mut s,
  293|      0|        rtsid.clone(),
  294|      0|        quote! { #ns::#import_trait + ::core::marker::Send + 'static },
  295|      0|        Some(quote! { #ns::#export_trait<I> }),
  296|      0|        true,
  297|      0|    );
  298|      0|    s.root_mod
  299|      0|        .items
  300|      0|        .extend(s.bound_vars.iter().enumerate().map(|(i, _)| {
  301|      0|            let id = format_ident!("HostResource{}", i);
  302|      0|            quote! {
  303|      0|                pub struct #id { rep: u32 }
  304|      0|            }
  305|      0|        }));
  306|      0|
  307|      0|    s.var_offset = ct.instance.evars.len();
  308|      0|    s.cur_trait = Some(import_trait.clone());
  309|      0|    let imports = ct
  310|      0|        .imports
  311|      0|        .iter()
  312|      0|        .map(|ed| emit_import_extern_decl(&mut s, ed))
  313|      0|        .collect::<Vec<_>>();
  314|      0|
  315|      0|    s.var_offset = 0;
  316|      0|
  317|      0|    let exports = ct
  318|      0|        .instance
  319|      0|        .unqualified
  320|      0|        .exports
  321|      0|        .iter()
  322|      0|        .map(|ed| emit_export_extern_decl(&mut s, Vec::new(), ed))
  323|      0|        .collect::<Vec<_>>();
  324|      0|
  325|      0|    s.root_mod.items.extend(quote! {
  326|      0|        impl #ns::#import_trait for Host {
  327|      0|            #(#imports)*
  328|      0|        }
  329|      0|    });
  330|      0|    quote! {
  331|      0|        #(#exports)*
  332|      0|    }
  333|      0|}
  334|       |
  335|       |/// In addition to the items emitted by [`emit_component`], mutate `s`
  336|       |/// to emit:
  337|       |/// - a dummy `Host` type to reflect host functions
  338|       |/// - a toplevel `Guest` trait that can be implemented to provide access to
  339|       |///   any guest state
  340|       |/// - a `hyperlight_guest_init` function that registers all guest
  341|       |/// - functions when given a type that implements the `Guest` trait
  342|      0|pub fn emit_toplevel<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, n: &str, ct: &'c Component<'b>) {
  343|      0|    s.is_impl = true;
  344|      0|    log::debug!("\n\n=== starting guest emit ===\n");
  345|      0|    let wn = split_wit_name(n);
  346|      0|
  347|      0|    let ns = wn.namespace_path();
  348|      0|    let export_trait = kebab_to_exports_name(wn.name);
  349|      0|
  350|      0|    let tokens = emit_component(s, wn, ct);
  351|      0|
  352|      0|    s.root_mod.items.extend(quote! {
  353|      0|        pub struct Host {}
  354|      0|
  355|      0|        /// Because Hyperlight guest functions can't close over any
  356|      0|        /// state, this function is used on each guest call to acquire
  357|      0|        /// any state that the guest functions might need.
  358|      0|        pub trait Guest: #ns::#export_trait<Host> {
  359|      0|            fn with_guest_state<R, F: FnOnce(&mut Self) -> R>(f: F) -> R;
  360|      0|        }
  361|      0|        /// Register all guest functions.
  362|      0|        pub fn hyperlight_guest_init<T: Guest>() {
  363|      0|            #tokens
  364|      0|        }
  365|      0|    });
  366|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/hl.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |use itertools::Itertools;
   18|       |use proc_macro2::{Ident, TokenStream};
   19|       |use quote::{format_ident, quote};
   20|       |
   21|       |use crate::emit::{State, kebab_to_cons, kebab_to_var};
   22|       |use crate::etypes::{self, Defined, Handleable, TypeBound, Tyvar, Value};
   23|       |use crate::rtypes;
   24|       |
   25|       |/// Construct a string that can be used "on the wire" to identify a
   26|       |/// given function between the guest/host.  This should be replaced
   27|       |/// with an integer index so that we can dispatch less dynamically in
   28|       |/// the future.
   29|     79|pub fn emit_fn_hl_name(s: &State, kebab: &str) -> String {
   30|     79|    s.mod_cursor
   31|     79|        .iter()
   32|    158|        .map(|x| x.to_string())
   33|     79|        .chain(std::iter::once(kebab.to_string()))
   34|     79|        .join("::")
   35|     79|}
   36|       |
   37|       |/// Emit code to unmarshal a value into a toplevel type (i.e. types
   38|       |/// that cannot be represented inline in a valtype).
   39|       |/// - `id`: an ident of a slice that the code will unmarshal from; also
   40|       |///   used as the beginning of any other identifiers that this code
   41|       |///   declares (if only we had hygiene in stable rust...)
   42|       |/// - `tv`: the tyvar that we followed to get to this type
   43|       |/// - `vt`: the value type that we are unmarshalling
   44|       |///
   45|       |/// The token stream produced will be an expression which typechecks
   46|       |/// as a tuple whose first component is the Rust type (as defined by
   47|       |/// the [`crate::rtypes`] module) of the given value type and whose
   48|       |/// second component is an integer. The second component represents
   49|       |/// the number of bytes consumed from the `id` slice while
   50|       |/// unmarshalling.
   51|     10|pub fn emit_hl_unmarshal_toplevel_value(
   52|     10|    s: &mut State,
   53|     10|    id: Ident,
   54|     10|    tv: Tyvar,
   55|     10|    vt: &Value,
   56|     10|) -> TokenStream {
   57|     10|    let tname = rtypes::emit_var_ref_value(s, &tv);
   58|     10|    let mut s = s.clone();
   59|     10|    let Tyvar::Bound(n) = tv else {
   60|      0|        panic!("impossible tyvar")
   61|       |    };
   62|     10|    s.var_offset += n as usize + 1;
   63|     10|    let s = &mut s;
   64|     10|    match vt {
   65|      2|        Value::Record(rfs) => {
   66|      2|            let cursor = format_ident!("{}_cursor", id);
   67|      2|            let inid = format_ident!("{}_field", id);
   68|      2|            let (decls, uses) = rfs
   69|      2|                .iter()
   70|      4|                .map(|rf| {
   71|      4|                    let field_name = kebab_to_var(rf.name.name);
   72|      4|                    let field_name_var = format_ident!("{}_field_{}", id, field_name);
   73|      4|                    let vtun = emit_hl_unmarshal_value(s, inid.clone(), &rf.ty);
   74|      4|                    (
   75|      4|                        quote! {
   76|      4|                            let #inid = &#id[#cursor..];
   77|      4|                            let (#field_name_var, b) = { #vtun };
   78|      4|                            #cursor += b;
   79|      4|                        },
   80|      4|                        quote! {
   81|      4|                            #field_name: #field_name_var,
   82|      4|                        },
   83|      4|                    )
   84|      4|                })
   85|      2|                .unzip::<_, _, Vec<_>, Vec<_>>();
   86|      2|            quote! {
   87|      2|                let mut #cursor = 0;
   88|      2|                #(#decls)*
   89|      2|                (#tname { #(#uses)* }, #cursor)
   90|      2|            }
   91|       |        }
   92|      4|        Value::Flags(ns) => {
   93|      4|            let bytes = usize::div_ceil(ns.len(), 8);
   94|     70|            let fields = ns.iter().enumerate().map(|(i, n)| {
   95|     70|                let byte_offset = i / 8;
   96|     70|                let bit_offset = i % 8;
   97|     70|                let fieldid = kebab_to_var(n.name);
   98|     70|                quote! {
   99|     70|                    #fieldid: (#id[#byte_offset] >> #bit_offset) & 0x1 == 1,
  100|     70|                }
  101|     70|            });
  102|      4|            quote! {
  103|      4|                (#tname { #(#fields)* }, #bytes)
  104|      4|            }
  105|       |        }
  106|      2|        Value::Variant(vcs) => {
  107|      2|            let inid = format_ident!("{}_body", id);
  108|      6|            let vcs = vcs.iter().enumerate().map(|(i, vc)| {
  109|      6|                let case_name = kebab_to_cons(vc.name.name);
  110|      6|                let i = i as u32;
  111|      6|                let case_name_var = format_ident!("{}_case_{}", id, case_name);
  112|      6|                match &vc.ty {
  113|      4|                    Some(ty) => {
  114|      4|                        let vtun = emit_hl_unmarshal_value(s, inid.clone(), ty);
  115|      4|                        quote! {
  116|      4|                            #i => {
  117|      4|                                let (#case_name_var, b) = { #vtun };
  118|      4|                                (#tname::#case_name(#case_name_var), b + 4)
  119|      4|                            }
  120|      4|                        }
  121|       |                    }
  122|      2|                    None => quote! {
  123|      2|                        #i => (#tname::#case_name, 4)
  124|      2|                    },
  125|       |                }
  126|      6|            });
  127|      2|            quote! {
  128|      2|                let n = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  129|      2|                let #inid = &#id[4..];
  130|      2|                match n {
  131|      2|                    #(#vcs,)*
  132|      2|                    _ => panic!("invalid value for variant"),
  133|      2|                }
  134|      2|            }
  135|       |        }
  136|      2|        Value::Enum(ns) => {
  137|      6|            let vcs = ns.iter().enumerate().map(|(i, n)| {
  138|      6|                let case_name = kebab_to_cons(n.name);
  139|      6|                let i = i as u32;
  140|      6|                quote! { #i => ( #tname::#case_name, 4) }
  141|      6|            });
  142|      2|            quote! {
  143|      2|                let n = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  144|      2|                match n {
  145|      2|                    #(#vcs,)*
  146|      2|                    _ => panic!("invalid value for enum"),
  147|      2|                }
  148|      2|            }
  149|       |        }
  150|      0|        _ => emit_hl_unmarshal_value(s, id, vt),
  151|       |    }
  152|     10|}
  153|       |
  154|       |/// Find the resource index that the given type variable refers to.
  155|       |///
  156|       |/// Precondition: this type variable does refer to a resource type
  157|      5|fn resolve_tyvar_to_resource(s: &mut State, v: u32) -> u32 {
  158|      5|    match s.bound_vars[v as usize].bound {
  159|      5|        TypeBound::SubResource => v,
  160|      0|        TypeBound::Eq(Defined::Handleable(Handleable::Var(Tyvar::Bound(vv)))) => {
  161|      0|            resolve_tyvar_to_resource(s, v + vv + 1)
  162|       |        }
  163|      0|        _ => panic!("impossible: resource var is not resource"),
  164|       |    }
  165|      5|}
  166|       |/// Find the resource index that the given Handleable refers to.
  167|       |///
  168|       |/// Precondition: this type variable does refer to a resource type
  169|      5|pub fn resolve_handleable_to_resource(s: &mut State, ht: &Handleable) -> u32 {
  170|      5|    match ht {
  171|      5|        Handleable::Var(Tyvar::Bound(vi)) => {
  172|      5|            resolve_tyvar_to_resource(s, s.var_offset as u32 + *vi)
  173|       |        }
  174|      0|        _ => panic!("impossible handleable in type"),
  175|       |    }
  176|      5|}
  177|       |
  178|       |/// Emit code to unmarshal a value into an inline-able value type
  179|       |/// - `id`: an ident of a slice that the code will unmarshal from; also
  180|       |///   used as the beginning of any other identifiers that this code
  181|       |///   declares (if only we had hygiene in stable rust...)
  182|       |/// - `vt`: the value type that we are unmarshalling
  183|       |///
  184|       |/// The token stream produced will be an expression which typechecks
  185|       |/// as a tuple whose first component is the Rust type (as defined by
  186|       |/// the [`crate::rtypes`] module) of the given value type and whose
  187|       |/// second component is an integer. The second component represents
  188|       |/// the number of bytes consumed from the `id` slice while
  189|       |/// unmarshalling.
  190|    132|pub fn emit_hl_unmarshal_value(s: &mut State, id: Ident, vt: &Value) -> TokenStream {
  191|    132|    match vt {
  192|      3|        Value::Bool => quote! { (#id[0] != 0, 1) },
  193|       |        Value::S(_) | Value::U(_) | Value::F(_) => {
  194|     51|            let (tid, width) = rtypes::numeric_rtype(vt);
  195|     51|            let blen = width as usize / 8;
  196|     51|            quote! {
  197|     51|                (#tid::from_ne_bytes(#id[0..#blen].try_into().unwrap()), #blen)
  198|     51|            }
  199|       |        }
  200|      8|        Value::Char => quote! {
  201|      8|            (unsafe { char::from_u32_unchecked(u32::from_ne_bytes(
  202|      8|                #id[0..4].try_into().unwrap())) }, 4)
  203|      8|        },
  204|     17|        Value::String => quote! {
  205|     17|            let n = u32::from_ne_bytes(#id[0..4].try_into().unwrap()) as usize;
  206|     17|            let s = ::alloc::string::ToString::to_string(::core::str::from_utf8(&#id[4..4 + n]).unwrap()); // todo: better error handling
  207|     17|            (s, n + 4)
  208|     17|        },
  209|      6|        Value::List(vt) => {
  210|      6|            let retid = format_ident!("{}_list", id);
  211|      6|            let inid = format_ident!("{}_elem", id);
  212|      6|            let vtun = emit_hl_unmarshal_value(s, inid.clone(), vt);
  213|      6|            quote! {
  214|      6|                let n = u32::from_ne_bytes(#id[0..4].try_into().unwrap()) as usize;
  215|      6|                let mut #retid = alloc::vec::Vec::new();
  216|      6|                let mut cursor = 4;
  217|      6|                for i in 0..n {
  218|      6|                    let #inid = &#id[cursor..];
  219|      6|                    let (x, b) = { #vtun };
  220|      6|                    cursor += b;
  221|      6|                    #retid.push(x);
  222|      6|                }
  223|      6|                (#retid, cursor)
  224|      6|            }
  225|       |        }
  226|     28|        Value::FixList(vt, _) => {
  227|     28|            let inid = format_ident!("{}_elem", id);
  228|     28|            let vtun = emit_hl_unmarshal_value(s, inid.clone(), vt);
  229|     28|            quote! {
  230|     28|                let mut cursor = 0;
  231|     28|                let arr = ::core::array::from_fn(|_i| {
  232|     28|                    let #inid = &#id[cursor..];
  233|     28|                    let (x, b) = { #vtun };
  234|     28|                    cursor += b;
  235|     28|                    x
  236|     28|                });
  237|     28|                (arr, cursor)
  238|     28|            }
  239|       |        }
  240|      0|        Value::Record(_) => panic!("record not at top level of valtype"),
  241|      2|        Value::Tuple(vts) => {
  242|      2|            let inid = format_ident!("{}_elem", id);
  243|      2|            let len = format_ident!("{}_len", id);
  244|      2|            let (ns, vtuns) = vts
  245|      2|                .iter()
  246|      2|                .enumerate()
  247|      4|                .map(|(i, vt)| {
  248|      4|                    let vtun = emit_hl_unmarshal_value(s, inid.clone(), vt);
  249|      4|                    let retid = format_ident!("{}_elem{}", id, i);
  250|      4|                    (
  251|      4|                        retid.clone(),
  252|      4|                        quote! {
  253|      4|                            let (#retid, b) = { #vtun };
  254|      4|                            #len += b;
  255|      4|                            let #inid = &#inid[b..];
  256|      4|                        },
  257|      4|                    )
  258|      4|                })
  259|      2|                .unzip::<_, _, Vec<_>, Vec<_>>();
  260|      2|            quote! {
  261|      2|                let #inid = &#id[0..];
  262|      2|                let mut #len = 0;
  263|      2|                #(#vtuns)*
  264|      2|                ((#(#ns),*), #len)
  265|      2|            }
  266|       |        }
  267|      0|        Value::Flags(_) => panic!("flags not at top level of valtype"),
  268|      0|        Value::Variant(_) => panic!("variant not at top level of valtype"),
  269|      0|        Value::Enum(_) => panic!("enum not at top level of valtype"),
  270|      2|        Value::Option(vt) => {
  271|      2|            let inid = format_ident!("{}_body", id);
  272|      2|            let vtun = emit_hl_unmarshal_value(s, inid.clone(), vt);
  273|      2|            quote! {
  274|      2|                let n = u8::from_ne_bytes(#id[0..1].try_into().unwrap());
  275|      2|                if n != 0 {
  276|      2|                    let #inid = &#id[1..];
  277|      2|                    let (x, b) = { #vtun };
  278|      2|                    (::core::option::Option::Some(x), b + 1)
  279|      2|                } else {
  280|      2|                    (::core::option::Option::None, 1)
  281|      2|                }
  282|      2|            }
  283|       |        }
  284|      2|        Value::Result(vt1, vt2) => {
  285|      2|            let inid = format_ident!("{}_body", id);
  286|      2|            let vtun1 = if let Some(ref vt1) = **vt1 {
  287|      2|                emit_hl_unmarshal_value(s, inid.clone(), vt1)
  288|       |            } else {
  289|      0|                quote! { ((), 0) }
  290|       |            };
  291|      2|            let vtun2 = if let Some(ref vt2) = **vt2 {
  292|      2|                emit_hl_unmarshal_value(s, inid.clone(), vt2)
  293|       |            } else {
  294|      0|                quote! { ((), 0) }
  295|       |            };
  296|      2|            quote! {
  297|      2|                let i = u8::from_ne_bytes(#id[0..1].try_into().unwrap());
  298|      2|                let #inid = &#id[1..];
  299|      2|                if i == 0 {
  300|      2|                    let (x, b) = { #vtun1 };
  301|      2|                    (::core::result::Result::Ok(x), b + 1)
  302|      2|                } else {
  303|      2|                    let (x, b)= { #vtun2 };
  304|      2|                    (::core::result::Result::Err(x), b +1)
  305|      2|                }
  306|      2|            }
  307|       |        }
  308|      2|        Value::Own(ht) => {
  309|      2|            let vi = resolve_handleable_to_resource(s, ht);
  310|      2|            log::debug!("resolved ht to r (1) {:?} {:?}", ht, vi);
                                      ^0
  311|      2|            if s.is_guest {
  312|      0|                let rid = format_ident!("HostResource{}", vi);
  313|      0|                if s.is_wasmtime_guest {
  314|      0|                    quote! {
  315|      0|                        let i = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  316|      0|                        (::wasmtime::component::Resource::<#rid>::new_own(i), 4)
  317|      0|                    }
  318|       |                } else {
  319|      0|                    quote! {
  320|      0|                        let i = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  321|      0|                        (#rid { rep: i }, 4)
  322|      0|                    }
  323|       |                }
  324|       |            } else {
  325|      2|                let rid = format_ident!("resource{}", vi);
  326|      2|                quote! {
  327|      2|                    let i = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  328|      2|                    let Some(v) = rts.#rid[i as usize].take() else {
  329|      2|                        // todo: better error handling
  330|      2|                        panic!("");
  331|      2|                    };
  332|      2|                    (v, 4)
  333|      2|                }
  334|       |            }
  335|       |        }
  336|      1|        Value::Borrow(ht) => {
  337|      1|            let vi = resolve_handleable_to_resource(s, ht);
  338|      1|            log::debug!("resolved ht to r (2) {:?} {:?}", ht, vi);
                                      ^0
  339|      1|            if s.is_guest {
  340|      0|                let rid = format_ident!("HostResource{}", vi);
  341|      0|                quote! {
  342|      0|                    let i = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  343|      0|                    (::wasmtime::component::Resource::<#rid>::new_borrow(i), 4)
  344|      0|                }
  345|       |            } else {
  346|      1|                let rid = format_ident!("resource{}", vi);
  347|      1|                quote! {
  348|      1|                    let i = u32::from_ne_bytes(#id[0..4].try_into().unwrap());
  349|      1|                    let Some(v) = rts.#rid[i as usize].borrow() else {
  350|      1|                        // todo: better error handling
  351|      1|                        panic!("");
  352|      1|                    };
  353|      1|                    (v, 4)
  354|      1|                }
  355|       |            }
  356|       |        }
  357|     10|        Value::Var(tv, _) => {
  358|     10|            let Some(Tyvar::Bound(n)) = tv else {
  359|      0|                panic!("impossible tyvar")
  360|       |            };
  361|     10|            let (n, Some(Defined::Value(vt))) = s.resolve_tv(*n) else {
  362|      0|                panic!("unresolvable tyvar (2)");
  363|       |            };
  364|     10|            let vt = vt.clone();
  365|     10|            emit_hl_unmarshal_toplevel_value(s, id, Tyvar::Bound(n), &vt)
  366|       |        }
  367|       |    }
  368|    132|}
  369|       |
  370|       |/// Emit code to marshal a value from a toplevel type (i.e. types that
  371|       |/// cannot be represented inline in a valtype).
  372|       |/// - `id`: an ident of a Rust value of the Rust type (as defined by
  373|       |///   the [`crate::rtypes`] module) of the given value type that is
  374|       |///   being marshaled from
  375|       |/// - `tv`: the tyvar that we followed to get to this type
  376|       |/// - `vt`: the value type that we are marshaling
  377|       |///
  378|       |/// The token stream produced will be an expression which typechecks
  379|       |/// as `Vec<u8`>`.
  380|     10|pub fn emit_hl_marshal_toplevel_value(
  381|     10|    s: &mut State,
  382|     10|    id: Ident,
  383|     10|    tv: Tyvar,
  384|     10|    vt: &Value,
  385|     10|) -> TokenStream {
  386|     10|    let tname = rtypes::emit_var_ref_value(s, &tv);
  387|     10|    let mut s = s.clone();
  388|     10|    let Tyvar::Bound(n) = tv else {
  389|      0|        panic!("impossible tyvar")
  390|       |    };
  391|     10|    s.var_offset += n as usize + 1;
  392|     10|    let s = &mut s;
  393|     10|    match vt {
  394|      2|        Value::Record(rfs) => {
  395|      2|            let retid = format_ident!("{}_record", id);
  396|      2|            let fields = rfs
  397|      2|                .iter()
  398|      4|                .map(|rf| {
  399|      4|                    let field_name = kebab_to_var(rf.name.name);
  400|      4|                    let fieldid = format_ident!("{}_field_{}", id, field_name);
  401|      4|                    let vtun = emit_hl_marshal_value(s, fieldid.clone(), &rf.ty);
  402|      4|                    quote! {
  403|      4|                        let #fieldid = #id.#field_name;
  404|      4|                        #retid.extend({ #vtun });
  405|      4|                    }
  406|      4|                })
  407|      2|                .collect::<Vec<_>>();
  408|      2|            quote! {
  409|      2|                let mut #retid = alloc::vec::Vec::new();
  410|      2|                #(#fields)*
  411|      2|                #retid
  412|      2|            }
  413|       |        }
  414|      4|        Value::Flags(ns) => {
  415|      4|            let bytes = usize::div_ceil(ns.len(), 8);
  416|      4|            let fields = ns
  417|      4|                .iter()
  418|      4|                .enumerate()
  419|     70|                .map(|(i, n)| {
  420|     70|                    let byte_offset = i / 8;
  421|     70|                    let bit_offset = i % 8;
  422|     70|                    let fieldid = kebab_to_var(n.name);
  423|     70|                    quote! {
  424|     70|                        bytes[#byte_offset] |= (if #id.#fieldid { 1 } else { 0 }) << #bit_offset;
  425|     70|                    }
  426|     70|                })
  427|      4|                .collect::<Vec<_>>();
  428|      4|            quote! {
  429|      4|                let mut bytes = [0; #bytes];
  430|      4|                #(#fields)*
  431|      4|                alloc::vec::Vec::from(bytes)
  432|      4|            }
  433|       |        }
  434|      2|        Value::Variant(vcs) => {
  435|      2|            let retid = format_ident!("{}_ret", id);
  436|      2|            let bodyid = format_ident!("{}_body", id);
  437|      2|            let vcs = vcs
  438|      2|                .iter()
  439|      2|                .enumerate()
  440|      6|                .map(|(i, vc)| {
  441|      6|                    let i = i as u32;
  442|      6|                    let case_name = kebab_to_cons(vc.name.name);
  443|      6|                    match &vc.ty {
  444|      4|                        Some(ty) => {
  445|      4|                            let vtun = emit_hl_marshal_value(s, bodyid.clone(), ty);
  446|      4|                            quote! {
  447|      4|                               #tname::#case_name(#bodyid) => {
  448|      4|                                    #retid.extend(u32::to_ne_bytes(#i));
  449|      4|                                    #retid.extend({ #vtun })
  450|      4|                                }
  451|      4|                            }
  452|       |                        }
  453|       |                        None => {
  454|      2|                            quote! {
  455|      2|                                #tname::#case_name => {
  456|      2|                                    #retid.extend(u32::to_ne_bytes(#i));
  457|      2|                                }
  458|      2|                            }
  459|       |                        }
  460|       |                    }
  461|      6|                })
  462|      2|                .collect::<Vec<_>>();
  463|      2|            quote! {
  464|      2|                let mut #retid = alloc::vec::Vec::new();
  465|      2|                match #id {
  466|      2|                    #(#vcs)*
  467|      2|                }
  468|      2|                #retid
  469|      2|            }
  470|       |        }
  471|      2|        Value::Enum(ns) => {
  472|      6|            let vcs = ns.iter().enumerate().map(|(i, n)| {
  473|      6|                let case_name = kebab_to_cons(n.name);
  474|      6|                let i = i as u32;
  475|      6|                quote! { #tname::#case_name => #i }
  476|      6|            });
  477|      2|            quote! {
  478|      2|                alloc::vec::Vec::from(u32::to_ne_bytes(match #id {
  479|      2|                    #(#vcs,)*
  480|      2|                }))
  481|      2|            }
  482|       |        }
  483|      0|        _ => emit_hl_marshal_value(s, id, vt),
  484|       |    }
  485|     10|}
  486|       |
  487|       |/// Emit code to marshal a value from an inline-able value type
  488|       |/// - `id`: an ident of a Rust value of the Rust type (as defined by
  489|       |///   the [`crate::rtypes`] module) of the given value type that is
  490|       |///   being marshaled from
  491|       |/// - `vt`: the value type that we are marshaling
  492|       |///
  493|       |/// The token stream produced will be an expression which typechecks
  494|       |/// as `Vec<u8>`.
  495|    127|pub fn emit_hl_marshal_value(s: &mut State, id: Ident, vt: &Value) -> TokenStream {
  496|    127|    match vt {
  497|      2|        Value::Bool => quote! {
  498|      2|            alloc::vec![if #id { 1u8 } else { 0u8 }]
  499|      2|        },
  500|       |        Value::S(_) | Value::U(_) | Value::F(_) => {
  501|     51|            let (tid, _) = rtypes::numeric_rtype(vt);
  502|     51|            quote! { alloc::vec::Vec::from(#tid::to_ne_bytes(#id)) }
  503|       |        }
  504|      6|        Value::Char => quote! {
  505|      6|            alloc::vec::Vec::from((#id as u32).to_ne_bytes())
  506|      6|        },
  507|       |        Value::String => {
  508|     16|            let retid = format_ident!("{}_string", id);
  509|     16|            let bytesid = format_ident!("{}_bytes", id);
  510|     16|            quote! {
  511|     16|                let mut #retid = alloc::vec::Vec::new();
  512|     16|                let #bytesid = #id.into_bytes();
  513|     16|                #retid.extend(alloc::vec::Vec::from(u32::to_ne_bytes(#bytesid.len() as u32)));
  514|     16|                #retid.extend(#bytesid);
  515|     16|                #retid
  516|     16|            }
  517|       |        }
  518|      6|        Value::List(vt) => {
  519|      6|            let retid = format_ident!("{}_list", id);
  520|      6|            let inid = format_ident!("{}_elem", id);
  521|      6|            let vtun = emit_hl_marshal_value(s, inid.clone(), vt);
  522|      6|            quote! {
  523|      6|                let mut #retid = alloc::vec::Vec::new();
  524|      6|                let n = #id.len();
  525|      6|                #retid.extend(alloc::vec::Vec::from(u32::to_ne_bytes(n as u32)));
  526|      6|                for #inid in #id {
  527|      6|                    #retid.extend({ #vtun })
  528|      6|                }
  529|      6|                #retid
  530|      6|            }
  531|       |        }
  532|     28|        Value::FixList(vt, _size) => {
  533|     28|            let retid = format_ident!("{}_fixlist", id);
  534|     28|            let inid = format_ident!("{}_elem", id);
  535|     28|            let vtun = emit_hl_marshal_value(s, inid.clone(), vt);
  536|     28|            quote! {
  537|     28|                let mut #retid = alloc::vec::Vec::new();
  538|     28|                for #inid in #id {
  539|     28|                    #retid.extend({ #vtun })
  540|     28|                }
  541|     28|                #retid
  542|     28|            }
  543|       |        }
  544|      0|        Value::Record(_) => panic!("record not at top level of valtype"),
  545|      2|        Value::Tuple(vts) => {
  546|      2|            let retid = format_ident!("{}_tuple", id);
  547|      2|            let inid = format_ident!("{}_elem", id);
  548|      4|            let vtuns = vts.iter().enumerate().map(|(i, vt)| {
  549|      4|                let i = syn::Index::from(i);
  550|      4|                let vtun = emit_hl_marshal_value(s, inid.clone(), vt);
  551|      4|                quote! {
  552|      4|                    let #inid = #id.#i;
  553|      4|                    #retid.extend({ #vtun });
  554|      4|                }
  555|      4|            });
  556|      2|            quote! {
  557|      2|                let mut #retid = alloc::vec::Vec::new();
  558|      2|                #(#vtuns)*
  559|      2|                #retid
  560|      2|            }
  561|       |        }
  562|      0|        Value::Flags(_) => panic!("flags not at top level of valtype"),
  563|      0|        Value::Variant(_) => panic!("flags not at top level of valtype"),
  564|      0|        Value::Enum(_) => panic!("flags not at top level of valtype"),
  565|      2|        Value::Option(vt) => {
  566|      2|            let bodyid = format_ident!("{}_body", id);
  567|      2|            let retid = format_ident!("{}_ret", id);
  568|      2|            let vtun = emit_hl_marshal_value(s, bodyid.clone(), vt);
  569|      2|            quote! {
  570|      2|                match #id {
  571|      2|                    ::core::option::Option::Some(#bodyid) => {
  572|      2|                        let mut #retid = alloc::vec::Vec::from(u8::to_ne_bytes(1));
  573|      2|                        #retid.extend({ #vtun });
  574|      2|                        #retid
  575|      2|                    },
  576|      2|                    ::core::option::Option::None => alloc::vec::Vec::from(u8::to_ne_bytes(0))
  577|      2|                }
  578|      2|            }
  579|       |        }
  580|      2|        Value::Result(vt1, vt2) => {
  581|      2|            let bodyid = format_ident!("{}_body", id);
  582|      2|            let retid = format_ident!("{}_ret", id);
  583|      2|            let vtun1 = if let Some(ref vt1) = **vt1 {
  584|      2|                let vtun = emit_hl_marshal_value(s, bodyid.clone(), vt1);
  585|      2|                quote! { #retid.extend({ #vtun }); }
  586|       |            } else {
  587|      0|                quote! {}
  588|       |            };
  589|      2|            let vtun2 = if let Some(ref vt2) = **vt2 {
  590|      2|                let vtun = emit_hl_marshal_value(s, bodyid.clone(), vt2);
  591|      2|                quote! { #retid.extend({ #vtun }); }
  592|       |            } else {
  593|      0|                quote! {}
  594|       |            };
  595|      2|            quote! {
  596|      2|                match #id {
  597|      2|                    ::core::result::Result::Ok(#bodyid) => {
  598|      2|                        let mut #retid = alloc::vec::Vec::from(u8::to_ne_bytes(0));
  599|      2|                        #vtun1
  600|      2|                        #retid
  601|      2|                    },
  602|      2|                    ::core::result::Result::Err(#bodyid) => {
  603|      2|                        let mut #retid = alloc::vec::Vec::from(u8::to_ne_bytes(1));
  604|      2|                        #vtun2
  605|      2|                        #retid
  606|      2|                    },
  607|      2|                }
  608|      2|            }
  609|       |        }
  610|      2|        Value::Own(ht) => {
  611|      2|            let vi = resolve_handleable_to_resource(s, ht);
  612|      2|            log::debug!("resolved ht to r (3) {:?} {:?}", ht, vi);
                                      ^0
  613|      2|            if s.is_guest {
  614|      0|                let call = if s.is_wasmtime_guest {
  615|      0|                    quote! { () }
  616|       |                } else {
  617|      0|                    quote! {}
  618|       |                };
  619|      0|                quote! {
  620|      0|                    alloc::vec::Vec::from(u32::to_ne_bytes(#id.rep #call))
  621|      0|                }
  622|       |            } else {
  623|      2|                let rid = format_ident!("resource{}", vi);
  624|      2|                quote! {
  625|      2|                    let i = rts.#rid.len();
  626|      2|                    rts.#rid.push_back(::hyperlight_common::resource::ResourceEntry::give(#id));
  627|      2|                    alloc::vec::Vec::from(u32::to_ne_bytes(i as u32))
  628|      2|                }
  629|       |            }
  630|       |        }
  631|      0|        Value::Borrow(ht) => {
  632|      0|            let vi = resolve_handleable_to_resource(s, ht);
  633|      0|            log::debug!("resolved ht to r (6) {:?} {:?}", ht, vi);
  634|      0|            if s.is_guest {
  635|      0|                let call = if s.is_wasmtime_guest {
  636|      0|                    quote! { () }
  637|       |                } else {
  638|      0|                    quote! {}
  639|       |                };
  640|      0|                quote! {
  641|      0|                    alloc::vec::Vec::from(u32::to_ne_bytes(#id.rep #call))
  642|      0|                }
  643|       |            } else {
  644|      0|                let rid = format_ident!("resource{}", vi);
  645|      0|                quote! {
  646|      0|                    let i = rts.#rid.len();
  647|      0|                    rts.#rid.push_back(::hyperlight_common::resource::ResourceEntry::lend(#id));
  648|      0|                    alloc::vec::Vec::from(u32::to_ne_bytes(i as u32))
  649|      0|                }
  650|       |            }
  651|       |        }
  652|     10|        Value::Var(tv, _) => {
  653|     10|            let Some(Tyvar::Bound(n)) = tv else {
  654|      0|                panic!("impossible tyvar")
  655|       |            };
  656|     10|            let (n, Some(Defined::Value(vt))) = s.resolve_tv(*n) else {
  657|      0|                panic!("unresolvable tyvar (2)");
  658|       |            };
  659|     10|            let vt = vt.clone();
  660|     10|            emit_hl_marshal_toplevel_value(s, id, Tyvar::Bound(n), &vt)
  661|       |        }
  662|       |    }
  663|    127|}
  664|       |
  665|       |/// Emit code to unmarshal a parameter with value type `pt` from a
  666|       |/// slice named by `id`. The resultant token stream will be an
  667|       |/// expression which typechecks at the Rust type (as defined by the
  668|       |/// [`crate::rtypes`] module) of the given value type.
  669|     43|pub fn emit_hl_unmarshal_param(s: &mut State, id: Ident, pt: &Value) -> TokenStream {
  670|     43|    let toks = emit_hl_unmarshal_value(s, id, pt);
  671|     43|    quote! { { #toks }.0 }
  672|     43|}
  673|       |
  674|       |/// Emit code to unmarshal the result of a function with result type
  675|       |/// `rt` from a slice named by `id`. The resultant token stream
  676|       |/// will be an expression which typechecks at the Rust type (as
  677|       |/// defined by the [`crate::rtypes`] module) of the unnamed type of
  678|       |/// the result, or unit if named results are used.
  679|       |///
  680|       |/// Precondition: the result type must only be a named result if there
  681|       |/// are no names in it (i.e. a unit type)
  682|     38|pub fn emit_hl_unmarshal_result(s: &mut State, id: Ident, rt: &etypes::Result<'_>) -> TokenStream {
  683|     38|    match rt {
  684|     37|        Some(vt) => {
  685|     37|            let toks = emit_hl_unmarshal_value(s, id, vt);
  686|     37|            quote! { { #toks }.0 }
  687|       |        }
  688|      1|        None => quote! { () },
  689|       |    }
  690|     38|}
  691|       |
  692|       |/// Emit code to marshal a parameter with value type `pt` from a
  693|       |/// Rust value named by `id`. The resultant token stream will be an
  694|       |/// expression which typechecks as `Vec<u8>`.
  695|     37|pub fn emit_hl_marshal_param(s: &mut State, id: Ident, pt: &Value) -> TokenStream {
  696|     37|    let toks = emit_hl_marshal_value(s, id, pt);
  697|     37|    quote! { { #toks } }
  698|     37|}
  699|       |
  700|       |/// Emit code to marshal the result of a function with result type
  701|       |/// `rt` from a Rust value named by `id`. The resultant token stream
  702|       |/// will be an expression that which typechecks as `Vec<u8>`.
  703|       |///
  704|       |/// Precondition: the result type must only be a named result if there
  705|       |/// are no names in it (a unit type)
  706|     41|pub fn emit_hl_marshal_result(s: &mut State, id: Ident, rt: &etypes::Result) -> TokenStream {
  707|     41|    match rt {
  708|      3|        None => quote! { ::alloc::vec::Vec::new() },
  709|     38|        Some(vt) => {
  710|     38|            let toks = emit_hl_marshal_value(s, id, vt);
  711|     38|            quote! { { #toks } }
  712|       |        }
  713|       |    }
  714|     41|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/host.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |use proc_macro2::{Ident, TokenStream};
   18|       |use quote::{format_ident, quote};
   19|       |
   20|       |use crate::emit::{
   21|       |    FnName, ResourceItemName, State, WitName, kebab_to_exports_name, kebab_to_fn, kebab_to_getter,
   22|       |    kebab_to_imports_name, kebab_to_namespace, kebab_to_type, kebab_to_var, split_wit_name,
   23|       |};
   24|       |use crate::etypes::{Component, ExternDecl, ExternDesc, Instance, Tyvar};
   25|       |use crate::hl::{
   26|       |    emit_fn_hl_name, emit_hl_marshal_param, emit_hl_marshal_result, emit_hl_unmarshal_param,
   27|       |    emit_hl_unmarshal_result,
   28|       |};
   29|       |use crate::{resource, rtypes};
   30|       |
   31|       |/// Emit (via returning) code to be added to an `impl <instance trait>
   32|       |/// for Guest {}` declaration that implements this extern declaration
   33|       |/// in terms of Hyperlight guest calls
   34|     45|fn emit_export_extern_decl<'a, 'b, 'c>(
   35|     45|    s: &'c mut State<'a, 'b>,
   36|     45|    ed: &'c ExternDecl<'b>,
   37|     45|) -> TokenStream {
   38|     45|    match &ed.desc {
   39|      0|        ExternDesc::CoreModule(_) => panic!("core module (im/ex)ports are not supported"),
   40|     38|        ExternDesc::Func(ft) => {
   41|     38|            match kebab_to_fn(ed.kebab_name) {
   42|     38|                FnName::Plain(n) => {
   43|     38|                    let param_decls = ft
   44|     38|                        .params
   45|     38|                        .iter()
   46|     38|                        .map(|p| rtypes::emit_func_param(s, p))
                                               ^37
   47|     38|                        .collect::<Vec<_>>();
   48|     38|                    let result_decl = rtypes::emit_func_result(s, &ft.result);
   49|     38|                    let hln = emit_fn_hl_name(s, ed.kebab_name);
   50|     38|                    let ret = format_ident!("ret");
   51|     38|                    let marshal = ft
   52|     38|                        .params
   53|     38|                        .iter()
   54|     38|                        .map(|p| emit_hl_marshal_param(s, kebab_to_var(p.name.name), &p.ty))
                                               ^37
   55|     38|                        .collect::<Vec<_>>();
   56|     38|                    let unmarshal = emit_hl_unmarshal_result(s, ret.clone(), &ft.result);
   57|     38|                    quote! {
   58|     38|                        fn #n(&mut self, #(#param_decls),*) -> #result_decl {
   59|     38|                            let #ret = ::hyperlight_host::sandbox::Callable::call::<::std::vec::Vec::<u8>>(&mut self.sb,
   60|     38|                                #hln,
   61|     38|                                (#(#marshal,)*)
   62|     38|                            );
   63|     38|                            let ::std::result::Result::Ok(#ret) = #ret else { panic!("bad return from guest {:?}", #ret) };
   64|     38|                            #[allow(clippy::unused_unit)]
   65|     38|                            #unmarshal
   66|     38|                        }
   67|     38|                    }
   68|       |                }
   69|       |                FnName::Associated(_, _) =>
   70|       |                // this can be fixed when the guest wasm and
   71|       |                // general macros are split
   72|       |                {
   73|      0|                    panic!("guest resources are not currently supported")
   74|       |                }
   75|       |            }
   76|       |        }
   77|       |        ExternDesc::Type(_) => {
   78|       |            // no runtime representation is needed for types
   79|      5|            quote! {}
   80|       |        }
   81|      2|        ExternDesc::Instance(it) => {
   82|      2|            let wn = split_wit_name(ed.kebab_name);
   83|      2|            emit_export_instance(s, wn.clone(), it);
   84|      2|
   85|      2|            let getter = kebab_to_getter(wn.name);
   86|      2|            let tn = kebab_to_type(wn.name);
   87|      2|            quote! {
   88|      2|                type #tn = Self;
   89|      2|                #[allow(refining_impl_trait)]
   90|      2|                fn #getter<'a>(&'a mut self) -> &'a mut Self {
   91|      2|                    self
   92|      2|                }
   93|      2|            }
   94|       |        }
   95|       |        ExternDesc::Component(_) => {
   96|      0|            panic!("nested components not yet supported in rust bindings");
   97|       |        }
   98|       |    }
   99|     45|}
  100|       |
  101|       |/// Emit (via mutating `s`) an `impl <instance trait> for Host {}`
  102|       |/// declaration that implements this exported instance in terms of
  103|       |/// hyperlight guest calls
  104|      2|fn emit_export_instance<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, wn: WitName, it: &'c Instance<'b>) {
  105|      2|    let mut s = s.with_cursor(wn.namespace_idents());
  106|      2|    s.cur_helper_mod = Some(kebab_to_namespace(wn.name));
  107|      2|
  108|      2|    let exports = it
  109|      2|        .exports
  110|      2|        .iter()
  111|     43|        .map(|ed| emit_export_extern_decl(&mut s, ed))
  112|      2|        .collect::<Vec<_>>();
  113|      2|
  114|      2|    let ns = wn.namespace_path();
  115|      2|    let nsi = wn.namespace_idents();
  116|      2|    let trait_name = kebab_to_type(wn.name);
  117|      2|    let r#trait = s.r#trait(&nsi, trait_name.clone());
  118|      2|    let tvs = r#trait
  119|      2|        .tvs
  120|      2|        .iter()
  121|      2|        .map(|(_, (tv, _))| tv.unwrap())
                                          ^0
  122|      2|        .collect::<Vec<_>>();
  123|      2|    let tvs = tvs
  124|      2|        .iter()
  125|      2|        .map(|tv| rtypes::emit_var_ref(&mut s, &Tyvar::Bound(*tv)))
                                ^0
  126|      2|        .collect::<Vec<_>>();
  127|      2|    let (root_ns, root_base_name) = s.root_component_name.unwrap();
  128|      2|    let wrapper_name = kebab_to_wrapper_name(root_base_name);
  129|      2|    let imports_name = kebab_to_imports_name(root_base_name);
  130|      2|    s.root_mod.items.extend(quote! {
  131|      2|        impl<I: #root_ns::#imports_name, S: ::hyperlight_host::sandbox::Callable> #ns::#trait_name <#(#tvs),*> for #wrapper_name<I, S> {
  132|      2|            #(#exports)*
  133|      2|        }
  134|      2|    });
  135|      2|}
  136|       |
  137|       |/// Keep track of how to get the portion of the state that corresponds
  138|       |/// to the instance that we are presently emitting
  139|       |#[derive(Clone)]
  140|       |struct SelfInfo {
  141|       |    orig_id: Ident,
  142|       |    type_id: Vec<Ident>,
  143|       |    outer_id: Ident,
  144|       |    inner_preamble: TokenStream,
  145|       |    inner_id: Ident,
  146|       |}
  147|       |impl SelfInfo {
  148|      2|    fn new(orig_id: Ident) -> Self {
  149|      2|        let outer_id = format_ident!("captured_{}", orig_id);
  150|      2|        let inner_id = format_ident!("slf");
  151|      2|        SelfInfo {
  152|      2|            orig_id,
  153|      2|            type_id: vec![format_ident!("I")],
  154|      2|            inner_preamble: quote! {
  155|      2|                let mut #inner_id = #outer_id.lock().unwrap();
  156|      2|                let mut #inner_id = ::std::ops::DerefMut::deref_mut(&mut #inner_id);
  157|      2|            },
  158|      2|            outer_id,
  159|      2|            inner_id,
  160|      2|        }
  161|      2|    }
  162|       |    /// Adjust a [`SelfInfo`] to get the portion of the state for the
  163|       |    /// current instance via calling the given getter
  164|      2|    fn with_getter(&self, tp: TokenStream, type_name: Ident, getter: Ident) -> Self {
  165|      2|        let mut toks = self.inner_preamble.clone();
  166|      2|        let id = self.inner_id.clone();
  167|      2|        let mut type_id = self.type_id.clone();
  168|      2|        toks.extend(quote! {
  169|      2|            let mut #id = #tp::#getter(::std::borrow::BorrowMut::<#(#type_id)::*>::borrow_mut(&mut #id));
  170|      2|        });
  171|      2|        type_id.push(type_name);
  172|      2|        SelfInfo {
  173|      2|            orig_id: self.orig_id.clone(),
  174|      2|            type_id,
  175|      2|            outer_id: self.outer_id.clone(),
  176|      2|            inner_preamble: toks,
  177|      2|            inner_id: id,
  178|      2|        }
  179|      2|    }
  180|       |}
  181|       |
  182|       |/// Emit (via returning) code to register this particular extern definition with
  183|       |/// Hyperlight as a host function
  184|       |///
  185|       |/// - `get_self`: a [`SelfInfo`] that details how to get from the root
  186|       |///   component implementation's state to the state for the
  187|       |///   implementation of this instance.
  188|     49|fn emit_import_extern_decl<'a, 'b, 'c>(
  189|     49|    s: &'c mut State<'a, 'b>,
  190|     49|    get_self: SelfInfo,
  191|     49|    ed: &'c ExternDecl<'b>,
  192|     49|) -> TokenStream {
  193|     49|    match &ed.desc {
  194|      0|        ExternDesc::CoreModule(_) => panic!("core module (im/ex)ports are not supported"),
  195|     41|        ExternDesc::Func(ft) => {
  196|     41|            let hln = emit_fn_hl_name(s, ed.kebab_name);
  197|     41|            log::debug!("providing host function {}", hln);
                                      ^0
  198|     41|            let (pds, pus) = ft
  199|     41|                .params
  200|     41|                .iter()
  201|     43|                .map(|p| {
  202|     43|                    let id = kebab_to_var(p.name.name);
  203|     43|                    (
  204|     43|                        quote! { #id: ::std::vec::Vec<u8> },
  205|     43|                        emit_hl_unmarshal_param(s, id, &p.ty),
  206|     43|                    )
  207|     43|                })
  208|     41|                .unzip::<_, _, Vec<_>, Vec<_>>();
  209|     41|            let tp = s.cur_trait_path();
  210|     41|            let callname = match kebab_to_fn(ed.kebab_name) {
  211|     39|                FnName::Plain(n) => quote! { #tp::#n },
  212|      2|                FnName::Associated(r, m) => {
  213|      2|                    let hp = s.helper_path();
  214|      2|                    match m {
  215|      1|                        ResourceItemName::Constructor => quote! { #hp #r::new },
  216|      1|                        ResourceItemName::Method(mn) => quote! { #hp #r::#mn },
  217|      0|                        ResourceItemName::Static(mn) => quote! { #hp #r::#mn },
  218|       |                    }
  219|       |                }
  220|       |            };
  221|       |            let SelfInfo {
  222|     41|                orig_id,
  223|     41|                type_id,
  224|     41|                outer_id,
  225|     41|                inner_preamble,
  226|     41|                inner_id,
  227|     41|            } = get_self;
  228|     41|            let ret = format_ident!("ret");
  229|     41|            let marshal_result = emit_hl_marshal_result(s, ret.clone(), &ft.result);
  230|     41|            quote! {
  231|     41|                let #outer_id = #orig_id.clone();
  232|     41|                let captured_rts = rts.clone();
  233|     41|                sb.register_host_function(#hln, move |#(#pds),*| {
  234|     41|                    let mut rts = captured_rts.lock().unwrap();
  235|     41|                    #inner_preamble
  236|     41|                    let #ret = #callname(
  237|     41|                        ::std::borrow::BorrowMut::<#(#type_id)::*>::borrow_mut(
  238|     41|                            &mut #inner_id
  239|     41|                        ),
  240|     41|                        #(#pus),*
  241|     41|                    );
  242|     41|                    Ok(#marshal_result)
  243|     41|                })
  244|     41|                .unwrap();
  245|     41|            }
  246|       |        }
  247|       |        ExternDesc::Type(_) => {
  248|       |            // no runtime representation is needed for types
  249|      6|            quote! {}
  250|       |        }
  251|      2|        ExternDesc::Instance(it) => {
  252|      2|            let mut s = s.clone();
  253|      2|            let wn = split_wit_name(ed.kebab_name);
  254|      2|            let type_name = kebab_to_type(wn.name);
  255|      2|            let getter = kebab_to_getter(wn.name);
  256|      2|            let tp = s.cur_trait_path();
  257|      2|            let get_self = get_self.with_getter(tp, type_name, getter); //quote! { #get_self let mut slf = &mut #tp::#getter(&mut *slf); };
  258|      2|            emit_import_instance(&mut s, get_self, wn.clone(), it)
  259|       |        }
  260|       |        ExternDesc::Component(_) => {
  261|      0|            panic!("nested components not yet supported in rust bindings");
  262|       |        }
  263|       |    }
  264|     49|}
  265|       |
  266|       |/// Emit (via returning) code to register each export of the given
  267|       |/// instance with Hyperlight as a host function.
  268|       |///
  269|       |/// - `get_self`: a [`SelfInfo`] that details how to get from the root
  270|       |///   component implementation's state to the state for the
  271|       |///   implementation of this instance. This should already have been
  272|       |///   updated for this instance by the caller!
  273|      2|fn emit_import_instance<'a, 'b, 'c>(
  274|      2|    s: &'c mut State<'a, 'b>,
  275|      2|    get_self: SelfInfo,
  276|      2|    wn: WitName,
  277|      2|    it: &'c Instance<'b>,
  278|      2|) -> TokenStream {
  279|      2|    let mut s = s.with_cursor(wn.namespace_idents());
  280|      2|    s.cur_helper_mod = Some(kebab_to_namespace(wn.name));
  281|      2|    s.cur_trait = Some(kebab_to_type(wn.name));
  282|      2|
  283|      2|    let imports = it
  284|      2|        .exports
  285|      2|        .iter()
  286|     47|        .map(|ed| emit_import_extern_decl(&mut s, get_self.clone(), ed))
  287|      2|        .collect::<Vec<_>>();
  288|      2|
  289|      2|    quote! { #(#imports)* }
  290|      2|}
  291|       |
  292|       |/// From a kebab name for a Component, derive something suitable for
  293|       |/// use as the name of the wrapper struct that will implement its
  294|       |/// exports in terms of guest function calls.
  295|      3|fn kebab_to_wrapper_name(trait_name: &str) -> Ident {
  296|      3|    format_ident!("{}Sandbox", kebab_to_type(trait_name))
  297|      3|}
  298|       |
  299|       |/// Emit (via mutating `s`):
  300|       |/// - a resource table for each resource exported by this component
  301|       |/// - a wrapper type encapsulating a sandbox and a wrapper table that
  302|       |///   implements the relevant export trait
  303|       |/// - an implementation of the component trait itself for Hyperlight's
  304|       |///   `UninitializedSandbox` that makes it easy to instantiate
  305|      1|fn emit_component<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, wn: WitName, ct: &'c Component<'b>) {
  306|      1|    let mut s = s.with_cursor(wn.namespace_idents());
  307|      1|    let ns = wn.namespace_path();
  308|      1|    let r#trait = kebab_to_type(wn.name);
  309|      1|    let import_trait = kebab_to_imports_name(wn.name);
  310|      1|    let export_trait = kebab_to_exports_name(wn.name);
  311|      1|    let wrapper_name = kebab_to_wrapper_name(wn.name);
  312|      1|    let import_id = format_ident!("imports");
  313|      1|
  314|      1|    let rtsid = format_ident!("{}Resources", r#trait);
  315|      1|    s.import_param_var = Some(format_ident!("I"));
  316|      1|    resource::emit_tables(
  317|      1|        &mut s,
  318|      1|        rtsid.clone(),
  319|      1|        quote! { #ns::#import_trait },
  320|      1|        None,
  321|      1|        false,
  322|      1|    );
  323|      1|
  324|      1|    s.var_offset = ct.instance.evars.len();
  325|      1|    s.cur_trait = Some(import_trait.clone());
  326|      1|    let imports = ct
  327|      1|        .imports
  328|      1|        .iter()
  329|      2|        .map(|ed| emit_import_extern_decl(&mut s, SelfInfo::new(import_id.clone()), ed))
  330|      1|        .collect::<Vec<_>>();
  331|      1|    s.var_offset = 0;
  332|      1|
  333|      1|    s.root_component_name = Some((ns.clone(), wn.name));
  334|      1|    s.cur_trait = Some(export_trait.clone());
  335|      1|    s.import_param_var = Some(format_ident!("I"));
  336|      1|    let exports = ct
  337|      1|        .instance
  338|      1|        .unqualified
  339|      1|        .exports
  340|      1|        .iter()
  341|      2|        .map(|ed| emit_export_extern_decl(&mut s, ed))
  342|      1|        .collect::<Vec<_>>();
  343|      1|
  344|      1|    s.root_mod.items.extend(quote! {
  345|      1|        pub struct #wrapper_name<T: #ns::#import_trait, S: ::hyperlight_host::sandbox::Callable> {
  346|      1|            pub(crate) sb: S,
  347|      1|            pub(crate) rt: ::std::sync::Arc<::std::sync::Mutex<#rtsid<T>>>,
  348|      1|        }
  349|      1|        pub(crate) fn register_host_functions<I: #ns::#import_trait + ::std::marker::Send + 'static, S: ::hyperlight_host::func::Registerable>(sb: &mut S, i: I) -> ::std::sync::Arc<::std::sync::Mutex<#rtsid<I>>> {
  350|      1|            let rts = ::std::sync::Arc::new(::std::sync::Mutex::new(#rtsid::new()));
  351|      1|            let #import_id = ::std::sync::Arc::new(::std::sync::Mutex::new(i));
  352|      1|            #(#imports)*
  353|      1|            rts
  354|      1|        }
  355|      1|        impl<I: #ns::#import_trait + ::std::marker::Send, S: ::hyperlight_host::sandbox::Callable> #ns::#export_trait<I> for #wrapper_name<I, S> {
  356|      1|            #(#exports)*
  357|      1|        }
  358|      1|        impl #ns::#r#trait for ::hyperlight_host::sandbox::UninitializedSandbox {
  359|      1|            type Exports<I: #ns::#import_trait + ::std::marker::Send> = #wrapper_name<I, ::hyperlight_host::sandbox::initialized_multi_use::MultiUseSandbox>;
  360|      1|            fn instantiate<I: #ns::#import_trait + ::std::marker::Send + 'static>(mut self, i: I) -> Self::Exports<I> {
  361|      1|                let rts = register_host_functions(&mut self, i);
  362|      1|                let sb = self.evolve().unwrap();
  363|      1|                #wrapper_name {
  364|      1|                    sb,
  365|      1|                    rt: rts,
  366|      1|                }
  367|      1|            }
  368|      1|        }
  369|      1|    });
  370|      1|}
  371|       |
  372|       |/// See [`emit_component`]
  373|      1|pub fn emit_toplevel<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, n: &str, ct: &'c Component<'b>) {
  374|      1|    s.is_impl = true;
  375|      1|    log::debug!("\n\n=== starting host emit ===\n");
                              ^0
  376|      1|    let wn = split_wit_name(n);
  377|      1|    emit_component(s, wn, ct)
  378|      1|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/resource.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |use proc_macro2::{Ident, TokenStream};
   18|       |use quote::{format_ident, quote};
   19|       |
   20|       |use crate::emit::State;
   21|       |use crate::etypes::{TypeBound, Tyvar};
   22|       |use crate::rtypes::emit_var_ref;
   23|       |
   24|       |/// Emit a structure definition for a resource table that keeps track
   25|       |/// of resources lent/borrowed/given/taken to/from the other side of
   26|       |/// the Hyperlight boundary.
   27|       |/// - `rtsid`: The name of the struct to create
   28|       |/// - `bound`: a bound to be used for a phantom type variable that
   29|       |///   records the fact that these resource tables are only valid for a
   30|       |///   component that has been instantiated with a particular
   31|       |///   implementation of its imports
   32|       |/// - `sv`: optionally a bound to be used for a phantom type variable
   33|       |///   that records the fact that these resource tables are only valid
   34|       |///   for a particular implementation of a component
   35|      1|pub fn emit_tables<'a, 'b, 'c>(
   36|      1|    s: &'c mut State<'a, 'b>,
   37|      1|    rtsid: Ident,
   38|      1|    bound: TokenStream,
   39|      1|    sv: Option<TokenStream>,
   40|      1|    is_guest: bool,
   41|      1|) {
   42|      1|    let vs = s.bound_vars.clone();
   43|      1|    let (fields, inits) = vs
   44|      1|        .iter()
   45|      1|        .enumerate()
   46|     11|        .map(|(i, v)| {
   47|     11|            let field_name = format_ident!("resource{}", i);
   48|     11|            let alloc_ns = if s.is_guest {
   49|      0|                quote! { ::alloc }
   50|       |            } else {
   51|     11|                quote! { ::std }
   52|       |            };
   53|     11|            match v.bound {
   54|     10|                TypeBound::Eq(_) => (quote! { #field_name: () }, quote! { #field_name: () }),
   55|       |                TypeBound::SubResource => {
   56|      1|                    if v.origin.is_imported() ^ is_guest {
   57|      1|                        let t = emit_var_ref(s, &Tyvar::Bound(i as u32));
   58|      1|                        (
   59|      1|                            quote! {
   60|      1|                                #field_name: #alloc_ns::collections::VecDeque<
   61|      1|                                ::hyperlight_common::resource::ResourceEntry<#t>
   62|      1|                                >
   63|      1|                            },
   64|      1|                            quote! { #field_name: #alloc_ns::collections::VecDeque::new() },
   65|      1|                        )
   66|       |                    } else {
   67|       |                        // we don't need to keep track of anything for
   68|       |                        // resources owned by the other side
   69|      0|                        (
   70|      0|                            quote! {
   71|      0|                                #field_name: ()
   72|      0|                            },
   73|      0|                            quote! { #field_name: () },
   74|      0|                        )
   75|       |                    }
   76|       |                }
   77|       |            }
   78|     11|        })
   79|      1|        .unzip::<_, _, Vec<_>, Vec<_>>();
   80|      1|    let (sv, svs, sphantom, sphantominit) = if let Some(sv) = sv {
                                                                      ^0
   81|      0|        (
   82|      0|            quote! { , S: #sv },
   83|      0|            quote! { , S },
   84|      0|            quote! { _phantomS: ::core::marker::PhantomData<S>, },
   85|      0|            quote! { _phantomS: ::core::marker::PhantomData, },
   86|      0|        )
   87|       |    } else {
   88|      1|        (
   89|      1|            TokenStream::new(),
   90|      1|            TokenStream::new(),
   91|      1|            TokenStream::new(),
   92|      1|            TokenStream::new(),
   93|      1|        )
   94|       |    };
   95|      1|    s.root_mod.items.extend(quote! {
   96|      1|        pub(crate) struct #rtsid<I: #bound #sv> {
   97|      1|            #(#fields,)*
   98|      1|            _phantomI: ::core::marker::PhantomData<I>,
   99|      1|            #sphantom
  100|      1|        }
  101|      1|        impl<I: #bound #sv> #rtsid<I #svs> {
  102|      1|            fn new() -> Self {
  103|      1|                #rtsid {
  104|      1|                    #(#inits,)*
  105|      1|                    _phantomI: ::core::marker::PhantomData,
  106|      1|                    #sphantominit
  107|      1|                }
  108|      1|            }
  109|      1|        }
  110|      1|    });
  111|      1|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/rtypes.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! The Rust representation of a component type (etype)
   18|       |
   19|       |use std::collections::{BTreeMap, BTreeSet, VecDeque};
   20|       |use std::vec::Vec;
   21|       |
   22|       |use proc_macro2::TokenStream;
   23|       |use quote::{format_ident, quote};
   24|       |use syn::Ident;
   25|       |
   26|       |use crate::emit::{
   27|       |    FnName, ResourceItemName, State, WitName, kebab_to_cons, kebab_to_exports_name, kebab_to_fn,
   28|       |    kebab_to_getter, kebab_to_imports_name, kebab_to_namespace, kebab_to_type, kebab_to_var,
   29|       |    split_wit_name,
   30|       |};
   31|       |use crate::etypes::{
   32|       |    self, Component, Defined, ExternDecl, ExternDesc, Func, Handleable, ImportExport, Instance,
   33|       |    Param, TypeBound, Tyvar, Value,
   34|       |};
   35|       |
   36|       |/// When referring to an instance or resource trait, emit a token
   37|       |/// stream that instantiates any types it is parametrized by with our
   38|       |/// own best understanding of how to name the relevant type variables
   39|      5|fn emit_tvis(s: &mut State, tvs: Vec<u32>) -> TokenStream {
   40|      5|    let tvs = tvs
   41|      5|        .iter()
   42|      5|        .map(|tv| emit_var_ref(s, &Tyvar::Bound(*tv)))
                                ^0
   43|      5|        .collect::<Vec<_>>();
   44|      5|    if !tvs.is_empty() {
   45|      0|        quote! { <#(#tvs),*> }
   46|       |    } else {
   47|      5|        TokenStream::new()
   48|       |    }
   49|      5|}
   50|       |
   51|       |/// Emit a token stream that references the type of a particular resource
   52|       |///
   53|       |/// - `n`: the absolute index (i.e. ignoring [`State::var_offset`]) of
   54|       |///   the component tyvar being referenced
   55|       |/// - `path`: the origin path between the module where we are and the
   56|       |///   module where the resource is defined.  The existence of this
   57|       |///   path implies that the var is "locally defined".
   58|      4|fn emit_resource_ref(s: &mut State, n: u32, path: Vec<ImportExport>) -> TokenStream {
   59|      4|    // todo: when the guest codegen is split into generic and wasm,
   60|      4|    // this can go away, since an appropriate impl for the imports
   61|      4|    // trait will be there
   62|      4|    if s.is_guest && s.is_impl {
                                   ^0
   63|       |        // Morally, this should check that the var is imported, but
   64|       |        // that information is gone by now (in the common prefix of
   65|       |        // the path that was chopped off), and we won't support
   66|       |        // resources exported from the guest until this whole special
   67|       |        // case is gone, so ignore it.
   68|      0|        let id = format_ident!("HostResource{}", n);
   69|      0|        return quote! { #id };
   70|      4|    }
   71|      4|    // There is always at least one element in the path, which names
   72|      4|    // the thing we are referring to
   73|      4|    let rtrait = kebab_to_type(path[path.len() - 1].name());
   74|      4|
   75|      4|    // Deal specially with being in the local instance, where there is
   76|      4|    // no instance type & so it is not easy to resolve the
   77|      4|    // path-from-the-root to the resource type trait in question
   78|      4|    if path.len() == 1 {
   79|      3|        let helper = s.cur_helper_mod.clone().unwrap();
   80|      3|        let rtrait = kebab_to_type(path[0].name());
   81|      3|        let t = s.resolve_trait_immut(false, &[helper.clone(), rtrait.clone()]);
   82|      3|        let tvis = emit_tvis(s, t.tv_idxs());
   83|      3|        let mut sv = quote! { Self };
   84|      3|        if let Some(s) = &s.self_param_var {
                                  ^0
   85|      0|            sv = quote! { #s };
   86|      3|        };
   87|      3|        return quote! { <#sv as #helper::#rtrait #tvis>::T };
   88|      1|    };
   89|      1|
   90|      1|    // Generally speaking, the structure that we expect to see in
   91|      1|    // `path` ends in an instance that exports the resource type,
   92|      1|    // followed by the resource type itself. We locate the resource
   93|      1|    // trait by using that final instance name directly; any other
   94|      1|    // names are just used to get to the type that implements it
   95|      1|    let instance = path[path.len() - 2].name();
   96|      1|    let iwn = split_wit_name(instance);
   97|      1|    let extras = path[0..path.len() - 2]
   98|      1|        .iter()
   99|      1|        .map(|p| {
  100|      0|            let wn = split_wit_name(p.name());
  101|      0|            kebab_to_type(wn.name)
  102|      1|        })
  103|      1|        .collect::<Vec<_>>();
  104|      1|    let extras = quote! { #(#extras::)* };
  105|      1|    let rp = s.root_path();
  106|      1|    let tns = iwn.namespace_path();
  107|      1|    let instance_mod = kebab_to_namespace(iwn.name);
  108|      1|    let instance_type = kebab_to_type(iwn.name);
  109|      1|    let mut sv = quote! { Self };
  110|      1|    if path[path.len() - 2].imported() {
  111|      1|        if let Some(iv) = &s.import_param_var {
  112|      1|            sv = quote! { #iv }
  113|      0|        };
  114|      0|    } else if let Some(s) = &s.self_param_var {
  115|      0|        sv = quote! { #s }
  116|      0|    };
  117|      1|    let mut trait_path = Vec::new();
  118|      1|    trait_path.extend(iwn.namespace_idents());
  119|      1|    trait_path.push(instance_mod.clone());
  120|      1|    trait_path.push(rtrait.clone());
  121|      1|    let t = s.resolve_trait_immut(true, &trait_path);
  122|      1|    let tvis = emit_tvis(s, t.tv_idxs());
  123|      1|    quote! { <#sv::#extras #instance_type as #rp #tns::#instance_mod::#rtrait #tvis>::T }
  124|      4|}
  125|       |
  126|       |/// Try to find a way to refer to the given type variable from the
  127|       |/// current module/trait. If this fails, the type must be coming from
  128|       |/// a sibling package, so we will have to emit a parametrization that
  129|       |/// the root (or at least someone higher up the tree) can instantiate.
  130|       |/// - `n`: the absolute index (i.e. ignoring [`State::var_offset`]) of
  131|       |///   the component tyvar being referenced
  132|     45|fn try_find_local_var_id(
  133|     45|    s: &mut State,
  134|     45|    // this should be an absolute var number (no noff)
  135|     45|    n: u32,
  136|     45|) -> Option<TokenStream> {
  137|     45|    if let Some((path, bound)) = s.is_noff_var_local(n) {
  138|     45|        let var_is_helper = match bound {
  139|     40|            TypeBound::Eq(_) => true,
  140|      5|            TypeBound::SubResource => false,
  141|       |        };
  142|     45|        if !var_is_helper {
  143|       |            // it is a resource type
  144|      5|            if s.is_helper {
  145|       |                // but we're in that resource type, so that's ok
  146|      1|                if path.len() == 1 && s.cur_trait == Some(kebab_to_type(path[0].name())) {
  147|      1|                    return Some(quote! { Self::T });
  148|      0|                }
  149|      0|                // otherwise, there is no way to reference that from here
  150|      0|                return None;
  151|       |            } else {
  152|      4|                let mut path_strs = vec!["".to_string(); path.len()];
  153|      5|                for (i, p) in path.iter().enumerate() {
                                            ^4
  154|      5|                    path_strs[i] = p.name().to_string();
  155|      5|                }
  156|      4|                let path = path
  157|      4|                    .into_iter()
  158|      4|                    .enumerate()
  159|      5|                    .map(|(i, p)| match p {
  160|      1|                        ImportExport::Import(_) => ImportExport::Import(&path_strs[i]),
  161|      4|                        ImportExport::Export(_) => ImportExport::Export(&path_strs[i]),
  162|      5|                    })
  163|      4|                    .collect::<Vec<_>>();
  164|      4|                return Some(emit_resource_ref(s, n, path));
  165|       |            }
  166|     40|        }
  167|     40|        log::debug!("path is {:?}\n", path);
                                  ^0
  168|     40|        let mut path = path.iter().rev();
  169|     40|        let name = kebab_to_type(path.next().unwrap().name());
  170|     40|        let owner = path.next();
  171|     40|        if let Some(owner) = owner {
                                  ^30
  172|       |            // if we have an instance type, use it
  173|     30|            let wn = split_wit_name(owner.name());
  174|     30|            let rp = s.root_path();
  175|     30|            let tns = wn.namespace_path();
  176|     30|            let helper = kebab_to_namespace(wn.name);
  177|     30|            Some(quote! { #rp #tns::#helper::#name })
  178|       |        } else {
  179|     10|            let hp = s.helper_path();
  180|     10|            Some(quote! { #hp #name })
  181|       |        }
  182|       |    } else {
  183|      0|        None
  184|       |    }
  185|     45|}
  186|       |
  187|       |/// Emit a token stream that references the given type variable in a
  188|       |/// type context, either directly if it is locally defined or by
  189|       |/// adding a parameter to the current type/trait/etc if necessary.
  190|       |/// - `tv`: the variable to reference
  191|       |///
  192|       |/// Precondition: `tv` must be a [`Tyvar::Bound`] tyvar
  193|     25|pub fn emit_var_ref(s: &mut State, tv: &Tyvar) -> TokenStream {
  194|     25|    let Tyvar::Bound(n) = tv else {
  195|      0|        panic!("free tyvar in rust emit")
  196|       |    };
  197|     25|    emit_var_ref_noff(s, n + s.var_offset as u32, false)
  198|     25|}
  199|       |/// Emit a token stream that references the given type variable in a
  200|       |/// value context (e.g. a constructor), either directly if it is
  201|       |/// locally defined or by adding a parameter to the current
  202|       |/// type/trait/etc if necessary.
  203|       |/// - `tv`: the variable to reference
  204|       |///
  205|       |/// Precondition: `tv` must be a [`Tyvar::Bound`] tyvar
  206|     20|pub fn emit_var_ref_value(s: &mut State, tv: &Tyvar) -> TokenStream {
  207|     20|    let Tyvar::Bound(n) = tv else {
  208|      0|        panic!("free tyvar in rust emit")
  209|       |    };
  210|     20|    emit_var_ref_noff(s, n + s.var_offset as u32, true)
  211|     20|}
  212|       |/// Emit a token stream that references the given bound type variable,
  213|       |/// either directly if it is locally defined or by adding a parameter
  214|       |/// to the current type/trait/etc if necessary.
  215|       |/// - `n`: the absolute index (i.e. ignoring [`State::var_offset`]) of
  216|       |///   the bound variable being referenced
  217|       |/// - `is_value`: whether this is a value (e.g. constructor) or type context.
  218|     45|pub fn emit_var_ref_noff(s: &mut State, n: u32, is_value: bool) -> TokenStream {
  219|     45|    log::debug!("var_ref {:?} {:?}", &s.bound_vars[n as usize], s.origin);
                              ^0
  220|       |    // if the variable was defined locally, try to reference it directly
  221|     45|    let id = try_find_local_var_id(s, n);
  222|     45|    let id = match id {
  223|     45|        Some(id) => {
  224|     45|            // if we are referencing the local one, we need to give it
  225|     45|            // the variables it wants
  226|     45|            let vs = s.get_noff_var_refs(n);
  227|     45|            let vs = vs
  228|     45|                .iter()
  229|     45|                .map(|n| emit_var_ref_noff(s, *n, false))
                                       ^0
  230|     45|                .collect::<Vec<_>>();
  231|     45|            let vs_toks = if !vs.is_empty() {
  232|      0|                if is_value {
  233|      0|                    quote! { ::<#(#vs),*> }
  234|       |                } else {
  235|      0|                    quote! { <#(#vs),*> }
  236|       |                }
  237|       |            } else {
  238|     45|                TokenStream::new()
  239|       |            };
  240|       |
  241|     45|            quote! { #id #vs_toks }
  242|       |        }
  243|       |        None => {
  244|       |            // otherwise, record that whatever type is referencing it needs to
  245|       |            // have it in scope
  246|      0|            s.need_noff_var(n);
  247|      0|            let id = s.noff_var_id(n);
  248|      0|            quote! { #id }
  249|       |        }
  250|       |    };
  251|     45|    quote! { #id }
  252|     45|}
  253|       |
  254|       |/// Format the name of the rust type corresponding to a component
  255|       |/// numeric type.
  256|       |///
  257|       |/// Precondition: `vt` is a numeric type (`S`, `U`, `F`)
  258|    201|pub fn numeric_rtype(vt: &Value) -> (Ident, u8) {
  259|    201|    match vt {
  260|     64|        Value::S(w) => (format_ident!("i{}", w.width()), w.width()),
  261|    105|        Value::U(w) => (format_ident!("u{}", w.width()), w.width()),
  262|     32|        Value::F(w) => (format_ident!("f{}", w.width()), w.width()),
  263|      0|        _ => panic!("numeric_rtype: internal invariant violation"),
  264|       |    }
  265|    201|}
  266|       |
  267|       |/// Emit a Rust type corresponding to a given value type. The
  268|       |/// resultant token stream will parse as a Rust type.
  269|       |///
  270|       |/// Precondition: `vt` is an inline-able value type.
  271|    247|pub fn emit_value(s: &mut State, vt: &Value) -> TokenStream {
  272|     20|    match vt {
  273|      6|        Value::Bool => quote! { bool },
  274|       |        Value::S(_) | Value::U(_) | Value::F(_) => {
  275|     99|            let (id, _) = numeric_rtype(vt);
  276|     99|            quote! { #id }
  277|       |        }
  278|     11|        Value::Char => quote! { char },
  279|     27|        Value::String => quote! { alloc::string::String },
  280|     12|        Value::List(vt) => {
  281|     12|            let vt = emit_value(s, vt);
  282|     12|            quote! { alloc::vec::Vec<#vt> }
  283|       |        }
  284|     56|        Value::FixList(vt, size) => {
  285|     56|            let vt = emit_value(s, vt);
  286|     56|            let size = *size as usize;
  287|     56|            quote! { [#vt; #size] }
  288|       |        }
  289|      0|        Value::Record(_) => panic!("record not at top level of valtype"),
  290|      4|        Value::Tuple(vts) => {
  291|      8|            let vts = vts.iter().map(|vt| emit_value(s, vt)).collect::<Vec<_>>();
  292|      4|            quote! { (#(#vts),*) }
  293|       |        }
  294|      0|        Value::Flags(_) => panic!("flags not at top level of valtype"),
  295|      0|        Value::Variant(_) => panic!("flags not at top level of valtype"),
  296|      0|        Value::Enum(_) => panic!("enum not at top level of valtype"),
  297|      4|        Value::Option(vt) => {
  298|      4|            let vt = emit_value(s, vt);
  299|      4|            quote! { ::core::option::Option<#vt> }
  300|       |        }
  301|      4|        Value::Result(vt1, vt2) => {
  302|      4|            let unit = Value::Tuple(Vec::new());
  303|      4|            let vt1 = emit_value(s, vt1.as_ref().as_ref().unwrap_or(&unit));
  304|      4|            let vt2 = emit_value(s, vt2.as_ref().as_ref().unwrap_or(&unit));
  305|      4|            quote! { ::core::result::Result<#vt1, #vt2> }
  306|       |        }
  307|      3|        Value::Own(ht) => match ht {
  308|      0|            Handleable::Resource(_) => panic!("bare resource in type"),
  309|      3|            Handleable::Var(tv) => {
  310|      3|                if s.is_guest {
  311|      0|                    let wrap = if s.is_wasmtime_guest {
  312|      0|                        |toks| quote! { ::wasmtime::component::Resource<#toks> }
  313|      0|                    } else {
  314|      0|                        |toks| toks
  315|      0|                    };
  316|      0|                    if !s.is_impl {
  317|      0|                        wrap(emit_var_ref(s, tv))
  318|       |                    } else {
  319|      0|                        let n = crate::hl::resolve_handleable_to_resource(s, ht);
  320|      0|                        log::debug!("resolved ht to r (4) {:?} {:?}", ht, n);
  321|      0|                        let id = format_ident!("HostResource{}", n);
  322|      0|                        wrap(quote! { #id })
  323|       |                    }
  324|       |                } else {
  325|      3|                    emit_var_ref(s, tv)
  326|       |                }
  327|       |            }
  328|       |        },
  329|      1|        Value::Borrow(ht) => match ht {
  330|      0|            Handleable::Resource(_) => panic!("bare resource in type"),
  331|      1|            Handleable::Var(tv) => {
  332|      1|                if s.is_guest {
  333|      0|                    let wrap = if s.is_wasmtime_guest {
  334|      0|                        |toks| quote! { ::wasmtime::component::Resource<#toks> }
  335|      0|                    } else {
  336|      0|                        |toks| quote! { &#toks }
  337|      0|                    };
  338|      0|                    if !s.is_impl {
  339|      0|                        wrap(emit_var_ref(s, tv))
  340|       |                    } else {
  341|      0|                        let n = crate::hl::resolve_handleable_to_resource(s, ht);
  342|      0|                        log::debug!("resolved ht to r (5) {:?} {:?}", ht, n);
  343|      0|                        let id = format_ident!("HostResource{}", n);
  344|      0|                        wrap(quote! { #id })
  345|       |                    }
  346|       |                } else {
  347|      1|                    let vr = emit_var_ref(s, tv);
  348|      1|                    quote! { ::hyperlight_common::resource::BorrowedResourceGuard<#vr> }
  349|       |                }
  350|       |            }
  351|       |        },
  352|     20|        Value::Var(Some(tv), _) => emit_var_ref(s, tv),
  353|      0|        Value::Var(None, _) => panic!("value type with recorded but unknown var"),
  354|       |    }
  355|    247|}
  356|       |
  357|       |/// Emit a Rust type corresponding to a given toplevel value type. The
  358|       |/// resultant token stream will parse as a Rust type declaration that
  359|       |/// defines a type named `id`.
  360|      5|fn emit_value_toplevel(s: &mut State, v: Option<u32>, id: Ident, vt: &Value) -> TokenStream {
  361|      5|    let is_wasmtime_guest = s.is_wasmtime_guest;
  362|      5|    match vt {
  363|      1|        Value::Record(rfs) => {
  364|      1|            let (vs, toks) = gather_needed_vars(s, v, |s| {
  365|      1|                let rfs = rfs
  366|      1|                    .iter()
  367|      2|                    .map(|rf| {
  368|      2|                        let orig_name = rf.name.name;
  369|      2|                        let id = kebab_to_var(orig_name);
  370|      2|                        let derives = if s.is_wasmtime_guest {
  371|      0|                            quote! { #[component(name = #orig_name)] }
  372|       |                        } else {
  373|      2|                            TokenStream::new()
  374|       |                        };
  375|      2|                        let ty = emit_value(s, &rf.ty);
  376|      2|                        quote! { #derives pub #id: #ty }
  377|      2|                    })
  378|      1|                    .collect::<Vec<_>>();
  379|      1|                quote! { #(#rfs),* }
  380|      1|            });
  381|      1|            let vs = emit_type_defn_var_list(s, vs);
  382|      1|            let derives = if s.is_wasmtime_guest {
  383|      0|                quote! {
  384|      0|                    #[derive(::wasmtime::component::ComponentType)]
  385|      0|                    #[derive(::wasmtime::component::Lift)]
  386|      0|                    #[derive(::wasmtime::component::Lower)]
  387|      0|                    #[component(record)]
  388|      0|                }
  389|       |            } else {
  390|      1|                TokenStream::new()
  391|       |            };
  392|      1|            quote! {
  393|      1|                #derives
  394|      1|                #[derive(Debug)]
  395|      1|                pub struct #id #vs { #toks }
  396|      1|            }
  397|       |        }
  398|      2|        Value::Flags(ns) => {
  399|      2|            let (vs, toks) = gather_needed_vars(s, v, |_| {
  400|      2|                let ns = ns
  401|      2|                    .iter()
  402|     35|                    .map(|n| {
  403|     35|                        let orig_name = n.name;
  404|     35|                        let id = kebab_to_var(orig_name);
  405|     35|                        quote! { pub #id: bool }
  406|     35|                    })
  407|      2|                    .collect::<Vec<_>>();
  408|      2|                quote! { #(#ns),* }
  409|      2|            });
  410|      2|            let vs = emit_type_defn_var_list(s, vs);
  411|      2|            quote! {
  412|      2|                #[derive(Debug, Clone, PartialEq)]
  413|      2|                pub struct #id #vs { #toks }
  414|      2|            }
  415|       |        }
  416|      1|        Value::Variant(vcs) => {
  417|      1|            let (vs, toks) = gather_needed_vars(s, v, |s| {
  418|      1|                let vcs = vcs
  419|      1|                    .iter()
  420|      3|                    .map(|vc| {
  421|      3|                        let orig_name = vc.name.name;
  422|      3|                        let id = kebab_to_cons(orig_name);
  423|      3|                        let derives = if s.is_wasmtime_guest {
  424|      0|                            quote! { #[component(name = #orig_name)] }
  425|       |                        } else {
  426|      3|                            TokenStream::new()
  427|       |                        };
  428|      3|                        match &vc.ty {
  429|      2|                            Some(ty) => {
  430|      2|                                let ty = emit_value(s, ty);
  431|      2|                                quote! { #derives #id(#ty) }
  432|       |                            }
  433|      1|                            None => quote! { #derives #id },
  434|       |                        }
  435|      3|                    })
  436|      1|                    .collect::<Vec<_>>();
  437|      1|                quote! { #(#vcs),* }
  438|      1|            });
  439|      1|            let vs = emit_type_defn_var_list(s, vs);
  440|      1|            let derives = if s.is_wasmtime_guest {
  441|      0|                quote! {
  442|      0|                    #[derive(::wasmtime::component::ComponentType)]
  443|      0|                    #[derive(::wasmtime::component::Lift)]
  444|      0|                    #[derive(::wasmtime::component::Lower)]
  445|      0|                    #[component(variant)]
  446|      0|                }
  447|       |            } else {
  448|      1|                TokenStream::new()
  449|       |            };
  450|      1|            quote! {
  451|      1|                #derives
  452|      1|                #[derive(Debug)]
  453|      1|                pub enum #id #vs { #toks }
  454|      1|            }
  455|       |        }
  456|      1|        Value::Enum(ns) => {
  457|      1|            let (vs, toks) = gather_needed_vars(s, v, |_| {
  458|      1|                let ns = ns
  459|      1|                    .iter()
  460|      3|                    .map(|n| {
  461|      3|                        let orig_name = n.name;
  462|      3|                        let id = kebab_to_cons(orig_name);
  463|      3|                        let derives = if is_wasmtime_guest {
  464|      0|                            quote! { #[component(name = #orig_name)] }
  465|       |                        } else {
  466|      3|                            TokenStream::new()
  467|       |                        };
  468|      3|                        quote! { #derives #id }
  469|      3|                    })
  470|      1|                    .collect::<Vec<_>>();
  471|      1|                quote! { #(#ns),* }
  472|      1|            });
  473|      1|            let vs = emit_type_defn_var_list(s, vs);
  474|      1|            let derives = if s.is_wasmtime_guest {
  475|      0|                quote! {
  476|      0|                    #[derive(::wasmtime::component::ComponentType)]
  477|      0|                    #[derive(::wasmtime::component::Lift)]
  478|      0|                    #[derive(::wasmtime::component::Lower)]
  479|      0|                    #[component(enum)]
  480|      0|                    #[repr(u8)] // todo: should this always be u8?
  481|      0|                }
  482|       |            } else {
  483|      1|                TokenStream::new()
  484|       |            };
  485|      1|            quote! {
  486|      1|                #derives
  487|      1|                #[derive(Debug, Copy, Clone, PartialEq)]
  488|      1|                pub enum #id #vs { #toks }
  489|      1|            }
  490|       |        }
  491|      0|        _ => emit_type_alias(s, v, id, |s| emit_value(s, vt)),
  492|       |    }
  493|      5|}
  494|       |
  495|       |/// Emit a Rust type corresponding to a defined type. The token stream
  496|       |/// will parse as a Rust type declaration that defines a type named `id`.
  497|       |///
  498|       |/// Precondition: `dt` is not an instance or component, which we
  499|       |/// cannot deal with as first-class at the moment, or a bare resource
  500|       |/// type.
  501|      5|fn emit_defined(s: &mut State, v: Option<u32>, id: Ident, dt: &Defined) -> TokenStream {
  502|      0|    match dt {
  503|       |        // the lack of trait aliases makes emitting a name for an
  504|       |        // instance/component difficult in rust
  505|      0|        Defined::Instance(_) | Defined::Component(_) => TokenStream::new(),
  506|       |        // toplevel vars should have been handled elsewhere
  507|      0|        Defined::Handleable(Handleable::Resource(_)) => panic!("bare resource in type"),
  508|      0|        Defined::Handleable(Handleable::Var(tv)) => {
  509|      0|            emit_type_alias(s, v, id, |s| emit_var_ref(s, tv))
  510|       |        }
  511|      5|        Defined::Value(vt) => emit_value_toplevel(s, v, id, vt),
  512|      0|        Defined::Func(ft) => emit_type_alias(s, v, id, |s| emit_func(s, ft)),
  513|       |    }
  514|      5|}
  515|       |
  516|       |/// Emit a Rust argument declaration, suitable for placing in the
  517|       |/// argument list of a function, for a given component function type
  518|       |/// parameter.
  519|     80|pub fn emit_func_param(s: &mut State, p: &Param) -> TokenStream {
  520|     80|    let name = kebab_to_var(p.name.name);
  521|     80|    let ty = emit_value(s, &p.ty);
  522|     80|    quote! { #name: #ty }
  523|     80|}
  524|       |
  525|       |/// Emit a Rust version of a component function return type.
  526|       |///
  527|       |/// Precondition: the result type must only be a named result if there
  528|       |/// are no names in it (i.e. a unit type)
  529|     79|pub fn emit_func_result(s: &mut State, r: &etypes::Result<'_>) -> TokenStream {
  530|     79|    match r {
  531|     75|        Some(vt) => emit_value(s, vt),
  532|      4|        None => quote! { () },
  533|       |    }
  534|     79|}
  535|       |
  536|       |/// Emit a Rust typeversion of a component function type. This is only
  537|       |/// used for defining certain type aliases of functions, and so it
  538|       |/// truly is a Rust type-level function type, not a value-level
  539|       |/// declaration.
  540|      0|fn emit_func(s: &mut State, ft: &Func) -> TokenStream {
  541|      0|    let params = ft
  542|      0|        .params
  543|      0|        .iter()
  544|      0|        .map(|p| emit_func_param(s, p))
  545|      0|        .collect::<Vec<_>>();
  546|      0|    let result = emit_func_result(s, &ft.result);
  547|      0|    quote! { fn(#(#params),*) -> #result }
  548|      0|}
  549|       |
  550|       |/// Gather the vars that are referenced when running `f`. If `v` is
  551|       |/// [`Some(vn)`], also record this as the set of vars needed by the
  552|       |/// bound tyvar with absolute index `vn`.
  553|      5|fn gather_needed_vars<F: Fn(&mut State) -> TokenStream>(
  554|      5|    s: &mut State,
  555|      5|    v: Option<u32>,
  556|      5|    f: F,
  557|      5|) -> (BTreeSet<u32>, TokenStream) {
  558|      5|    let mut needs_vars = BTreeSet::new();
  559|      5|    let mut sv = s.with_needs_vars(&mut needs_vars);
  560|      5|    let toks = f(&mut sv);
  561|      5|    if let Some(vn) = v {
  562|      5|        sv.record_needs_vars(vn);
  563|      5|    }
                  ^0
  564|      5|    drop(sv);
  565|      5|    (needs_vars, toks)
  566|      5|}
  567|       |/// Emit a Rust type parameter list that can be affixed to a type
  568|       |/// definition, given a set `vs` of the component-level bound tyvars
  569|       |/// that the type references but are not locally-defined.
  570|      5|fn emit_type_defn_var_list(s: &mut State, vs: BTreeSet<u32>) -> TokenStream {
  571|      5|    if vs.is_empty() {
  572|      5|        TokenStream::new()
  573|       |    } else {
  574|      0|        let vs = vs
  575|      0|            .iter()
  576|      0|            .map(|n| {
  577|      0|                if s.is_guest {
  578|      0|                    let t = s.noff_var_id(*n);
  579|      0|                    quote! { #t: 'static }
  580|       |                } else {
  581|      0|                    let t = s.noff_var_id(*n);
  582|      0|                    quote! { #t }
  583|       |                }
  584|      0|            })
  585|      0|            .collect::<Vec<_>>();
  586|      0|        quote! { <#(#vs),*> }
  587|       |    }
  588|      5|}
  589|       |/// Emit a type alias declaration, allowing one to name an anonymous
  590|       |/// Rust type without creating a new nominal type.
  591|       |///
  592|       |/// - `v`: If [`Some(vn)`], the component-level bound tyvar absolute
  593|       |///   index that this declaration corresponds to
  594|       |/// - `id`: The name of the alias to produce
  595|       |/// - `f`: A function which produces a token stream that parses as a
  596|       |///   Rust type, to use as the body of the alias
  597|      0|fn emit_type_alias<F: Fn(&mut State) -> TokenStream>(
  598|      0|    s: &mut State,
  599|      0|    v: Option<u32>,
  600|      0|    id: Ident,
  601|      0|    f: F,
  602|      0|) -> TokenStream {
  603|      0|    let (vs, toks) = gather_needed_vars(s, v, f);
  604|      0|    let vs = emit_type_defn_var_list(s, vs);
  605|      0|    quote! { pub type #id #vs = #toks; }
  606|      0|}
  607|       |
  608|       |/// Emit (via returning) a Rust trait item corresponding to this
  609|       |/// extern decl
  610|     52|fn emit_extern_decl<'a, 'b, 'c>(
  611|     52|    is_export: bool,
  612|     52|    s: &'c mut State<'a, 'b>,
  613|     52|    ed: &'c ExternDecl<'b>,
  614|     52|) -> TokenStream {
  615|     52|    log::debug!("  emitting decl {:?}", ed.kebab_name);
                              ^0
  616|     52|    match &ed.desc {
  617|      0|        ExternDesc::CoreModule(_) => panic!("core module (im/ex)ports are not supported"),
  618|     42|        ExternDesc::Func(ft) => {
  619|     42|            let mut s = s.push_origin(is_export, ed.kebab_name);
  620|     42|            match kebab_to_fn(ed.kebab_name) {
  621|     40|                FnName::Plain(n) => {
  622|     40|                    let params = ft
  623|     40|                        .params
  624|     40|                        .iter()
  625|     40|                        .map(|p| emit_func_param(&mut s, p))
                                               ^39
  626|     40|                        .collect::<Vec<_>>();
  627|     40|                    let result = emit_func_result(&mut s, &ft.result);
  628|     40|                    quote! {
  629|     40|                        fn #n(&mut self, #(#params),*) -> #result;
  630|     40|                    }
  631|       |                }
  632|      2|                FnName::Associated(r, n) => {
  633|      2|                    let mut s = s.helper();
  634|      2|                    s.cur_trait = Some(r.clone());
  635|      2|                    let mut needs_vars = BTreeSet::new();
  636|      2|                    let mut sv = s.with_needs_vars(&mut needs_vars);
  637|      2|                    let params = ft
  638|      2|                        .params
  639|      2|                        .iter()
  640|      4|                        .map(|p| emit_func_param(&mut sv, p))
  641|      2|                        .collect::<Vec<_>>();
  642|      2|                    match n {
  643|       |                        ResourceItemName::Constructor => {
  644|      1|                            sv.cur_trait().items.extend(quote! {
  645|      1|                                fn new(&mut self, #(#params),*) -> Self::T;
  646|      1|                            });
  647|       |                        }
  648|      1|                        ResourceItemName::Method(n) => {
  649|      1|                            let result = emit_func_result(&mut sv, &ft.result);
  650|      1|                            sv.cur_trait().items.extend(quote! {
  651|      1|                                fn #n(&mut self, #(#params),*) -> #result;
  652|      1|                            });
  653|       |                        }
  654|      0|                        ResourceItemName::Static(n) => {
  655|      0|                            let result = emit_func_result(&mut sv, &ft.result);
  656|      0|                            sv.cur_trait().items.extend(quote! {
  657|      0|                                fn #n(&mut self, #(#params),*) -> #result;
  658|      0|                            });
  659|       |                        }
  660|       |                    }
  661|      2|                    for v in needs_vars {
                                      ^0
  662|      0|                        let id = s.noff_var_id(v);
  663|      0|                        s.cur_trait().tvs.insert(id, (Some(v), TokenStream::new()));
  664|      0|                    }
  665|      2|                    quote! {}
  666|       |                }
  667|       |            }
  668|       |        }
  669|      6|        ExternDesc::Type(t) => {
  670|      5|            fn go_defined<'a, 'b, 'c>(
  671|      5|                s: &'c mut State<'a, 'b>,
  672|      5|                ed: &'c ExternDecl<'b>,
  673|      5|                t: &'c Defined<'b>,
  674|      5|                v: Option<u32>,
  675|      5|            ) -> TokenStream {
  676|      5|                let id = kebab_to_type(ed.kebab_name);
  677|      5|                let mut s = s.helper();
  678|      5|
  679|      5|                let t = emit_defined(&mut s, v, id, t);
  680|      5|                s.cur_mod().items.extend(t);
  681|      5|                TokenStream::new()
  682|      5|            }
  683|      6|            let edn: &'b str = ed.kebab_name;
  684|      6|            let mut s: State<'_, 'b> = s.push_origin(is_export, edn);
  685|      6|            if let Some((n, bound)) = s.is_var_defn(t) {
  686|      6|                match bound {
  687|      5|                    TypeBound::Eq(t) => {
  688|      5|                        // ensure that when go_defined() looks up vars
  689|      5|                        // that might occur in the type, they resolve
  690|      5|                        // properly
  691|      5|                        let noff = s.var_offset as u32 + n;
  692|      5|                        s.var_offset += n as usize + 1;
  693|      5|                        go_defined(&mut s, ed, &t, Some(noff))
  694|       |                    }
  695|       |                    TypeBound::SubResource => {
  696|      1|                        let rn = kebab_to_type(ed.kebab_name);
  697|      1|                        s.add_helper_supertrait(rn.clone());
  698|      1|                        let mut s = s.helper();
  699|      1|                        s.cur_trait = Some(rn.clone());
  700|      1|                        s.cur_trait().items.extend(quote! {
  701|      1|                            type T: ::core::marker::Send;
  702|      1|                        });
  703|      1|                        quote! {}
  704|       |                    }
  705|       |                }
  706|       |            } else {
  707|      0|                go_defined(&mut s, ed, t, None)
  708|       |            }
  709|       |        }
  710|      4|        ExternDesc::Instance(it) => {
  711|      4|            let mut s = s.push_origin(is_export, ed.kebab_name);
  712|      4|            let wn = split_wit_name(ed.kebab_name);
  713|      4|            emit_instance(&mut s, wn.clone(), it);
  714|      4|
  715|      4|            let nsids = wn.namespace_idents();
  716|      4|            let repr = s.r#trait(&nsids, kebab_to_type(wn.name));
  717|      4|            let vs = if !repr.tvs.is_empty() {
  718|      0|                let vs = repr.tvs.clone();
  719|      0|                let tvs = vs
  720|      0|                    .iter()
  721|      0|                    .map(|(_, (tv, _))| emit_var_ref(&mut s, &Tyvar::Bound(tv.unwrap())));
  722|      0|                quote! { <#(#tvs),*> }
  723|       |            } else {
  724|      4|                TokenStream::new()
  725|       |            };
  726|       |
  727|      4|            let getter = kebab_to_getter(wn.name);
  728|      4|            let rp = s.root_path();
  729|      4|            let tns = wn.namespace_path();
  730|      4|            let tn = kebab_to_type(wn.name);
  731|      4|            quote! {
  732|      4|                type #tn: #rp #tns::#tn #vs;
  733|      4|                fn #getter(&mut self) -> impl ::core::borrow::BorrowMut<Self::#tn>;
  734|      4|            }
  735|       |        }
  736|       |        ExternDesc::Component(_) => {
  737|      0|            panic!("nested components not yet supported in rust bindings");
  738|       |        }
  739|       |    }
  740|     52|}
  741|       |
  742|       |/// Emit (via mutating `s`) a Rust trait declaration corresponding to
  743|       |/// this instance type
  744|      4|fn emit_instance<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, wn: WitName, it: &'c Instance<'b>) {
  745|      4|    log::debug!("emitting instance {:?}", wn);
                              ^0
  746|      4|    let mut s = s.with_cursor(wn.namespace_idents());
  747|      4|
  748|      4|    let name = kebab_to_type(wn.name);
  749|      4|
  750|      4|    s.cur_helper_mod = Some(kebab_to_namespace(wn.name));
  751|      4|    s.cur_trait = Some(name.clone());
  752|      4|    if !s.cur_trait().items.is_empty() {
  753|       |        // Temporary hack: we have visited this wit:package/instance
  754|       |        // before, so bail out instead of adding duplicates of
  755|       |        // everything. Since we don't really have strong semantic
  756|       |        // guarantees that the exact same contents will be in each
  757|       |        // occurrence of a wit:package/instance (and indeed they may
  758|       |        // well be stripped down to the essentials in each
  759|       |        // occurrence), this is NOT sound, and will need to be
  760|       |        // revisited.  The correct approach here is to change
  761|       |        // emit_extern_decl to create function/resource items in a
  762|       |        // Trait that can be merged properly, instead of directly
  763|       |        // emitting tokens.
  764|      1|        return;
  765|      3|    }
  766|      3|
  767|      3|    let mut needs_vars = BTreeSet::new();
  768|      3|    let mut sv = s.with_needs_vars(&mut needs_vars);
  769|      3|
  770|      3|    let exports = it
  771|      3|        .exports
  772|      3|        .iter()
  773|     48|        .map(|ed| emit_extern_decl(true, &mut sv, ed))
  774|      3|        .collect::<Vec<_>>();
  775|      3|
  776|      3|    // instantiations for the supertraits
  777|      3|
  778|      3|    let mut stvs = BTreeMap::new();
  779|      3|    let _ = sv.cur_trait(); // make sure it exists
  780|      3|    let t = sv.cur_trait_immut();
  781|      3|    for (ti, _) in t.supertraits.iter() {
                       ^1
  782|      1|        let t = sv.resolve_trait_immut(false, ti);
  783|      1|        stvs.insert(ti.clone(), t.tv_idxs());
  784|      1|    }
  785|       |    // hack to make the local-definedness check work properly, since
  786|       |    // it usually should ignore the last origin component
  787|      3|    sv.origin.push(ImportExport::Export("self"));
  788|      3|    let mut stis = BTreeMap::new();
  789|      3|    for (id, tvs) in stvs.into_iter() {
                       ^1
  790|      1|        stis.insert(id, emit_tvis(&mut sv, tvs));
  791|      1|    }
  792|      3|    for (id, ts) in stis.into_iter() {
                       ^1
  793|      1|        sv.cur_trait().supertraits.get_mut(&id).unwrap().extend(ts);
  794|      1|    }
  795|       |
  796|      3|    drop(sv);
  797|      3|    log::debug!("after exports, ncur_needs_vars is {:?}", needs_vars);
                              ^0
  798|      3|    for v in needs_vars {
                      ^0
  799|      0|        let id = s.noff_var_id(v);
  800|      0|        s.cur_trait().tvs.insert(id, (Some(v), TokenStream::new()));
  801|      0|    }
  802|       |
  803|      3|    s.cur_trait().items.extend(quote! { #(#exports)* });
  804|      4|}
  805|       |
  806|       |/// Emit (via mutating `s`) a set of Rust trait declarations
  807|       |/// corresponding to this component. This includes an `Imports` and an
  808|       |/// `Exports` trait, as well as a main trait with an `instantiate()`
  809|       |/// function that maps from an implementer of the imports to an
  810|       |/// implementor of the exports
  811|      1|fn emit_component<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, wn: WitName, ct: &'c Component<'b>) {
  812|      1|    let mut s = s.with_cursor(wn.namespace_idents());
  813|      1|
  814|      1|    let base_name = kebab_to_type(wn.name);
  815|      1|
  816|      1|    s.cur_helper_mod = Some(kebab_to_namespace(wn.name));
  817|      1|
  818|      1|    let import_name = kebab_to_imports_name(wn.name);
  819|      1|    *s.bound_vars = ct
  820|      1|        .uvars
  821|      1|        .iter()
  822|      1|        .rev()
  823|      1|        .map(Clone::clone)
  824|      1|        .collect::<VecDeque<_>>();
  825|      1|    s.cur_trait = Some(import_name.clone());
  826|      1|    let imports = ct
  827|      1|        .imports
  828|      1|        .iter()
  829|      2|        .map(|ed| emit_extern_decl(false, &mut s, ed))
  830|      1|        .collect::<Vec<TokenStream>>();
  831|      1|    s.cur_trait().items.extend(quote! { #(#imports)* });
  832|       |
  833|      1|    s.adjust_vars(ct.instance.evars.len() as u32);
  834|      1|
  835|      1|    s.import_param_var = Some(format_ident!("I"));
  836|      1|
  837|      1|    let export_name = kebab_to_exports_name(wn.name);
  838|      1|    *s.bound_vars = ct
  839|      1|        .instance
  840|      1|        .evars
  841|      1|        .iter()
  842|      1|        .rev()
  843|      1|        .chain(ct.uvars.iter().rev())
  844|      1|        .map(Clone::clone)
  845|      1|        .collect::<VecDeque<_>>();
  846|      1|    s.cur_trait = Some(export_name.clone());
  847|      1|    let exports = ct
  848|      1|        .instance
  849|      1|        .unqualified
  850|      1|        .exports
  851|      1|        .iter()
  852|      2|        .map(|ed| emit_extern_decl(true, &mut s, ed))
  853|      1|        .collect::<Vec<_>>();
  854|      1|    s.cur_trait().tvs.insert(
  855|      1|        format_ident!("I"),
  856|      1|        (None, quote! { #import_name + ::core::marker::Send }),
  857|      1|    );
  858|      1|    s.cur_trait().items.extend(quote! { #(#exports)* });
  859|       |
  860|      1|    s.cur_helper_mod = None;
  861|      1|    s.cur_trait = None;
  862|      1|
  863|      1|    s.cur_mod().items.extend(quote! {
  864|      1|        pub trait #base_name {
  865|      1|            type Exports<I: #import_name + ::core::marker::Send>: #export_name<I>;
  866|      1|            // todo: can/should this 'static bound be avoided?
  867|      1|            // it is important right now because this is closed over in host functions
  868|      1|            fn instantiate<I: #import_name + ::core::marker::Send + 'static>(self, imports: I) -> Self::Exports<I>;
  869|      1|        }
  870|      1|    });
  871|      1|}
  872|       |
  873|       |/// See [`emit_component`]
  874|      1|pub fn emit_toplevel<'a, 'b, 'c>(s: &'c mut State<'a, 'b>, n: &str, ct: &'c Component<'b>) {
  875|      1|    let wn = split_wit_name(n);
  876|      1|    emit_component(s, wn, ct);
  877|      1|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/substitute.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! Capture-avoiding substitution
   18|       |
   19|       |use std::primitive::u32;
   20|       |
   21|       |use crate::etypes::{
   22|       |    BoundedTyvar, Component, Ctx, Defined, ExternDecl, ExternDesc, FreeTyvar, Func, Handleable,
   23|       |    Instance, Param, QualifiedInstance, RecordField, TypeBound, Tyvar, Value, VariantCase,
   24|       |};
   25|       |use crate::tv::ResolvedTyvar;
   26|       |
   27|       |/// A substitution
   28|       |///
   29|       |/// This trait can be implemented by specific structures that have
   30|       |/// specific substitution behavior, which only need to define how the
   31|       |/// act on bound/existential/universal variables. The implemented
   32|       |/// methods on the trait will then allow applying that substitution in
   33|       |/// a capture-avoiding manner to any relevant term.
   34|       |///
   35|       |/// The [`Shiftable`] bound is required because the implementation of
   36|       |/// substitution for components and instances needs to be able to
   37|       |/// shift the substitution in order to make substitution
   38|       |/// capture-avoiding.
   39|       |pub trait Substitution<'a>
   40|       |where
   41|       |    Self: Shiftable<'a>,
   42|       |{
   43|       |    /// Some, but not all, substitutions are fallible (i.e. may reveal
   44|       |    /// latent misbehaviour in the type they are being applied to), so
   45|       |    /// any given [`Substitution`] can provide its own
   46|       |    /// [`Substitution::Error`] type.
   47|       |    ///
   48|       |    /// An infallible substitution can use [`Void`] to reflect
   49|       |    /// the fact that error is impossible, and callers can use
   50|       |    /// [`Unvoidable::not_void`] to eliminate the impossible case of
   51|       |    /// the result neatly.
   52|       |    type Error: From<<<Self as Shiftable<'a>>::Inner as Substitution<'a>>::Error>;
   53|       |    /// Any substitution should define whether a given bound variable
   54|       |    /// should be substituted, and if so with what.
   55|       |    fn subst_bvar(&self, i: u32) -> Result<Option<Defined<'a>>, Self::Error>;
   56|       |    /// Any substitution should define whether a given existential variable
   57|       |    /// should be substituted, and if so with what.
   58|       |    fn subst_evar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, Self::Error>;
   59|       |    /// Any substitution should define whether a given universal variable
   60|       |    /// should be substituted, and if so with what.
   61|       |    fn subst_uvar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, Self::Error>;
   62|       |
   63|    114|    fn record_fields(&self, rfs: &[RecordField<'a>]) -> Result<Vec<RecordField<'a>>, Self::Error> {
   64|    114|        rfs.iter()
   65|    228|            .map(|rf| {
   66|    228|                Ok(RecordField {
   67|    228|                    name: rf.name,
   68|    228|                    ty: self.value(&rf.ty)?,
                                                        ^0
   69|       |                })
   70|    228|            })
   71|    114|            .collect()
   72|    114|    }
   73|       |
   74|    114|    fn variant_cases(&self, vcs: &[VariantCase<'a>]) -> Result<Vec<VariantCase<'a>>, Self::Error> {
   75|    114|        vcs.iter()
   76|    342|            .map(|vc| {
   77|    342|                Ok(VariantCase {
   78|    342|                    name: vc.name,
   79|    342|                    ty: self.value_option(&vc.ty)?,
                                                               ^0
   80|    342|                    refines: vc.refines,
   81|       |                })
   82|    342|            })
   83|    114|            .collect()
   84|    114|    }
   85|       |
   86|    494|    fn value_option(&self, vt: &Option<Value<'a>>) -> Result<Option<Value<'a>>, Self::Error> {
   87|    494|        vt.as_ref().map(|ty| self.value(ty)).transpose()
                                           ^380
   88|    494|    }
   89|       |
   90|  5.67k|    fn value(&self, vt: &Value<'a>) -> Result<Value<'a>, Self::Error> {
   91|  5.67k|        Ok(match vt {
   92|    101|            Value::Bool => Value::Bool,
   93|    608|            Value::S(w) => Value::S(*w),
   94|  1.06k|            Value::U(w) => Value::U(*w),
   95|    304|            Value::F(w) => Value::F(*w),
   96|    310|            Value::Char => Value::Char,
   97|    706|            Value::String => Value::String,
   98|    228|            Value::List(vt) => Value::List(Box::new(self.value(vt)?)),
                                                                                ^0
   99|  1.06k|            Value::FixList(vt, size) => Value::FixList(Box::new(self.value(vt)?), *size),
                                                                                            ^0
  100|    114|            Value::Record(rfs) => Value::Record(self.record_fields(rfs)?),
                                                                                     ^0
  101|    114|            Value::Variant(vcs) => Value::Variant(self.variant_cases(vcs)?),
                                                                                       ^0
  102|    228|            Value::Flags(ns) => Value::Flags(ns.clone()),
  103|    114|            Value::Enum(ns) => Value::Enum(ns.clone()),
  104|     76|            Value::Option(vt) => Value::Option(Box::new(self.value(vt)?)),
                                                                                    ^0
  105|     76|            Value::Tuple(vts) => Value::Tuple(
  106|     76|                vts.iter()
  107|    152|                    .map(|vt| self.value(vt))
  108|     76|                    .collect::<Result<Vec<Value<'a>>, Self::Error>>()?,
                                                                                   ^0
  109|       |            ),
  110|     76|            Value::Result(vt1, vt2) => Value::Result(
  111|     76|                Box::new(self.value_option(vt1)?),
                                                             ^0
  112|     76|                Box::new(self.value_option(vt2)?),
                                                             ^0
  113|       |            ),
  114|     88|            Value::Own(h) => Value::Own(self.handleable_(h)?),
                                                                         ^0
  115|     22|            Value::Borrow(h) => Value::Borrow(self.handleable_(h)?),
                                                                               ^0
  116|    380|            Value::Var(tv, vt) => Value::Var(
  117|    380|                tv.as_ref().and_then(|tv| match self.var(tv) {
  118|    170|                    Ok(Some(Defined::Handleable(Handleable::Var(tv)))) => Some(tv),
  119|    210|                    Ok(None) => Some(tv.clone()),
  120|      0|                    _ => None,
  121|    380|                }),
  122|    380|                Box::new(self.value(vt)?),
                                                     ^0
  123|       |            ),
  124|       |        })
  125|  5.67k|    }
  126|       |
  127|  1.53k|    fn param(&self, pt: &Param<'a>) -> Result<Param<'a>, Self::Error> {
  128|  1.53k|        Ok(Param {
  129|  1.53k|            name: pt.name,
  130|  1.53k|            ty: self.value(&pt.ty)?,
                                                ^0
  131|       |        })
  132|  1.53k|    }
  133|       |
  134|  1.51k|    fn params(&self, pts: &Vec<Param<'a>>) -> Result<Vec<Param<'a>>, Self::Error> {
  135|  1.53k|        pts.iter().map(|pt| self.param(pt)).collect()
  136|  1.51k|    }
  137|       |
  138|  1.51k|    fn result(
  139|  1.51k|        &self,
  140|  1.51k|        rt: &crate::etypes::Result<'a>,
  141|  1.51k|    ) -> Result<crate::etypes::Result<'a>, Self::Error> {
  142|  1.51k|        Ok(match rt {
  143|  1.43k|            Some(vt) => Some(self.value(vt)?),
                                                         ^0
  144|     82|            None => None,
  145|       |        })
  146|  1.51k|    }
  147|       |
  148|  1.51k|    fn func(&self, ft: &Func<'a>) -> Result<Func<'a>, Self::Error> {
  149|  1.51k|        Ok(Func {
  150|  1.51k|            params: self.params(&ft.params)?,
                                                         ^0
  151|  1.51k|            result: self.result(&ft.result)?,
                                                         ^0
  152|       |        })
  153|  1.51k|    }
  154|       |
  155|    702|    fn var(&self, tv: &Tyvar) -> Result<Option<Defined<'a>>, Self::Error> {
  156|    154|        match tv {
  157|    548|            Tyvar::Bound(i) => self.subst_bvar(*i),
  158|     21|            Tyvar::Free(FreeTyvar::U(o, i)) => self.subst_uvar(*o, *i),
  159|    133|            Tyvar::Free(FreeTyvar::E(o, i)) => self.subst_evar(*o, *i),
  160|       |        }
  161|    702|    }
  162|       |
  163|    322|    fn handleable(&self, h: &Handleable) -> Result<Defined<'a>, Self::Error> {
  164|    322|        let hh = Defined::Handleable(h.clone());
  165|    322|        match h {
  166|      0|            Handleable::Resource(_) => Ok(hh),
  167|    322|            Handleable::Var(tv) => Ok(self.var(tv)?.unwrap_or(hh)),
                                                                ^0
  168|       |        }
  169|    322|    }
  170|       |
  171|    110|    fn handleable_(&self, h: &Handleable) -> Result<Handleable, Self::Error> {
  172|    110|        match self.handleable(h)? {
                                              ^0
  173|    110|            Defined::Handleable(h_) => Ok(h_),
  174|      0|            _ => panic!("internal invariant a violation: owned/borrowed var is not resource"),
  175|       |        }
  176|    110|    }
  177|       |
  178|    402|    fn defined(&self, dt: &Defined<'a>) -> Result<Defined<'a>, Self::Error> {
  179|    402|        Ok(match dt {
  180|    212|            Defined::Handleable(h) => self.handleable(h)?,
                                                                      ^0
  181|    190|            Defined::Value(vt) => Defined::Value(self.value(vt)?),
                                                                             ^0
  182|      0|            Defined::Func(ft) => Defined::Func(self.func(ft)?),
  183|      0|            Defined::Instance(it) => Defined::Instance(self.qualified_instance(it)?),
  184|      0|            Defined::Component(ct) => Defined::Component(self.component(ct)?),
  185|       |        })
  186|    402|    }
  187|       |
  188|    212|    fn type_bound(&self, tb: &TypeBound<'a>) -> Result<TypeBound<'a>, Self::Error> {
  189|    212|        Ok(match tb {
  190|    190|            TypeBound::Eq(dt) => TypeBound::Eq(self.defined(dt)?),
                                                                             ^0
  191|     22|            TypeBound::SubResource => TypeBound::SubResource,
  192|       |        })
  193|    212|    }
  194|       |
  195|    212|    fn bounded_tyvar(&self, btv: &BoundedTyvar<'a>) -> Result<BoundedTyvar<'a>, Self::Error> {
  196|    212|        Ok(BoundedTyvar {
  197|    212|            origin: btv.origin.clone(),
  198|    212|            bound: self.type_bound(&btv.bound)?,
                                                            ^0
  199|       |        })
  200|    212|    }
  201|       |
  202|  1.79k|    fn extern_desc(&self, ed: &ExternDesc<'a>) -> Result<ExternDesc<'a>, Self::Error> {
  203|  1.79k|        Ok(match ed {
  204|      0|            ExternDesc::CoreModule(cmt) => ExternDesc::CoreModule(cmt.clone()),
  205|  1.51k|            ExternDesc::Func(ft) => ExternDesc::Func(self.func(ft)?),
                                                                                ^0
  206|    212|            ExternDesc::Type(dt) => ExternDesc::Type(self.defined(dt)?),
                                                                                   ^0
  207|     57|            ExternDesc::Instance(it) => ExternDesc::Instance(self.instance(it)?),
                                                                                            ^0
  208|      5|            ExternDesc::Component(ct) => ExternDesc::Component(self.component(ct)?),
                                                                                               ^0
  209|       |        })
  210|  1.79k|    }
  211|       |
  212|  1.64k|    fn extern_decl(&self, ed: &ExternDecl<'a>) -> Result<ExternDecl<'a>, Self::Error> {
  213|  1.64k|        Ok(ExternDecl {
  214|  1.64k|            kebab_name: ed.kebab_name,
  215|  1.64k|            desc: self.extern_desc(&ed.desc)?,
                                                          ^0
  216|       |        })
  217|  1.64k|    }
  218|       |
  219|    105|    fn instance(&self, it: &Instance<'a>) -> Result<Instance<'a>, Self::Error> {
  220|    105|        let exports = it
  221|    105|            .exports
  222|    105|            .iter()
  223|  1.63k|            .map(|ed| self.extern_decl(ed))
  224|    105|            .collect::<Result<Vec<_>, Self::Error>>()?;
                                                                   ^0
  225|    105|        Ok(Instance { exports })
  226|    105|    }
  227|       |
  228|     23|    fn qualified_instance(
  229|     23|        &self,
  230|     23|        qit: &QualifiedInstance<'a>,
  231|     23|    ) -> Result<QualifiedInstance<'a>, Self::Error> {
  232|     23|        let mut evars = Vec::new();
  233|     23|        let mut sub = self.shifted();
  234|     92|        for evar in &qit.evars {
                          ^69
  235|     69|            evars.push(sub.bounded_tyvar(evar)?);
                                                            ^0
  236|     69|            sub.bshift(1);
  237|     69|            sub.rbshift(1);
  238|       |        }
  239|     23|        let it = sub.instance(&qit.unqualified)?;
                                                             ^0
  240|     23|        Ok(QualifiedInstance {
  241|     23|            evars,
  242|     23|            unqualified: it,
  243|     23|        })
  244|     23|    }
  245|       |
  246|      5|    fn component(&self, ct: &Component<'a>) -> Result<Component<'a>, Self::Error> {
  247|      5|        let mut uvars = Vec::new();
  248|      5|        let mut sub = self.shifted();
  249|     35|        for uvar in &ct.uvars {
                          ^30
  250|     30|            uvars.push(sub.bounded_tyvar(uvar)?);
                                                            ^0
  251|     30|            sub.bshift(1);
  252|     30|            sub.rbshift(1);
  253|       |        }
  254|      5|        let imports = ct
  255|      5|            .imports
  256|      5|            .iter()
  257|     10|            .map(|ed| sub.extern_decl(ed).map_err(Into::into))
  258|      5|            .collect::<Result<Vec<ExternDecl<'a>>, Self::Error>>()?;
                                                                                ^0
  259|      5|        let instance = sub.qualified_instance(&ct.instance)?;
                                                                         ^0
  260|      5|        Ok(Component {
  261|      5|            uvars,
  262|      5|            imports,
  263|      5|            instance,
  264|      5|        })
  265|      5|    }
  266|       |}
  267|       |
  268|       |/// A substitution that shifts bound variables up by a defined offset.
  269|       |/// This will generally be accessed through [`Shifted`] below.  It is
  270|       |/// important to ensure that a bound variable produced by a
  271|       |/// substitution is not captured.
  272|       |struct RBShift {
  273|       |    rbshift: i32,
  274|       |}
  275|       |impl<'a> Shiftable<'a> for RBShift {
  276|       |    type Inner = Self;
  277|      0|    fn shifted<'b>(&'b self) -> Shifted<'b, Self::Inner> {
  278|      0|        Shifted::new(self)
  279|      0|    }
  280|       |}
  281|       |impl<'a> Substitution<'a> for RBShift {
  282|       |    type Error = Void;
  283|      0|    fn subst_bvar(&self, i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  284|      0|        Ok(Some(Defined::Handleable(Handleable::Var(Tyvar::Bound(
  285|      0|            i.checked_add_signed(self.rbshift).unwrap(),
  286|      0|        )))))
  287|      0|    }
  288|      0|    fn subst_evar(&self, _o: u32, _i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  289|      0|        Ok(None)
  290|      0|    }
  291|      0|    fn subst_uvar(&self, _o: u32, _i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  292|      0|        Ok(None)
  293|      0|    }
  294|       |}
  295|       |
  296|       |/// A substitution that can be converted into a [`Shifted`]
  297|       |/// substitution. All types other than [`Shifted`] itself should
  298|       |/// implement this with the obvious option of
  299|       |/// ```
  300|       |/// impl<'a> Shiftable<'a> for A {
  301|       |///     type Inner = Self;
  302|       |///     fn shifted<'b>(&'b self) -> Shifted<'b, Self::Inner> { Shifted::new(self) }
  303|       |/// }
  304|       |/// ```
  305|       |/// Unfortunately, it is not reasonably possible to provide this
  306|       |/// automatically without specialization.
  307|       |pub trait Shiftable<'a> {
  308|       |    type Inner: ?Sized + Substitution<'a>;
  309|       |    fn shifted<'c>(&'c self) -> Shifted<'c, Self::Inner>;
  310|       |}
  311|       |
  312|       |/// A "shifted" version of a substitution, used internally to assure
  313|       |/// that substitution is capture-avoiding.
  314|       |pub struct Shifted<'b, A: ?Sized> {
  315|       |    /// The substitution which is being shifted
  316|       |    underlying: &'b A,
  317|       |    /// The offset to apply to bound variables before querying the
  318|       |    /// original substitution
  319|       |    bshift: i32,
  320|       |    /// The offset to apply to outer instance indices before
  321|       |    /// querying the original substitution
  322|       |    oshift: i32,
  323|       |    /// The offset to apply to free evar indices before
  324|       |    /// querying the original substitution
  325|       |    eshift: i32,
  326|       |    /// The offset to apply to free uvar indices before
  327|       |    /// querying the original substitution
  328|       |    ushift: i32,
  329|       |    /// The offset to apply to bound variables in the result of the
  330|       |    /// original substitution
  331|       |    rbshift: i32,
  332|       |}
  333|       |impl<'b, A: ?Sized> Clone for Shifted<'b, A> {
  334|      7|    fn clone(&self) -> Self {
  335|      7|        Self {
  336|      7|            underlying: self.underlying,
  337|      7|            bshift: self.bshift,
  338|      7|            oshift: self.oshift,
  339|      7|            eshift: self.eshift,
  340|      7|            ushift: self.ushift,
  341|      7|            rbshift: self.rbshift,
  342|      7|        }
  343|      7|    }
  344|       |}
  345|       |impl<'a, 'b, A: ?Sized + Substitution<'a>> Shiftable<'a> for Shifted<'b, A> {
  346|       |    type Inner = A;
  347|      7|    fn shifted<'c>(&'c self) -> Shifted<'c, Self::Inner> {
  348|      7|        self.clone()
  349|      7|    }
  350|       |}
  351|       |
  352|       |impl<'a, 'b, A: ?Sized + Substitution<'a>> Shifted<'b, A> {
  353|     21|    fn new(s: &'b A) -> Self {
  354|     21|        Self {
  355|     21|            underlying: s,
  356|     21|            bshift: 0,
  357|     21|            oshift: 0,
  358|     21|            eshift: 0,
  359|     21|            ushift: 0,
  360|     21|            rbshift: 0,
  361|     21|        }
  362|     21|    }
  363|     99|    fn bshift(&mut self, bshift: i32) {
  364|     99|        self.bshift += bshift;
  365|     99|    }
  366|       |    #[allow(unused)]
  367|      0|    fn oshift(&mut self, oshift: i32) {
  368|      0|        self.oshift += oshift;
  369|      0|    }
  370|       |    #[allow(unused)]
  371|      0|    fn ushift(&mut self, ushift: i32) {
  372|      0|        self.ushift += ushift;
  373|      0|    }
  374|       |    #[allow(unused)]
  375|      0|    fn eshift(&mut self, eshift: i32) {
  376|      0|        self.eshift += eshift;
  377|      0|    }
  378|     99|    fn rbshift(&mut self, rbshift: i32) {
  379|     99|        self.rbshift += rbshift;
  380|     99|    }
  381|       |
  382|      0|    fn sub_rbshift(
  383|      0|        &self,
  384|      0|        dt: Result<Option<Defined<'a>>, <Self as Substitution<'a>>::Error>,
  385|      0|    ) -> Result<Option<Defined<'a>>, <Self as Substitution<'a>>::Error> {
  386|      0|        match dt {
  387|      0|            Ok(Some(dt)) => {
  388|      0|                let rbsub = RBShift {
  389|      0|                    rbshift: self.rbshift,
  390|      0|                };
  391|      0|                Ok(Some(rbsub.defined(&dt).not_void()))
  392|       |            }
  393|      0|            _ => dt,
  394|       |        }
  395|      0|    }
  396|       |}
  397|       |
  398|       |impl<'a, 'b, A: ?Sized + Substitution<'a>> Substitution<'a> for Shifted<'b, A> {
  399|       |    type Error = A::Error;
  400|    324|    fn subst_bvar(&self, i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  401|    324|        match i.checked_add_signed(-self.bshift) {
  402|      0|            Some(i) => self.sub_rbshift(self.underlying.subst_bvar(i)),
  403|    324|            _ => Ok(None),
  404|       |        }
  405|    324|    }
  406|      0|    fn subst_evar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  407|      0|        match (
  408|      0|            o.checked_add_signed(-self.oshift),
  409|      0|            i.checked_add_signed(-self.eshift),
  410|       |        ) {
  411|      0|            (Some(o), Some(i)) => self.sub_rbshift(self.underlying.subst_evar(o, i)),
  412|      0|            _ => Ok(None),
  413|       |        }
  414|      0|    }
  415|      0|    fn subst_uvar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  416|      0|        match (
  417|      0|            o.checked_add_signed(-self.oshift),
  418|      0|            i.checked_add_signed(-self.ushift),
  419|       |        ) {
  420|      0|            (Some(o), Some(i)) => self.sub_rbshift(self.underlying.subst_uvar(o, i)),
  421|      0|            _ => Ok(None),
  422|       |        }
  423|      0|    }
  424|       |}
  425|       |
  426|       |/// Innerizing can fail because a type variable needs to be taken
  427|       |/// through an `outer_boundary` but cannot be resolved to a concrete
  428|       |/// type that can be copied.
  429|       |#[derive(Debug)]
  430|       |pub enum InnerizeError {
  431|       |    IndefiniteTyvar,
  432|       |}
  433|       |/// An innerize substitution is used to bring an outer type alias
  434|       |/// inwards through one context.
  435|       |pub struct Innerize<'c, 'p, 'a> {
  436|       |    /// What ctx was this type originally in?
  437|       |    ctx: &'c Ctx<'p, 'a>,
  438|       |    /// Are we crossing an outer_boundary?
  439|       |    outer_boundary: bool,
  440|       |}
  441|       |impl<'c, 'p, 'a> Shiftable<'a> for Innerize<'c, 'p, 'a> {
  442|       |    type Inner = Self;
  443|      0|    fn shifted<'d>(&'d self) -> Shifted<'d, Self::Inner> {
  444|      0|        Shifted::new(self)
  445|      0|    }
  446|       |}
  447|       |impl<'c, 'p, 'a> Substitution<'a> for Innerize<'c, 'p, 'a> {
  448|       |    type Error = InnerizeError;
  449|      0|    fn subst_bvar(&self, _i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  450|      0|        Ok(None)
  451|      0|    }
  452|       |    // Note that even if the variables resolve, what they resolve to
  453|       |    // needs to itself be innerized, since it was also designed for
  454|       |    // this context.
  455|      0|    fn subst_evar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  456|      0|        if !self.outer_boundary {
  457|      0|            Ok(Some(Defined::Handleable(Handleable::Var(Tyvar::Free(
  458|      0|                FreeTyvar::E(o + 1, i),
  459|      0|            )))))
  460|       |        } else {
  461|      0|            match self.ctx.resolve_tyvar(&Tyvar::Free(FreeTyvar::E(o, i))) {
  462|      0|                ResolvedTyvar::Definite(dt) => Ok(Some(self.defined(&dt)?)),
  463|      0|                _ => Err(InnerizeError::IndefiniteTyvar),
  464|       |            }
  465|       |        }
  466|      0|    }
  467|      0|    fn subst_uvar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, Self::Error> {
  468|      0|        if !self.outer_boundary {
  469|      0|            Ok(Some(Defined::Handleable(Handleable::Var(Tyvar::Free(
  470|      0|                FreeTyvar::U(o + 1, i),
  471|      0|            )))))
  472|       |        } else {
  473|      0|            match self.ctx.resolve_tyvar(&Tyvar::Free(FreeTyvar::U(o, i))) {
  474|      0|                ResolvedTyvar::Definite(dt) => Ok(Some(self.defined(&dt)?)),
  475|      0|                _ => Err(InnerizeError::IndefiniteTyvar),
  476|       |            }
  477|       |        }
  478|      0|    }
  479|       |}
  480|       |impl<'c, 'p, 'a> Innerize<'c, 'p, 'a> {
  481|      0|    pub fn new(ctx: &'c Ctx<'p, 'a>, outer_boundary: bool) -> Innerize<'c, 'p, 'a> {
  482|      0|        Innerize {
  483|      0|            ctx,
  484|      0|            outer_boundary,
  485|      0|        }
  486|      0|    }
  487|       |}
  488|       |
  489|       |/// The empty (void) type
  490|       |pub enum Void {}
  491|       |
  492|       |/// Things that you can call [`not_void`](Unvoidable::not_void) on
  493|       |pub trait Unvoidable {
  494|       |    type Result;
  495|       |    fn not_void(self) -> Self::Result;
  496|       |}
  497|       |
  498|       |/// Eliminate a Result<_, Void>
  499|       |impl<A> Unvoidable for Result<A, Void> {
  500|       |    type Result = A;
  501|    248|    fn not_void(self) -> A {
  502|    248|        match self {
  503|    248|            Ok(x) => x,
  504|    248|            Err(v) => match v {},
  505|    248|        }
  506|    248|    }
  507|       |}
  508|       |
  509|       |/// An opening substitution is used to map bound variables into
  510|       |/// free variables. Note that because of the differences in ordering
  511|       |/// for bound variable indices (inside out) and context variables
  512|       |/// (left to right, but variables are inserted in outside-in order),
  513|       |/// `Bound(0)` gets mapped to `Free(0, base + n)`.
  514|       |pub struct Opening {
  515|       |    /// Whether to produce E or U free variables
  516|       |    is_universal: bool,
  517|       |    /// At what index in the context are the free variables being
  518|       |    /// inserted?
  519|       |    free_base: u32,
  520|       |    /// How many bound variables are being shifted to the context
  521|       |    how_many: u32,
  522|       |}
  523|       |impl<'a> Shiftable<'a> for Opening {
  524|       |    type Inner = Self;
  525|      8|    fn shifted<'d>(&'d self) -> Shifted<'d, Self::Inner> {
  526|      8|        Shifted::new(self)
  527|      8|    }
  528|       |}
  529|       |impl<'a> Substitution<'a> for Opening {
  530|       |    type Error = Void;
  531|    224|    fn subst_bvar(&self, i: u32) -> Result<Option<Defined<'a>>, Void> {
  532|    224|        let mk = |i| {
  533|    224|            let fi = self.free_base + self.how_many - i - 1;
  534|    224|            if self.is_universal {
  535|     63|                FreeTyvar::U(0, fi)
  536|       |            } else {
  537|    161|                FreeTyvar::E(0, fi)
  538|       |            }
  539|    224|        };
  540|    224|        Ok(if i < self.how_many {
  541|    224|            Some(Defined::Handleable(Handleable::Var(Tyvar::Free(mk(i)))))
  542|       |        } else {
  543|      0|            None
  544|       |        })
  545|    224|    }
  546|     40|    fn subst_evar(&self, _o: u32, _i: u32) -> Result<Option<Defined<'a>>, Void> {
  547|     40|        Ok(None)
  548|     40|    }
  549|      0|    fn subst_uvar(&self, _o: u32, _i: u32) -> Result<Option<Defined<'a>>, Void> {
  550|      0|        Ok(None)
  551|      0|    }
  552|       |}
  553|       |impl Opening {
  554|    165|    pub fn new(is_universal: bool, free_base: u32) -> Self {
  555|    165|        Opening {
  556|    165|            is_universal,
  557|    165|            free_base,
  558|    165|            how_many: 0,
  559|    165|        }
  560|    165|    }
  561|     79|    pub fn next(&mut self) {
  562|     79|        self.how_many += 1;
  563|     79|    }
  564|       |}
  565|       |
  566|       |/// A closing substitution is used to map free variables into bound
  567|       |/// variables when converting a type being built in a context to a
  568|       |/// closed(ish) type that is above that context.
  569|       |///
  570|       |/// Like [`Opening`], a given [`Closing`] substitution either affects
  571|       |/// only existential variables or affects only universal variables, as
  572|       |/// these are closed at different times.
  573|       |pub struct Closing {
  574|       |    /// If this substitution applies to universal variables, this
  575|       |    /// keeps track of which ones are imported and which are
  576|       |    /// not. Non-imported universal variables may not be referred to
  577|       |    /// in types.
  578|       |    ///
  579|       |    /// Invariant: If this is provided, its length must be equal to
  580|       |    /// self.how_many
  581|       |    universal_imported: Option<Vec<bool>>,
  582|       |    /// How many of the relevant (u/e) free vars are valid at this point.
  583|       |    how_many: u32,
  584|       |}
  585|       |impl Closing {
  586|     24|    pub fn new(is_universal: bool) -> Self {
  587|     24|        let universal_imported = if is_universal { Some(Vec::new()) } else { None };
                                                                 ^12                       ^12
  588|     24|        Closing {
  589|     24|            universal_imported,
  590|     24|            how_many: 0,
  591|     24|        }
  592|     24|    }
  593|    142|    fn is_universal(&self) -> bool {
  594|    142|        self.universal_imported.is_some()
  595|    142|    }
  596|      6|    pub fn next_u(&mut self, imported: bool) {
  597|      6|        let Some(ref mut importeds) = self.universal_imported else {
  598|      0|            panic!("next_u called on existential Closing");
  599|       |        };
  600|      6|        importeds.push(imported);
  601|      6|        self.how_many += 1;
  602|      6|    }
  603|     28|    pub fn next_e(&mut self) {
  604|     28|        if self.is_universal() {
  605|      0|            panic!("next_e called on universal Closing");
  606|     28|        };
  607|     28|        self.how_many += 1;
  608|     28|    }
  609|    114|    fn subst_uevar<'a>(
  610|    114|        &self,
  611|    114|        ue_is_u: bool,
  612|    114|        o: u32,
  613|    114|        i: u32,
  614|    114|    ) -> Result<Option<Defined<'a>>, ClosingError> {
  615|    114|        if self.is_universal() ^ ue_is_u {
  616|      0|            return Ok(None);
  617|    114|        }
  618|    114|        let mk_ue = |o, i| {
  619|      0|            if self.is_universal() {
  620|      0|                Tyvar::Free(FreeTyvar::U(o, i))
  621|       |            } else {
  622|      0|                Tyvar::Free(FreeTyvar::E(o, i))
  623|       |            }
  624|      0|        };
  625|    114|        let mk = |v| Ok(Some(Defined::Handleable(Handleable::Var(v))));
  626|    114|        if o > 0 {
  627|      0|            return mk(mk_ue(o - 1, i));
  628|    114|        }
  629|    114|        if i >= self.how_many {
  630|      0|            return Err(ClosingError::UnknownVar(false, i));
  631|    114|        }
  632|    114|        let bidx = if let Some(imported) = &self.universal_imported {
                                             ^21
  633|     21|            if !imported[i as usize] {
  634|      0|                return Err(ClosingError::UnimportedVar(i));
  635|     21|            }
  636|     66|            imported[i as usize..].iter().filter(|x| **x).count() as u32 - 1
                                                                      ^21
  637|       |        } else {
  638|     93|            self.how_many - i - 1
  639|       |        };
  640|    114|        mk(Tyvar::Bound(bidx))
  641|    114|    }
  642|       |}
  643|       |impl<'a> Shiftable<'a> for Closing {
  644|       |    type Inner = Self;
  645|     13|    fn shifted<'d>(&'d self) -> Shifted<'d, Self::Inner> {
  646|     13|        Shifted::new(self)
  647|     13|    }
  648|       |}
  649|       |/// Closing can fail for a few reasons:
  650|       |#[derive(Debug)]
  651|       |#[allow(unused)]
  652|       |pub enum ClosingError {
  653|       |    /// A variable was encountered that isn't currently being moved to
  654|       |    /// a bound variable. This is an internal invariant violation in
  655|       |    /// the typechecker, not an issue of a malformed input type.
  656|       |    UnknownVar(bool, u32),
  657|       |    /// A universal variable wasn't imported. This is probably an
  658|       |    /// internal invariant violation in the typechecker.
  659|       |    UnimportedVar(u32),
  660|       |}
  661|       |impl<'a> Substitution<'a> for Closing {
  662|       |    type Error = ClosingError;
  663|      0|    fn subst_bvar(&self, _: u32) -> Result<Option<Defined<'a>>, ClosingError> {
  664|      0|        Ok(None)
  665|      0|    }
  666|     93|    fn subst_evar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, ClosingError> {
  667|     93|        self.subst_uevar(false, o, i)
  668|     93|    }
  669|     21|    fn subst_uvar(&self, o: u32, i: u32) -> Result<Option<Defined<'a>>, ClosingError> {
  670|     21|        self.subst_uevar(true, o, i)
  671|     21|    }
  672|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/subtype.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |use itertools::Itertools;
   18|       |
   19|       |use crate::etypes::{
   20|       |    Component, Ctx, Defined, Func, Handleable, Name, QualifiedInstance, ResourceId, TypeBound,
   21|       |    Tyvar, Value,
   22|       |};
   23|       |use crate::tv::ResolvedTyvar;
   24|       |
   25|       |/// The various ways in which a value can fail to be a subtype of another
   26|       |#[derive(Debug)]
   27|       |#[allow(dead_code)]
   28|       |pub enum Error<'r> {
   29|       |    /// An unnamed value that was expected was missing (e.g. in a
   30|       |    /// tuple or variant case)
   31|       |    MissingValue(Value<'r>),
   32|       |    /// A record field that was expected was missing
   33|       |    MissingRecordField(Name<'r>),
   34|       |    /// A variant case that was expected was missing
   35|       |    MissingVariantCase(Name<'r>),
   36|       |    /// A value type was present, but incompatible with its expected type
   37|       |    MismatchedValue(Value<'r>, Value<'r>),
   38|       |    /// A defined type was present, but incompatible with its expected type
   39|       |    MismatchedDefined(Box<Defined<'r>>, Box<Defined<'r>>),
   40|       |    /// A resource was present, but was not the same resource as was expected
   41|       |    MismatchedResources(ResourceId, ResourceId),
   42|       |    /// A type variable could not be resolved to be the same as the
   43|       |    /// expected one
   44|       |    MismatchedVars(Tyvar, Tyvar),
   45|       |    /// A resource was expected but a non-resource tyvar was found, or
   46|       |    /// vice versa
   47|       |    MismatchedResourceVar(Tyvar, ResourceId),
   48|       |    /// A handle was taken to something that wasn't a
   49|       |    /// resource. Strictly speaking, this might be a well-formedness
   50|       |    /// error on one side or the other rather than a subtyping error
   51|       |    NotResource(Handleable),
   52|       |}
   53|       |
   54|       |/// # Subtyping
   55|       |///
   56|       |/// Most of this is a very direct translation of the subset of the
   57|       |/// OCaml reference interpreter that we need here. Most of the bits
   58|       |/// with variables and instantiation that require being quite careful
   59|       |/// are not involved here, since during the elaboration that we are
   60|       |/// doing we never need to fully subtype entire component types, which
   61|       |/// makes this quite a bit simpler.
   62|       |impl<'p, 'a> Ctx<'p, 'a> {
   63|      0|    pub fn subtype_value<'r>(
   64|      0|        &self,
   65|      0|        vt1: &'r Value<'a>,
   66|      0|        vt2: &'r Value<'a>,
   67|      0|    ) -> Result<(), Error<'a>> {
   68|       |        use Value::*;
   69|       |        use itertools::EitherOrBoth::*;
   70|      0|        match (vt1, vt2) {
   71|      0|            (Bool, Bool) => Ok(()),
   72|      0|            (S(w1), S(w2)) if w1 == w2 => Ok(()),
   73|      0|            (U(w1), U(w2)) if w1 == w2 => Ok(()),
   74|      0|            (F(w1), F(w2)) if w1 == w2 => Ok(()),
   75|      0|            (Char, Char) => Ok(()),
   76|      0|            (String, String) => Ok(()),
   77|      0|            (List(vt1), List(vt2)) => self.subtype_value(vt1, vt2),
   78|      0|            (Record(rfs1), Record(rfs2)) => {
   79|      0|                for rf2 in rfs2.iter() {
   80|      0|                    match rfs1.iter().find(|rf| rf2.name.name == rf.name.name) {
   81|      0|                        None => return Err(Error::MissingRecordField(rf2.name)),
   82|      0|                        Some(rf1) => self.subtype_value(&rf1.ty, &rf2.ty)?,
   83|       |                    }
   84|       |                }
   85|      0|                Ok(())
   86|       |            }
   87|      0|            (Tuple(vts1), Tuple(vts2)) => {
   88|      0|                vts1.iter()
   89|      0|                    .zip_longest(vts2.iter())
   90|      0|                    .try_for_each(|vs| match vs {
   91|      0|                        Both(vt1, vt2) => self.subtype_value(vt1, vt2),
   92|      0|                        Left(_) => Ok(()),
   93|      0|                        Right(vt2) => Err(Error::MissingValue(vt2.clone())),
   94|      0|                    })
   95|       |            }
   96|      0|            (Flags(ns1), Flags(ns2)) => ns2
   97|      0|                .iter()
   98|      0|                .find(|n2| !ns1.iter().any(|n| n.name == n2.name))
   99|      0|                .map_or(Ok(()), |n| Err(Error::MissingRecordField(*n))),
  100|      0|            (Variant(vcs1), Variant(vcs2)) => {
  101|      0|                for vc1 in vcs1.iter() {
  102|      0|                    match vcs2.iter().find(|vc| vc1.name.name == vc.name.name) {
  103|      0|                        None => return Err(Error::MissingVariantCase(vc1.name)),
  104|      0|                        Some(vc2) => self.subtype_value_option(&vc1.ty, &vc2.ty)?,
  105|       |                    }
  106|       |                }
  107|      0|                Ok(())
  108|       |            }
  109|      0|            (Enum(ns1), Enum(ns2)) => ns1
  110|      0|                .iter()
  111|      0|                .find(|n1| !ns2.iter().any(|n| n.name == n1.name))
  112|      0|                .map_or(Ok(()), |n| Err(Error::MissingVariantCase(*n))),
  113|      0|            (Option(vt1), Option(vt2)) => self.subtype_value(vt1, vt2),
  114|      0|            (Result(vt11, vt12), Result(vt21, vt22)) => self
  115|      0|                .subtype_value_option(vt11, vt21)
  116|      0|                .and(self.subtype_value_option(vt12, vt22)),
  117|      0|            (Own(ht1), Own(ht2)) | (Borrow(ht1), Borrow(ht2)) => {
  118|      0|                self.subtype_handleable_is_resource(ht1)?;
  119|      0|                self.subtype_handleable_is_resource(ht2)?;
  120|      0|                self.subtype_handleable(ht1, ht2)
  121|       |            }
  122|      0|            (Var(_, vt1), vt2) => self.subtype_value(vt1, vt2),
  123|      0|            (vt1, Var(_, vt2)) => self.subtype_value(vt1, vt2),
  124|      0|            _ => Err(Error::MismatchedValue(vt1.clone(), vt2.clone())),
  125|       |        }
  126|      0|    }
  127|      0|    pub fn subtype_value_option<'r>(
  128|      0|        &self,
  129|      0|        vt1: &'r Option<Value<'a>>,
  130|      0|        vt2: &'r Option<Value<'a>>,
  131|      0|    ) -> Result<(), Error<'a>> {
  132|      0|        match (vt1, vt2) {
  133|      0|            (None, None) => Ok(()),
  134|      0|            (None, Some(vt2)) => Err(Error::MissingValue(vt2.clone())),
  135|      0|            (Some(_), None) => Ok(()),
  136|      0|            (Some(vt1), Some(vt2)) => self.subtype_value(vt1, vt2),
  137|       |        }
  138|      0|    }
  139|      0|    pub fn subtype_var_var<'r>(&self, v1: &'r Tyvar, v2: &'r Tyvar) -> Result<(), Error<'a>> {
  140|      0|        match (self.resolve_tyvar(v1), self.resolve_tyvar(v2)) {
  141|      0|            (ResolvedTyvar::Definite(dt1), ResolvedTyvar::Definite(dt2)) => {
  142|      0|                self.subtype_defined(&dt1, &dt2)
  143|       |            }
  144|      0|            (ResolvedTyvar::E(o1, i1, _), ResolvedTyvar::E(o2, i2, _)) if o1 == o2 && i1 == i2 => {
  145|      0|                Ok(())
  146|       |            }
  147|      0|            (ResolvedTyvar::U(o1, i1, _), ResolvedTyvar::U(o2, i2, _)) if o1 == o2 && i1 == i2 => {
  148|      0|                Ok(())
  149|       |            }
  150|       |            (ResolvedTyvar::Bound(_), _) | (_, ResolvedTyvar::Bound(_)) => {
  151|      0|                panic!("internal invariant violation: stray bvar in subtype_var_var")
  152|       |            }
  153|      0|            _ => Err(Error::MismatchedVars(v1.clone(), v2.clone())),
  154|       |        }
  155|      0|    }
  156|      0|    pub fn subtype_var_resource<'r>(
  157|      0|        &self,
  158|      0|        v1: &'r Tyvar,
  159|      0|        rid2: &'r ResourceId,
  160|      0|    ) -> Result<(), Error<'a>> {
  161|      0|        match self.resolve_tyvar(v1) {
  162|      0|            ResolvedTyvar::Definite(Defined::Handleable(Handleable::Resource(rid1)))
  163|      0|                if rid1 == *rid2 =>
  164|      0|            {
  165|      0|                Ok(())
  166|       |            }
  167|      0|            _ => Err(Error::MismatchedResourceVar(v1.clone(), *rid2)),
  168|       |        }
  169|      0|    }
  170|      0|    pub fn subtype_resource_var<'r>(
  171|      0|        &self,
  172|      0|        rid1: &'r ResourceId,
  173|      0|        v2: &'r Tyvar,
  174|      0|    ) -> Result<(), Error<'a>> {
  175|      0|        match self.resolve_tyvar(v2) {
  176|      0|            ResolvedTyvar::Definite(Defined::Handleable(Handleable::Resource(rid2)))
  177|      0|                if *rid1 == rid2 =>
  178|      0|            {
  179|      0|                Ok(())
  180|       |            }
  181|      0|            _ => Err(Error::MismatchedResourceVar(v2.clone(), *rid1)),
  182|       |        }
  183|      0|    }
  184|      0|    pub fn subtype_handleable<'r>(
  185|      0|        &self,
  186|      0|        ht1: &'r Handleable,
  187|      0|        ht2: &'r Handleable,
  188|      0|    ) -> Result<(), Error<'a>> {
  189|      0|        match (ht1, ht2) {
  190|      0|            (Handleable::Var(v1), Handleable::Var(v2)) => self.subtype_var_var(v1, v2),
  191|      0|            (Handleable::Var(v1), Handleable::Resource(rid2)) => {
  192|      0|                self.subtype_var_resource(v1, rid2)
  193|       |            }
  194|      0|            (Handleable::Resource(rid1), Handleable::Var(v2)) => {
  195|      0|                self.subtype_resource_var(rid1, v2)
  196|       |            }
  197|      0|            (Handleable::Resource(rid1), Handleable::Resource(rid2)) => {
  198|      0|                if rid1 == rid2 {
  199|      0|                    Ok(())
  200|       |                } else {
  201|      0|                    Err(Error::MismatchedResources(*rid1, *rid2))
  202|       |                }
  203|       |            }
  204|       |        }
  205|      0|    }
  206|      0|    pub fn subtype_func<'r>(
  207|      0|        &self,
  208|      0|        _ft1: &'r Func<'a>,
  209|      0|        _ft2: &'r Func<'a>,
  210|      0|    ) -> Result<(), Error<'a>> {
  211|      0|        panic!("func <: func should be impossible to encounter during type elaboration")
  212|       |    }
  213|      0|    pub fn subtype_qualified_instance<'r>(
  214|      0|        &self,
  215|      0|        _qi1: &'r QualifiedInstance<'a>,
  216|      0|        _qi2: &'r QualifiedInstance<'a>,
  217|      0|    ) -> Result<(), Error<'a>> {
  218|      0|        panic!("qinstance <: qinstance should be impossible to encounter during type elaboration")
  219|       |    }
  220|      0|    pub fn subtype_component<'r>(
  221|      0|        &self,
  222|      0|        _ct1: &'r Component<'a>,
  223|      0|        _ct2: &'r Component<'a>,
  224|      0|    ) -> Result<(), Error<'a>> {
  225|      0|        panic!("component <: component should be impossible to encounter during type elaboration")
  226|       |    }
  227|      0|    pub fn subtype_defined<'r>(
  228|      0|        &self,
  229|      0|        dt1: &'r Defined<'a>,
  230|      0|        dt2: &'r Defined<'a>,
  231|      0|    ) -> Result<(), Error<'a>> {
  232|      0|        match (dt1, dt2) {
  233|      0|            (Defined::Handleable(ht1), Defined::Handleable(ht2)) => {
  234|      0|                self.subtype_handleable(ht1, ht2)
  235|       |            }
  236|      0|            (Defined::Value(vt1), Defined::Value(vt2)) => self.subtype_value(vt1, vt2),
  237|      0|            (Defined::Func(ft1), Defined::Func(ft2)) => self.subtype_func(ft1, ft2),
  238|      0|            (Defined::Instance(it1), Defined::Instance(it2)) => {
  239|      0|                self.subtype_qualified_instance(it1, it2)
  240|       |            }
  241|      0|            (Defined::Component(ct1), Defined::Component(ct2)) => self.subtype_component(ct1, ct2),
  242|      0|            _ => Err(Error::MismatchedDefined(
  243|      0|                Box::new(dt1.clone()),
  244|      0|                Box::new(dt2.clone()),
  245|      0|            )),
  246|       |        }
  247|      0|    }
  248|     25|    pub fn subtype_handleable_is_resource<'r>(&self, ht: &'r Handleable) -> Result<(), Error<'a>> {
  249|     25|        match ht {
  250|      0|            Handleable::Resource(_) => Ok(()),
  251|     25|            Handleable::Var(tv) => match self.resolve_tyvar(tv) {
  252|      0|                ResolvedTyvar::Definite(Defined::Handleable(Handleable::Resource(_))) => Ok(()),
  253|     15|                ResolvedTyvar::E(_, _, TypeBound::SubResource) => Ok(()),
  254|     10|                ResolvedTyvar::U(_, _, TypeBound::SubResource) => Ok(()),
  255|      0|                _ => Err(Error::NotResource(ht.clone())),
  256|       |            },
  257|       |        }
  258|     25|    }
  259|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/tv.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |use crate::etypes::{
   18|       |    BoundedTyvar, Ctx, Defined, FreeTyvar, Handleable, ImportExport, TypeBound, Tyvar,
   19|       |};
   20|       |use crate::substitute::{self, Substitution, Unvoidable};
   21|       |
   22|       |/// The most information we possibly have about a type variable
   23|       |pub enum ResolvedTyvar<'a> {
   24|       |    /// Invariant: the head of this [`Defined`] is not `[Defined::Handleable]([HHandleable::Var](...))`
   25|       |    Definite(Defined<'a>),
   26|       |    /// It's just some bound var... so there is no way to look it up.
   27|       |    #[allow(unused)]
   28|       |    Bound(u32),
   29|       |    /// Invariant: the `TypeBound` is not `TypeBound::Eq`
   30|       |    E(u32, u32, TypeBound<'a>),
   31|       |    /// Invariant: the `TypeBound` is not `TypeBound::Eq`
   32|       |    U(u32, u32, TypeBound<'a>),
   33|       |}
   34|       |
   35|       |impl<'p, 'a> Ctx<'p, 'a> {
   36|       |    /// Look up a universal variable in the context, panicking if it doesn't exist
   37|     52|    fn lookup_uvar<'c>(&'c self, o: u32, i: u32) -> &'c (BoundedTyvar<'a>, bool) {
   38|     52|        // unwrap because failure is an internal invariant violation
   39|     52|        &self.parents().nth(o as usize).unwrap().uvars[i as usize]
   40|     52|    }
   41|       |    /// Look up an existential variable in the context, panicking if it doesn't exist
   42|    153|    fn lookup_evar<'c>(&'c self, o: u32, i: u32) -> &'c (BoundedTyvar<'a>, Option<Defined<'a>>) {
   43|    153|        // unwrap because failure is an internal invariant violation
   44|    153|        &self.parents().nth(o as usize).unwrap().evars[i as usize]
   45|    153|    }
   46|       |    /// Find a bound for the given free tyvar. Panics if given a
   47|       |    /// TV_bound; by the time you call this, you should have used
   48|       |    /// bound_to_[e/u]var.
   49|    150|    pub fn var_bound<'c>(&'c self, tv: &Tyvar) -> &'c TypeBound<'a> {
   50|    150|        match tv {
   51|      0|            Tyvar::Bound(_) => panic!("Requested bound for Bound tyvar"),
   52|     42|            Tyvar::Free(FreeTyvar::U(o, i)) => &self.lookup_uvar(*o, *i).0.bound,
   53|    108|            Tyvar::Free(FreeTyvar::E(o, i)) => &self.lookup_evar(*o, *i).0.bound,
   54|       |        }
   55|    150|    }
   56|       |    /// Try really hard to resolve a tyvar to a definite type or a
   57|       |    /// descriptive bound.
   58|     55|    pub fn resolve_tyvar<'c>(&'c self, v: &Tyvar) -> ResolvedTyvar<'a> {
   59|     55|        let check_deftype = |dt: &Defined<'a>| match dt {
                                                                   ^0
   60|      0|            Defined::Handleable(Handleable::Var(v_)) => self.resolve_tyvar(v_),
   61|     30|            _ => ResolvedTyvar::Definite(dt.clone()),
   62|     30|        };
   63|     55|        match *v {
   64|      0|            Tyvar::Bound(i) => ResolvedTyvar::Bound(i),
   65|     45|            Tyvar::Free(FreeTyvar::E(o, i)) => {
   66|     45|                let (tv, def) = self.lookup_evar(o, i);
   67|     45|                match (&tv.bound, def) {
   68|     30|                    (TypeBound::Eq(dt), _) => check_deftype(dt),
   69|      0|                    (_, Some(dt)) => check_deftype(dt),
   70|     15|                    (tb, _) => ResolvedTyvar::E(o, i, tb.clone()),
   71|       |                }
   72|       |            }
   73|     10|            Tyvar::Free(FreeTyvar::U(o, i)) => {
   74|     10|                let (tv, _) = self.lookup_uvar(o, i);
   75|     10|                match &tv.bound {
   76|      0|                    TypeBound::Eq(dt) => check_deftype(dt),
   77|     10|                    tb => ResolvedTyvar::U(o, i, tb.clone()),
   78|       |                }
   79|       |            }
   80|       |        }
   81|     55|    }
   82|       |    /// Modify the context to move the given variables into it as
   83|       |    /// existential variables and compute a substitution
   84|       |    /// that replaces bound variable references to them with free
   85|       |    /// variable references
   86|    157|    pub fn bound_to_evars(
   87|    157|        &mut self,
   88|    157|        origin: Option<&'a str>,
   89|    157|        vs: &[BoundedTyvar<'a>],
   90|    157|    ) -> substitute::Opening {
   91|    157|        let mut sub = substitute::Opening::new(false, self.evars.len() as u32);
   92|    218|        for var in vs {
                          ^61
   93|     61|            let var = var.push_origin(origin.map(ImportExport::Export));
   94|     61|            let bound = sub.bounded_tyvar(&var).not_void();
   95|     61|            self.evars.push((bound, None));
   96|     61|            sub.next();
   97|     61|        }
   98|    157|        sub
   99|    157|    }
  100|       |    /// Modify the context to move the given variables into it as
  101|       |    /// universal variables and compute a substitution that replaces
  102|       |    /// bound variable references to them with free variable
  103|       |    /// references
  104|      8|    pub fn bound_to_uvars(
  105|      8|        &mut self,
  106|      8|        origin: Option<&'a str>,
  107|      8|        vs: &[BoundedTyvar<'a>],
  108|      8|        imported: bool,
  109|      8|    ) -> substitute::Opening {
  110|      8|        let mut sub = substitute::Opening::new(true, self.uvars.len() as u32);
  111|     26|        for var in vs {
                          ^18
  112|     18|            let var = var.push_origin(origin.map(ImportExport::Import));
  113|     18|            let bound = sub.bounded_tyvar(&var).not_void();
  114|     18|            self.uvars.push((bound, imported));
  115|     18|            sub.next();
  116|     18|        }
  117|      8|        sub
  118|      8|    }
  119|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/util.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! General utilities for bindgen macros
   18|       |use crate::etypes;
   19|       |
   20|       |/// Read and parse a WIT type encapsulated in a wasm file from the
   21|       |/// given filename, relative to the cargo manifest directory.
   22|      1|pub fn read_wit_type_from_file<R, F: FnMut(String, &etypes::Component) -> R>(
   23|      1|    filename: impl AsRef<std::ffi::OsStr>,
   24|      1|    mut cb: F,
   25|      1|) -> R {
   26|      1|    let path = std::path::Path::new(&filename);
   27|      1|    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
   28|      1|    let manifest_dir = std::path::Path::new(&manifest_dir);
   29|      1|    let path = manifest_dir.join(path);
   30|      1|
   31|      1|    let bytes = std::fs::read(path).unwrap();
   32|      1|    let i = wasmparser::Parser::new(0).parse_all(&bytes);
   33|      1|    let ct = crate::component::read_component_single_exported_type(i);
   34|      1|
   35|      1|    // because of the two-level encapsulation scheme, we need to look
   36|      1|    // for the single export of the component type that we just read
   37|      1|    if !ct.uvars.is_empty()
   38|      1|        || !ct.imports.is_empty()
   39|      1|        || !ct.instance.evars.is_empty()
   40|      1|        || ct.instance.unqualified.exports.len() != 1
   41|       |    {
   42|      0|        panic!("malformed component type container for wit type");
   43|      1|    };
   44|      1|    let export = &ct.instance.unqualified.exports[0];
   45|       |    use etypes::ExternDesc;
   46|      1|    let ExternDesc::Component(ct) = &export.desc else {
   47|      0|        panic!("malformed component type container: does not contain component type");
   48|       |    };
   49|      1|    log::debug!("hcm: considering component type {:?}", ct);
                              ^0
   50|      1|    cb(export.kebab_name.to_string(), ct)
   51|      1|}
   52|       |
   53|       |/// Deal with `$HYPERLIGHT_COMPONENT_MACRO_DEBUG`: if it is present,
   54|       |/// save the given token stream (representing the result of
   55|       |/// macroexpansion) to the debug file and include that file instead of
   56|       |/// directly returning the given token stream.
   57|      1|pub fn emit_decls(decls: proc_macro2::TokenStream) -> proc_macro2::TokenStream {
   58|      1|    if let Ok(dbg_out) = std::env::var("HYPERLIGHT_COMPONENT_MACRO_DEBUG") {
                            ^0
   59|      0|        if let Ok(file) = syn::parse2(decls.clone()) {
   60|      0|            std::fs::write(&dbg_out, prettyplease::unparse(&file)).unwrap();
   61|      0|        } else {
   62|      0|            let decls = format!("{}", &decls);
   63|      0|            std::fs::write(&dbg_out, &decls).unwrap();
   64|      0|        }
   65|      0|        quote::quote! { include!(#dbg_out); }
   66|       |    } else {
   67|      1|        decls
   68|       |    }
   69|      1|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_component_util/src/wf.rs:
    1|       |/*
    2|       |Copyright 2025 The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       | */
   16|       |
   17|       |//! Component type well-formedness
   18|       |//!
   19|       |//! This is a pretty direct port of the relevant sections of the OCaml
   20|       |//! reference interpreter.
   21|       |use itertools::Itertools;
   22|       |
   23|       |use crate::etypes::{
   24|       |    BoundedTyvar, Component, Ctx, Defined, ExternDecl, ExternDesc, Func, Handleable, Instance,
   25|       |    Name, Param, QualifiedInstance, RecordField, TypeBound, Value, VariantCase,
   26|       |};
   27|       |use crate::substitute::{Substitution, Unvoidable};
   28|       |use crate::subtype;
   29|       |
   30|       |/// The various position metadata that affect what value types are
   31|       |/// well-formed
   32|       |#[derive(Clone, Copy)]
   33|       |struct ValueTypePosition {
   34|       |    /// Is this well-formedness check for a type that is part of the
   35|       |    /// parameter type of a function? (Borrows should be allowed)
   36|       |    is_param: bool,
   37|       |    dtp: DefinedTypePosition,
   38|       |}
   39|       |
   40|       |impl From<DefinedTypePosition> for ValueTypePosition {
   41|    165|    fn from(p: DefinedTypePosition) -> ValueTypePosition {
   42|    165|        ValueTypePosition {
   43|    165|            is_param: false,
   44|    165|            dtp: p,
   45|    165|        }
   46|    165|    }
   47|       |}
   48|       |impl ValueTypePosition {
   49|     80|    fn not_anon_export(self) -> Self {
   50|     80|        ValueTypePosition {
   51|     80|            dtp: self.dtp.not_anon_export(),
   52|     80|            ..self
   53|     80|        }
   54|     80|    }
   55|  1.42k|    fn anon_export(self) -> Self {
   56|  1.42k|        ValueTypePosition {
   57|  1.42k|            dtp: self.dtp.anon_export(),
   58|  1.42k|            ..self
   59|  1.42k|        }
   60|  1.42k|    }
   61|       |}
   62|       |
   63|       |/// The various position metadata that affect what defined types are
   64|       |/// well-formed
   65|       |#[derive(Clone, Copy)]
   66|       |pub struct DefinedTypePosition {
   67|       |    /// Is this well-formedness check for a type one that should be
   68|       |    /// exportable (e.g. one that is being
   69|       |    /// exported/imported/outer-aliased-through-an-outer-boundary)?
   70|       |    /// (Bare resource types should be disallowed)
   71|       |    is_export: bool,
   72|       |    /// Is this well-formedness check for a type that should be
   73|       |    /// allowed in an "unnamed" export (i.e. nested under some other
   74|       |    /// type constructor in an export)? (Record, variant, enum, and
   75|       |    /// flags types, which must always be named in exports due to WIT
   76|       |    /// constraints, should not be allowed).
   77|       |    is_anon_export: bool,
   78|       |}
   79|       |impl DefinedTypePosition {
   80|     12|    pub fn internal() -> Self {
   81|     12|        DefinedTypePosition {
   82|     12|            is_export: false,
   83|     12|            is_anon_export: false,
   84|     12|        }
   85|     12|    }
   86|      0|    pub fn export() -> Self {
   87|      0|        DefinedTypePosition {
   88|      0|            is_export: true,
   89|      0|            is_anon_export: false,
   90|      0|        }
   91|      0|    }
   92|    200|    fn not_anon_export(self) -> Self {
   93|    200|        DefinedTypePosition {
   94|    200|            is_anon_export: false,
   95|    200|            ..self
   96|    200|        }
   97|    200|    }
   98|  1.74k|    fn anon_export(self) -> Self {
   99|  1.74k|        DefinedTypePosition {
  100|  1.74k|            is_anon_export: true,
  101|  1.74k|            ..self
  102|  1.74k|        }
  103|  1.74k|    }
  104|       |}
  105|       |
  106|       |/// There are several ways in which a type may be ill-formed:
  107|       |#[derive(Debug)]
  108|       |#[allow(dead_code)]
  109|       |pub enum Error<'a> {
  110|       |    /// A component/instance exported a bare resource type not behind
  111|       |    /// a tyvar (and therefore not named)
  112|       |    BareResourceExport,
  113|       |    /// A component/instance exported certain complex value types not
  114|       |    /// behind a tyvar (and therefore not named)
  115|       |    BareComplexValTypeExport(Value<'a>),
  116|       |    /// A record has multiple fields with the same name
  117|       |    DuplicateRecordField(Name<'a>),
  118|       |    /// A variant has multiple cases with the same name
  119|       |    DuplicateVariantField(Name<'a>),
  120|       |    /// A variant case is marked as refining another case, but that
  121|       |    /// case does not exist
  122|       |    NonexistentVariantRefinement(u32),
  123|       |    /// A variant case is marked as refining another case, but its
  124|       |    /// associated value is not a subtype of the value of the refined
  125|       |    /// case
  126|       |    IncompatibleVariantRefinement(subtype::Error<'a>),
  127|       |    /// A flags has multiple flags with the same name
  128|       |    DuplicateFlagsName(Name<'a>),
  129|       |    /// An enum has multiple cases with the same name
  130|       |    DuplicateEnumName(Name<'a>),
  131|       |    /// An import/export has the same name as another; the boolean is
  132|       |    /// true if it is an import
  133|       |    DuplicateExternName(&'a str, bool),
  134|       |    /// A value type owns or borrows a type that is not a resource type
  135|       |    NotAResource(subtype::Error<'a>),
  136|       |    /// A borrow type exists somewhere other than a function parameter
  137|       |    BorrowOutsideParam,
  138|       |}
  139|       |
  140|    275|fn error_if_duplicates_by<T, U: Eq + std::hash::Hash, E>(
  141|    275|    i: impl Iterator<Item = T>,
  142|    275|    f: impl FnMut(&T) -> U,
  143|    275|    e: impl Fn(T) -> E,
  144|    275|) -> Result<(), E> {
  145|    275|    let mut duplicates = i.duplicates_by(f);
  146|    275|    if let Some(x) = duplicates.next() {
                              ^0
  147|      0|        Err(e(x))
  148|       |    } else {
  149|    275|        Ok(())
  150|       |    }
  151|    275|}
  152|       |
  153|       |/// # Well-formedness
  154|       |///
  155|       |/// Most of this is a very direct translation of the specification
  156|       |/// (Well-formedness subsections of section 3.4 Type Elaboration).
  157|       |impl<'p, 'a> Ctx<'p, 'a> {
  158|     49|    fn wf_record_fields<'r>(
  159|     49|        &'r self,
  160|     49|        p: ValueTypePosition,
  161|     49|        rfs: &'r [RecordField<'a>],
  162|     49|    ) -> Result<(), Error<'a>> {
  163|     49|        rfs.iter()
  164|     98|            .try_for_each(|rf: &'r RecordField<'a>| self.wf_value(p, &rf.ty))?;
                                                                                          ^49^0
  165|     49|        error_if_duplicates_by(
  166|     49|            rfs.iter(),
  167|     98|            |&rf| rf.name.name,
  168|     49|            |rf| Error::DuplicateRecordField(rf.name),
                               ^0
  169|     49|        )?;
                       ^0
  170|     49|        Ok(())
  171|     49|    }
  172|     49|    fn wf_variant_cases<'r>(
  173|     49|        &'r self,
  174|     49|        p: ValueTypePosition,
  175|     49|        vcs: &'r [VariantCase<'a>],
  176|     49|    ) -> Result<(), Error<'a>> {
  177|     49|        vcs.iter()
  178|    147|            .try_for_each(|vc: &'r VariantCase<'a>| self.wf_value_option(p, &vc.ty))?;
                                                                                                 ^49^0
  179|     49|        error_if_duplicates_by(
  180|     49|            vcs.iter(),
  181|    147|            |&vc| vc.name.name,
  182|     49|            |vc| Error::DuplicateVariantField(vc.name),
                               ^0
  183|     49|        )?;
                       ^0
  184|    196|        for vc in vcs {
                          ^147
  185|    147|            if let Some(ri) = vc.refines {
                                      ^0
  186|      0|                let rvc = vcs
  187|      0|                    .get(ri as usize)
  188|      0|                    .ok_or(Error::NonexistentVariantRefinement(ri))?;
  189|      0|                self.subtype_value_option(&vc.ty, &rvc.ty)
  190|      0|                    .map_err(Error::IncompatibleVariantRefinement)?;
  191|    147|            }
  192|       |        }
  193|     49|        Ok(())
  194|     49|    }
  195|  1.42k|    fn wf_value<'r>(&'r self, p: ValueTypePosition, vt: &'r Value<'a>) -> Result<(), Error<'a>> {
  196|  1.42k|        let anon_err: Result<(), Error<'a>> = if p.dtp.is_export && p.dtp.is_anon_export {
                                                                                  ^0
  197|      0|            Err(Error::BareComplexValTypeExport(vt.clone()))
  198|       |        } else {
  199|  1.42k|            Ok(())
  200|       |        };
  201|  1.42k|        let p_ = p.anon_export();
  202|  1.42k|        let resource_err = |h| {
  203|     25|            self.wf_handleable(p.dtp, h).and(
  204|     25|                self.subtype_handleable_is_resource(h)
  205|     25|                    .map_err(Error::NotAResource),
  206|     25|            )
  207|     25|        };
  208|  1.42k|        match vt {
  209|     21|            Value::Bool => Ok(()),
  210|    128|            Value::S(_) => Ok(()),
  211|    249|            Value::U(_) => Ok(()),
  212|     64|            Value::F(_) => Ok(()),
  213|     91|            Value::Char => Ok(()),
  214|    199|            Value::String => Ok(()),
  215|     48|            Value::List(vt) => self.wf_value(p_, vt),
  216|    224|            Value::FixList(vt, _) => self.wf_value(p_, vt),
  217|     49|            Value::Record(rfs) => anon_err.and(self.wf_record_fields(p_, rfs)),
  218|     49|            Value::Variant(vcs) => anon_err.and(self.wf_variant_cases(p_, vcs)),
  219|     98|            Value::Flags(ns) => anon_err.and(error_if_duplicates_by(
  220|     98|                ns.iter(),
  221|  1.71k|                |&n| n.name,
  222|     98|                |n| Error::DuplicateFlagsName(*n),
                                  ^0
  223|     98|            )),
  224|     49|            Value::Enum(ns) => anon_err.and(error_if_duplicates_by(
  225|     49|                ns.iter(),
  226|    147|                |&n| n.name,
  227|     49|                |n| Error::DuplicateEnumName(*n),
                                  ^0
  228|     49|            )),
  229|     16|            Value::Option(vt) => self.wf_value(p_, vt),
  230|     16|            Value::Tuple(vs) => vs
  231|     16|                .iter()
  232|     32|                .try_for_each(|vt: &'r Value<'a>| self.wf_value(p_, vt)),
                                                                                     ^16
  233|     16|            Value::Result(vt1, vt2) => self
  234|     16|                .wf_value_option(p_, vt1)
  235|     16|                .and(self.wf_value_option(p_, vt2)),
  236|     20|            Value::Own(h) => resource_err(h),
  237|      5|            Value::Borrow(h) => {
  238|      5|                if p.is_param {
  239|      5|                    resource_err(h)
  240|       |                } else {
  241|      0|                    Err(Error::BorrowOutsideParam)
  242|       |                }
  243|       |            }
  244|     80|            Value::Var(tv, vt) => tv
  245|     80|                .as_ref()
  246|     80|                .map(|tv| self.wf_type_bound(p.dtp, self.var_bound(tv)))
  247|     80|                .unwrap_or(Ok(()))
  248|     80|                .and(self.wf_value(p.not_anon_export(), vt)),
  249|       |        }
  250|  1.42k|    }
  251|    179|    fn wf_value_option<'r>(
  252|    179|        &'r self,
  253|    179|        p: ValueTypePosition,
  254|    179|        vt: &'r Option<Value<'a>>,
  255|    179|    ) -> Result<(), Error<'a>> {
  256|    179|        vt.as_ref().map_or(Ok(()), |ty| self.wf_value(p, ty))
                                                      ^130
  257|    179|    }
  258|    321|    fn wf_func<'r>(&'r self, p: DefinedTypePosition, ft: &'r Func<'a>) -> Result<(), Error<'a>> {
  259|    321|        let p_ = p.anon_export();
  260|    321|        let param_pos = ValueTypePosition {
  261|    321|            is_param: true,
  262|    321|            dtp: p_,
  263|    321|        };
  264|    321|        let result_pos = ValueTypePosition {
  265|    321|            is_param: false,
  266|    321|            dtp: p_,
  267|    321|        };
  268|    321|        ft.params
  269|    321|            .iter()
  270|    326|            .try_for_each(|fp: &'r Param<'a>| self.wf_value(param_pos, &fp.ty))?;
                                                                                            ^321^0
  271|    321|        match &ft.result {
  272|    303|            Some(vt) => self.wf_value(result_pos, vt),
  273|     18|            None => Ok(()),
  274|       |        }
  275|    321|    }
  276|    150|    fn wf_type_bound<'r>(
  277|    150|        &'r self,
  278|    150|        p: DefinedTypePosition,
  279|    150|        tb: &'r TypeBound<'a>,
  280|    150|    ) -> Result<(), Error<'a>> {
  281|    150|        match tb {
  282|     30|            TypeBound::SubResource => Ok(()),
  283|    120|            TypeBound::Eq(dt) => self.wf_defined(p.not_anon_export(), dt),
  284|       |        }
  285|    150|    }
  286|     50|    fn wf_bounded_tyvar<'r>(
  287|     50|        &'r self,
  288|     50|        p: DefinedTypePosition,
  289|     50|        btv: &'r BoundedTyvar<'a>,
  290|     50|    ) -> Result<(), Error<'a>> {
  291|     50|        match &btv.bound {
  292|      5|            TypeBound::SubResource => Ok(()),
  293|     45|            TypeBound::Eq(dt) => self.wf_defined(p, dt),
  294|       |        }
  295|     50|    }
  296|       |
  297|     70|    fn wf_handleable<'r>(
  298|     70|        &'r self,
  299|     70|        p: DefinedTypePosition,
  300|     70|        ht: &'r Handleable,
  301|     70|    ) -> Result<(), Error<'a>> {
  302|     70|        match ht {
  303|     70|            Handleable::Var(tv) => self.wf_type_bound(p, self.var_bound(tv)),
  304|      0|            Handleable::Resource(rid) => {
  305|      0|                if p.is_export {
  306|      0|                    Err(Error::BareResourceExport)
  307|       |                } else {
  308|       |                    // Internal invariant: rtidx should always exist
  309|      0|                    assert!((rid.id as usize) < self.rtypes.len());
  310|      0|                    Ok(())
  311|       |                }
  312|       |            }
  313|       |        }
  314|     70|    }
  315|    210|    pub fn wf_defined<'r>(
  316|    210|        &'r self,
  317|    210|        p: DefinedTypePosition,
  318|    210|        dt: &'r Defined<'a>,
  319|    210|    ) -> Result<(), Error<'a>> {
  320|    210|        match dt {
  321|     45|            Defined::Handleable(ht) => self.wf_handleable(p, ht),
  322|    165|            Defined::Value(vt) => self.wf_value(p.into(), vt),
  323|      0|            Defined::Func(ft) => self.wf_func(p, ft),
  324|      0|            Defined::Instance(it) => self.wf_qualified_instance(p, it),
  325|      0|            Defined::Component(ct) => self.wf_component(p, ct),
  326|       |        }
  327|    210|    }
  328|    378|    fn wf_extern_desc<'r>(
  329|    378|        &self,
  330|    378|        p: DefinedTypePosition,
  331|    378|        ed: &'r ExternDesc<'a>,
  332|    378|    ) -> Result<(), Error<'a>> {
  333|    378|        match ed {
  334|      0|            ExternDesc::CoreModule(_) => Ok(()),
  335|    321|            ExternDesc::Func(ft) => self.wf_func(p, ft),
  336|     45|            ExternDesc::Type(dt) => self.wf_defined(p, dt),
  337|     11|            ExternDesc::Instance(it) => self.wf_instance(p, it),
  338|      1|            ExternDesc::Component(ct) => self.wf_component(p, ct),
  339|       |        }
  340|    378|    }
  341|    378|    fn wf_extern_decl<'r>(
  342|    378|        &self,
  343|    378|        p: DefinedTypePosition,
  344|    378|        ed: &'r ExternDecl<'a>,
  345|    378|    ) -> Result<(), Error<'a>> {
  346|    378|        self.wf_extern_desc(p, &ed.desc)
  347|    378|    }
  348|     24|    fn wf_instance<'r>(
  349|     24|        &self,
  350|     24|        p: DefinedTypePosition,
  351|     24|        it: &'r Instance<'a>,
  352|     24|    ) -> Result<(), Error<'a>> {
  353|     24|        error_if_duplicates_by(
  354|     24|            it.exports.iter(),
  355|    374|            |&ex| ex.kebab_name,
  356|     24|            |ex| Error::DuplicateExternName(ex.kebab_name, false),
                               ^0
  357|     24|        )?;
                       ^0
  358|     24|        it.exports
  359|     24|            .iter()
  360|    374|            .try_for_each(|ed| self.wf_extern_decl(p, ed))
                                                                       ^24
  361|     24|    }
  362|     13|    pub fn wf_qualified_instance<'r>(
  363|     13|        &self,
  364|     13|        p: DefinedTypePosition,
  365|     13|        qit: &'r QualifiedInstance<'a>,
  366|     13|    ) -> Result<(), Error<'a>> {
  367|     13|        let mut ctx_ = self.clone();
  368|     13|        let subst = ctx_.bound_to_evars(None, &qit.evars);
  369|     13|        ctx_.evars
  370|     13|            .iter()
  371|     38|            .try_for_each(|(btv, _)| ctx_.wf_bounded_tyvar(p, btv))?;
                                                                                ^13^0
  372|     13|        let it = subst.instance(&qit.unqualified).not_void();
  373|     13|        ctx_.wf_instance(p, &it)
  374|     13|    }
  375|      6|    pub fn wf_component<'r>(
  376|      6|        &self,
  377|      6|        p: DefinedTypePosition,
  378|      6|        ct: &'r Component<'a>,
  379|      6|    ) -> Result<(), Error<'a>> {
  380|      6|        let mut ctx_ = self.clone();
  381|      6|        let subst = ctx_.bound_to_uvars(None, &ct.uvars, false);
  382|      6|        ctx_.uvars
  383|      6|            .iter()
  384|     12|            .try_for_each(|(btv, _)| ctx_.wf_bounded_tyvar(p, btv))?;
                                                                                ^6^0
  385|      6|        error_if_duplicates_by(
  386|      6|            ct.imports.iter(),
  387|      6|            |&im| im.kebab_name,
                                ^4
  388|      6|            |im| Error::DuplicateExternName(im.kebab_name, true),
                               ^0
  389|      6|        )?;
                       ^0
  390|      6|        ct.imports
  391|      6|            .iter()
  392|      6|            .map(|ed| subst.extern_decl(ed).not_void())
                                    ^4
  393|      6|            .try_for_each(|ed| ctx_.wf_extern_decl(p, &ed))?;
                                             ^4                          ^0
  394|      6|        let it = subst.qualified_instance(&ct.instance).not_void();
  395|      6|        ctx_.wf_qualified_instance(p, &it)
  396|      6|    }
  397|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/error.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(mshv2)]
   18|       |extern crate mshv_ioctls2 as mshv_ioctls;
   19|       |
   20|       |#[cfg(mshv3)]
   21|       |extern crate mshv_ioctls3 as mshv_ioctls;
   22|       |
   23|       |use std::array::TryFromSliceError;
   24|       |use std::cell::{BorrowError, BorrowMutError};
   25|       |use std::convert::Infallible;
   26|       |use std::error::Error;
   27|       |use std::num::TryFromIntError;
   28|       |use std::string::FromUtf8Error;
   29|       |use std::sync::{MutexGuard, PoisonError};
   30|       |use std::time::SystemTimeError;
   31|       |
   32|       |#[cfg(target_os = "windows")]
   33|       |use crossbeam_channel::{RecvError, SendError};
   34|       |use flatbuffers::InvalidFlatbuffer;
   35|       |use hyperlight_common::flatbuffer_wrappers::function_types::{ParameterValue, ReturnValue};
   36|       |use hyperlight_common::flatbuffer_wrappers::guest_error::ErrorCode;
   37|       |use thiserror::Error;
   38|       |
   39|       |#[cfg(target_os = "windows")]
   40|       |use crate::hypervisor::wrappers::HandleWrapper;
   41|       |use crate::mem::memory_region::MemoryRegionFlags;
   42|       |use crate::mem::ptr::RawPtr;
   43|       |
   44|       |/// The error type for Hyperlight operations
   45|       |#[derive(Error, Debug)]
   46|       |pub enum HyperlightError {
   47|       |    /// Anyhow error
   48|       |    #[error("Anyhow Error was returned: {0}")]
   49|       |    AnyhowError(#[from] anyhow::Error),
   50|       |    /// Memory access out of bounds
   51|       |    #[error("Offset: {0} out of bounds, Max is: {1}")]
   52|       |    BoundsCheckFailed(u64, usize),
   53|       |
   54|       |    /// Checked Add Overflow
   55|       |    #[error("Couldn't add offset to base address. Offset: {0}, Base Address: {1}")]
   56|       |    CheckedAddOverflow(u64, u64),
   57|       |
   58|       |    /// Cross beam channel receive error
   59|       |    #[error("{0:?}")]
   60|       |    #[cfg(target_os = "windows")]
   61|       |    CrossBeamReceiveError(#[from] RecvError),
   62|       |
   63|       |    /// Cross beam channel send error
   64|       |    #[error("{0:?}")]
   65|       |    #[cfg(target_os = "windows")]
   66|       |    CrossBeamSendError(#[from] SendError<HandleWrapper>),
   67|       |
   68|       |    /// CString conversion error
   69|       |    #[error("Error converting CString {0:?}")]
   70|       |    CStringConversionError(#[from] std::ffi::NulError),
   71|       |
   72|       |    /// A disallowed syscall was caught
   73|       |    #[error("Seccomp filter trapped on disallowed syscall (check STDERR for offending syscall)")]
   74|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
   75|       |    DisallowedSyscall,
   76|       |
   77|       |    /// A generic error with a message
   78|       |    #[error("{0}")]
   79|       |    Error(String),
   80|       |
   81|       |    /// Execution violation
   82|       |    #[error("Non-executable address {0:#x} tried to be executed")]
   83|       |    ExecutionAccessViolation(u64),
   84|       |
   85|       |    /// Guest execution was cancelled by the host
   86|       |    #[error("Execution was cancelled by the host.")]
   87|       |    ExecutionCanceledByHost(),
   88|       |
   89|       |    /// Accessing the value of a flatbuffer parameter failed
   90|       |    #[error("Failed to get a value from flat buffer parameter")]
   91|       |    FailedToGetValueFromParameter(),
   92|       |
   93|       |    ///Field Name not found in decoded GuestLogData
   94|       |    #[error("Field Name {0} not found in decoded GuestLogData")]
   95|       |    FieldIsMissingInGuestLogData(String),
   96|       |
   97|       |    /// Guest aborted during outb
   98|       |    #[error("Guest aborted: {0} {1}")]
   99|       |    GuestAborted(u8, String),
  100|       |
  101|       |    /// Guest call resulted in error in guest
  102|       |    #[error("Guest error occurred {0:?}: {1}")]
  103|       |    GuestError(ErrorCode, String),
  104|       |
  105|       |    /// An attempt to cancel guest execution failed because it is hanging on a host function call
  106|       |    #[error("Guest execution hung on the execution of a host function call")]
  107|       |    GuestExecutionHungOnHostFunctionCall(),
  108|       |
  109|       |    /// Guest call already in progress
  110|       |    #[error("Guest call is already in progress")]
  111|       |    GuestFunctionCallAlreadyInProgress(),
  112|       |
  113|       |    /// The given type is not supported by the guest interface.
  114|       |    #[error("Unsupported type: {0}")]
  115|       |    GuestInterfaceUnsupportedType(String),
  116|       |
  117|       |    /// The guest offset is invalid.
  118|       |    #[error("The guest offset {0} is invalid.")]
  119|       |    GuestOffsetIsInvalid(usize),
  120|       |
  121|       |    /// A Host function was called by the guest but it was not registered.
  122|       |    #[error("HostFunction {0} was not found")]
  123|       |    HostFunctionNotFound(String),
  124|       |
  125|       |    /// Reading Writing or Seeking data failed.
  126|       |    #[error("Reading Writing or Seeking data failed {0:?}")]
  127|       |    IOError(#[from] std::io::Error),
  128|       |
  129|       |    /// Failed to convert to Integer
  130|       |    #[error("Failed To Convert Size to usize")]
  131|       |    IntConversionFailure(#[from] TryFromIntError),
  132|       |
  133|       |    /// The flatbuffer is invalid
  134|       |    #[error("The flatbuffer is invalid")]
  135|       |    InvalidFlatBuffer(#[from] InvalidFlatbuffer),
  136|       |
  137|       |    /// Conversion of str to Json failed
  138|       |    #[error("Conversion of str data to json failed")]
  139|       |    JsonConversionFailure(#[from] serde_json::Error),
  140|       |
  141|       |    /// KVM Error Occurred
  142|       |    #[error("KVM Error {0:?}")]
  143|       |    #[cfg(kvm)]
  144|       |    KVMError(#[from] kvm_ioctls::Error),
  145|       |
  146|       |    /// An attempt to get a lock from a Mutex failed.
  147|       |    #[error("Unable to lock resource")]
  148|       |    LockAttemptFailed(String),
  149|       |
  150|       |    /// Memory Access Violation at the given address. The access type and memory region flags are provided.
  151|       |    #[error("Memory Access Violation at address {0:#x} of type {1}, but memory is marked as {2}")]
  152|       |    MemoryAccessViolation(u64, MemoryRegionFlags, MemoryRegionFlags),
  153|       |
  154|       |    /// Memory Allocation Failed.
  155|       |    #[error("Memory Allocation Failed with OS Error {0:?}.")]
  156|       |    MemoryAllocationFailed(Option<i32>),
  157|       |
  158|       |    /// Memory Protection Failed
  159|       |    #[error("Memory Protection Failed with OS Error {0:?}.")]
  160|       |    MemoryProtectionFailed(Option<i32>),
  161|       |
  162|       |    /// The memory request exceeds the maximum size allowed
  163|       |    #[error("Memory requested {0} exceeds maximum size allowed {1}")]
  164|       |    MemoryRequestTooBig(usize, usize),
  165|       |
  166|       |    /// Metric Not Found.
  167|       |    #[error("Metric Not Found {0:?}.")]
  168|       |    MetricNotFound(&'static str),
  169|       |
  170|       |    /// mmap Failed.
  171|       |    #[error("mmap failed with os error {0:?}")]
  172|       |    MmapFailed(Option<i32>),
  173|       |
  174|       |    /// mprotect Failed.
  175|       |    #[error("mprotect failed with os error {0:?}")]
  176|       |    MprotectFailed(Option<i32>),
  177|       |
  178|       |    /// mshv Error Occurred
  179|       |    #[error("mshv Error {0:?}")]
  180|       |    #[cfg(mshv)]
  181|       |    MSHVError(#[from] mshv_ioctls::MshvError),
  182|       |
  183|       |    /// No Hypervisor was found for Sandbox.
  184|       |    #[error("No Hypervisor was found for Sandbox")]
  185|       |    NoHypervisorFound(),
  186|       |
  187|       |    /// Restore_state called with no valid snapshot
  188|       |    #[error("Restore_state called with no valid snapshot")]
  189|       |    NoMemorySnapshot,
  190|       |
  191|       |    /// Failed to get value from parameter value
  192|       |    #[error("Failed To Convert Parameter Value {0:?} to {1:?}")]
  193|       |    ParameterValueConversionFailure(ParameterValue, &'static str),
  194|       |
  195|       |    /// a failure occurred processing a PE file
  196|       |    #[error("Failure processing PE File {0:?}")]
  197|       |    PEFileProcessingFailure(#[from] goblin::error::Error),
  198|       |
  199|       |    /// Raw pointer is less than base address
  200|       |    #[error("Raw pointer ({0:?}) was less than the base address ({1})")]
  201|       |    RawPointerLessThanBaseAddress(RawPtr, u64),
  202|       |
  203|       |    /// RefCell borrow failed
  204|       |    #[error("RefCell borrow failed")]
  205|       |    RefCellBorrowFailed(#[from] BorrowError),
  206|       |
  207|       |    /// RefCell mut borrow failed
  208|       |    #[error("RefCell mut borrow failed")]
  209|       |    RefCellMutBorrowFailed(#[from] BorrowMutError),
  210|       |
  211|       |    /// Failed to get value from return value
  212|       |    #[error("Failed To Convert Return Value {0:?} to {1:?}")]
  213|       |    ReturnValueConversionFailure(ReturnValue, &'static str),
  214|       |
  215|       |    /// Stack overflow detected in guest
  216|       |    #[error("Stack overflow detected")]
  217|       |    StackOverflow(),
  218|       |
  219|       |    /// a backend error occurred with seccomp filters
  220|       |    #[error("Backend Error with Seccomp Filter {0:?}")]
  221|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
  222|       |    SeccompFilterBackendError(#[from] seccompiler::BackendError),
  223|       |
  224|       |    /// an error occurred with seccomp filters
  225|       |    #[error("Error with Seccomp Filter {0:?}")]
  226|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
  227|       |    SeccompFilterError(#[from] seccompiler::Error),
  228|       |
  229|       |    /// Tried to restore snapshot to a sandbox that is not the same as the one the snapshot was taken from
  230|       |    #[error("Snapshot was taken from a different sandbox")]
  231|       |    SnapshotSandboxMismatch,
  232|       |
  233|       |    /// SystemTimeError
  234|       |    #[error("SystemTimeError {0:?}")]
  235|       |    SystemTimeError(#[from] SystemTimeError),
  236|       |
  237|       |    /// Error occurred when translating guest address
  238|       |    #[error("An error occurred when translating guest address: {0:?}")]
  239|       |    #[cfg(gdb)]
  240|       |    TranslateGuestAddress(u64),
  241|       |
  242|       |    /// Error occurred converting a slice to an array
  243|       |    #[error("TryFromSliceError {0:?}")]
  244|       |    TryFromSliceError(#[from] TryFromSliceError),
  245|       |
  246|       |    /// A function was called with an incorrect number of arguments
  247|       |    #[error("The number of arguments to the function is wrong: got {0:?} expected {1:?}")]
  248|       |    UnexpectedNoOfArguments(usize, usize),
  249|       |
  250|       |    /// The parameter value type is unexpected
  251|       |    #[error("The parameter value type is unexpected got {0:?} expected {1:?}")]
  252|       |    UnexpectedParameterValueType(ParameterValue, String),
  253|       |
  254|       |    /// The return value type is unexpected
  255|       |    #[error("The return value type is unexpected got {0:?} expected {1:?}")]
  256|       |    UnexpectedReturnValueType(ReturnValue, String),
  257|       |
  258|       |    /// Slice conversion to UTF8 failed
  259|       |    #[error("String Conversion of UTF8 data to str failed")]
  260|       |    UTF8StringConversionFailure(#[from] FromUtf8Error),
  261|       |
  262|       |    /// The capacity of the vector is incorrect
  263|       |    #[error(
  264|       |        "The capacity of the vector is incorrect. Capacity: {0}, Length: {1}, FlatBuffer Size: {2}"
  265|       |    )]
  266|       |    VectorCapacityIncorrect(usize, usize, i32),
  267|       |
  268|       |    /// vmm sys Error Occurred
  269|       |    #[error("vmm sys Error {0:?}")]
  270|       |    #[cfg(target_os = "linux")]
  271|       |    VmmSysError(vmm_sys_util::errno::Error),
  272|       |
  273|       |    /// Windows Error
  274|       |    #[cfg(target_os = "windows")]
  275|       |    #[error("Windows API Error Result {0:?}")]
  276|       |    WindowsAPIError(#[from] windows_result::Error),
  277|       |}
  278|       |
  279|       |impl From<Infallible> for HyperlightError {
  280|      0|    fn from(_: Infallible) -> Self {
  281|      0|        "Impossible as this is an infallible error".into()
  282|      0|    }
  283|       |}
  284|       |
  285|       |impl From<&str> for HyperlightError {
  286|      0|    fn from(s: &str) -> Self {
  287|      0|        HyperlightError::Error(s.to_string())
  288|      0|    }
  289|       |}
  290|       |
  291|       |impl<T> From<PoisonError<MutexGuard<'_, T>>> for HyperlightError {
  292|       |    // Implemented this way rather than passing the error as a source to LockAttemptFailed as that would require
  293|       |    // Box<dyn Error + Send + Sync> which is not easy to implement for PoisonError<MutexGuard<'_, T>>
  294|       |    // This is a good enough solution and allows use to use the ? operator on lock() calls
  295|      0|    fn from(e: PoisonError<MutexGuard<'_, T>>) -> Self {
  296|      0|        let source = match e.source() {
  297|      0|            Some(s) => s.to_string(),
  298|      0|            None => String::from(""),
  299|       |        };
  300|      0|        HyperlightError::LockAttemptFailed(source)
  301|      0|    }
  302|       |}
  303|       |
  304|       |/// Creates a `HyperlightError::Error` from a string literal or format string
  305|       |#[macro_export]
  306|       |macro_rules! new_error {
  307|       |    ($msg:literal $(,)?) => {{
  308|       |        let __args = std::format_args!($msg);
  309|       |        let __err_msg = match __args.as_str() {
  310|       |            Some(msg) => String::from(msg),
  311|       |            None => std::format!($msg),
  312|       |        };
  313|       |        $crate::HyperlightError::Error(__err_msg)
  314|       |    }};
  315|       |    ($fmtstr:expr, $($arg:tt)*) => {{
  316|       |           let __err_msg = std::format!($fmtstr, $($arg)*);
  317|       |           $crate::error::HyperlightError::Error(__err_msg)
  318|       |    }};
  319|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/func/guest_err.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use hyperlight_common::flatbuffer_wrappers::guest_error::ErrorCode;
   18|       |
   19|       |use crate::error::HyperlightError::{GuestError, StackOverflow};
   20|       |use crate::mem::shared_mem::HostSharedMemory;
   21|       |use crate::metrics::{METRIC_GUEST_ERROR, METRIC_GUEST_ERROR_LABEL_CODE};
   22|       |use crate::sandbox::mem_mgr::MemMgrWrapper;
   23|       |use crate::{Result, log_then_return};
   24|       |
   25|       |/// Check for a guest error and return an `Err` if one was found,
   26|       |/// and `Ok` if one was not found.
   27|      0|pub(crate) fn check_for_guest_error(mgr: &mut MemMgrWrapper<HostSharedMemory>) -> Result<()> {
   28|      0|    let guest_err = mgr.as_mut().get_guest_error().ok();
   29|      0|    let Some(guest_err) = guest_err else {
   30|      0|        return Ok(());
   31|       |    };
   32|       |
   33|      0|    metrics::counter!(
   34|      0|        METRIC_GUEST_ERROR,
   35|      0|        METRIC_GUEST_ERROR_LABEL_CODE => (guest_err.code as u64).to_string()
   36|      0|    )
   37|      0|    .increment(1);
   38|      0|
   39|      0|    match guest_err.code {
   40|      0|        ErrorCode::NoError => Ok(()),
   41|       |        ErrorCode::StackOverflow => {
   42|      0|            log_then_return!(StackOverflow());
   43|       |        }
   44|       |        _ => {
   45|      0|            log_then_return!(GuestError(guest_err.code, guest_err.message.clone()));
   46|       |        }
   47|       |    }
   48|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/func/host_functions.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::sync::{Arc, Mutex};
   18|       |
   19|       |use hyperlight_common::flatbuffer_wrappers::function_types::{ParameterValue, ReturnValue};
   20|       |
   21|       |use super::utils::for_each_tuple;
   22|       |use super::{ParameterTuple, ResultType, SupportedReturnType};
   23|       |use crate::sandbox::host_funcs::FunctionEntry;
   24|       |use crate::sandbox::{ExtraAllowedSyscall, UninitializedSandbox};
   25|       |use crate::{Result, new_error};
   26|       |
   27|       |/// A sandbox on which (primitive) host functions can be registered
   28|       |///
   29|       |pub trait Registerable {
   30|       |    /// Register a primitive host function
   31|       |    fn register_host_function<Args: ParameterTuple, Output: SupportedReturnType>(
   32|       |        &mut self,
   33|       |        name: &str,
   34|       |        hf: impl Into<HostFunction<Output, Args>>,
   35|       |    ) -> Result<()>;
   36|       |    /// Register a primitive host function whose worker thread has
   37|       |    /// extra permissive seccomp filters installed
   38|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
   39|       |    fn register_host_function_with_syscalls<Args: ParameterTuple, Output: SupportedReturnType>(
   40|       |        &mut self,
   41|       |        name: &str,
   42|       |        hf: impl Into<HostFunction<Output, Args>>,
   43|       |        eas: Vec<ExtraAllowedSyscall>,
   44|       |    ) -> Result<()>;
   45|       |}
   46|       |impl Registerable for UninitializedSandbox {
   47|      0|    fn register_host_function<Args: ParameterTuple, Output: SupportedReturnType>(
   48|      0|        &mut self,
   49|      0|        name: &str,
   50|      0|        hf: impl Into<HostFunction<Output, Args>>,
   51|      0|    ) -> Result<()> {
   52|      0|        let mut hfs = self
   53|      0|            .host_funcs
   54|      0|            .try_lock()
   55|      0|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
   56|       |
   57|      0|        let entry = FunctionEntry {
   58|      0|            function: hf.into().into(),
   59|      0|            extra_allowed_syscalls: None,
   60|      0|            parameter_types: Args::TYPE,
   61|      0|            return_type: Output::TYPE,
   62|      0|        };
   63|      0|
   64|      0|        (*hfs).register_host_function(name.to_string(), entry, self.mgr.unwrap_mgr_mut())
   65|      0|    }
   66|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
   67|      0|    fn register_host_function_with_syscalls<Args: ParameterTuple, Output: SupportedReturnType>(
   68|      0|        &mut self,
   69|      0|        name: &str,
   70|      0|        hf: impl Into<HostFunction<Output, Args>>,
   71|      0|        eas: Vec<ExtraAllowedSyscall>,
   72|      0|    ) -> Result<()> {
   73|      0|        let mut hfs = self
   74|      0|            .host_funcs
   75|      0|            .try_lock()
   76|      0|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
   77|       |
   78|      0|        let entry = FunctionEntry {
   79|      0|            function: hf.into().into(),
   80|      0|            extra_allowed_syscalls: Some(eas),
   81|      0|            parameter_types: Args::TYPE,
   82|      0|            return_type: Output::TYPE,
   83|      0|        };
   84|      0|
   85|      0|        (*hfs).register_host_function(name.to_string(), entry, self.mgr.unwrap_mgr_mut())
   86|      0|    }
   87|       |}
   88|       |
   89|       |/// A representation of a host function.
   90|       |/// This is a thin wrapper around a `Fn(Args) -> Result<Output>`.
   91|       |#[derive(Clone)]
   92|       |pub struct HostFunction<Output, Args>
   93|       |where
   94|       |    Args: ParameterTuple,
   95|       |    Output: SupportedReturnType,
   96|       |{
   97|       |    // This is a thin wrapper around a `Fn(Args) -> Result<Output>`.
   98|       |    // But unlike `Fn` which is a trait, this is a concrete type.
   99|       |    // This allows us to:
  100|       |    //  1. Impose constraints on the function arguments and return type.
  101|       |    //  2. Impose a single function signature.
  102|       |    //
  103|       |    // This second point is important because the `Fn` trait is generic
  104|       |    // over the function arguments (with an associated return type).
  105|       |    // This means that a given type could implement `Fn` for multiple
  106|       |    // function signatures.
  107|       |    // This means we can't do something like:
  108|       |    // ```rust,ignore
  109|       |    // impl<Args, Output, F> SomeTrait for F
  110|       |    // where
  111|       |    //     F: Fn(Args) -> Result<Output>,
  112|       |    // { ... }
  113|       |    // ```
  114|       |    // because the concrete type F might implement `Fn` for multiple times,
  115|       |    // and that would means implementing `SomeTrait` multiple times for the
  116|       |    // same type.
  117|       |
  118|       |    // Use Arc in here instead of Box because it's useful in tests and
  119|       |    // presumably in other places to be able to clone a HostFunction and
  120|       |    // use it across different sandboxes.
  121|       |    func: Arc<dyn Fn(Args) -> Result<Output> + Send + Sync + 'static>,
  122|       |}
  123|       |
  124|       |pub(crate) struct TypeErasedHostFunction {
  125|       |    func: Box<dyn Fn(Vec<ParameterValue>) -> Result<ReturnValue> + Send + Sync + 'static>,
  126|       |}
  127|       |
  128|       |impl<Args, Output> HostFunction<Output, Args>
  129|       |where
  130|       |    Args: ParameterTuple,
  131|       |    Output: SupportedReturnType,
  132|       |{
  133|       |    /// Call the host function with the given arguments.
  134|     23|    pub fn call(&self, args: Args) -> Result<Output> {
  135|     23|        (self.func)(args)
  136|     23|    }
  137|       |}
  138|       |
  139|       |impl TypeErasedHostFunction {
  140|     23|    pub(crate) fn call(&self, args: Vec<ParameterValue>) -> Result<ReturnValue> {
  141|     23|        (self.func)(args)
  142|     23|    }
  143|       |}
  144|       |
  145|       |impl<Args, Output> From<HostFunction<Output, Args>> for TypeErasedHostFunction
  146|       |where
  147|       |    Args: ParameterTuple,
  148|       |    Output: SupportedReturnType,
  149|       |{
  150|     71|    fn from(func: HostFunction<Output, Args>) -> TypeErasedHostFunction {
  151|     71|        TypeErasedHostFunction {
  152|     71|            func: Box::new(move |args: Vec<ParameterValue>| {
                                                                          ^23
  153|     23|                let args = Args::from_value(args)?;
                                                               ^0
  154|     23|                Ok(func.call(args)?.into_value())
                                                ^0
  155|     71|            }),
                          ^23
  156|     71|        }
  157|     71|    }
  158|       |}
  159|       |
  160|       |macro_rules! impl_host_function {
  161|       |    ([$N:expr] ($($p:ident: $P:ident),*)) => {
  162|       |        /*
  163|       |        // Normally for a `Fn + Send + Sync` we don't need to use a Mutex
  164|       |        // like we do in the case of a `FnMut`.
  165|       |        // However, we can't implement `IntoHostFunction` for `Fn` and `FnMut`
  166|       |        // because `FnMut` is a supertrait of `Fn`.
  167|       |        */
  168|       |
  169|       |        impl<F, R, $($P),*> From<F> for HostFunction<R::ReturnType, ($($P,)*)>
  170|       |        where
  171|       |            F: FnMut($($P),*) -> R + Send + 'static,
  172|       |            ($($P,)*): ParameterTuple,
  173|       |            R: ResultType,
  174|       |        {
  175|     71|            fn from(mut func: F) -> HostFunction<R::ReturnType, ($($P,)*)> {
  176|     71|                let func = move |($($p,)*): ($($P,)*)| -> Result<R::ReturnType> {
  177|     23|                    func($($p),*).into_result()
  178|     23|                };
  179|     71|                let func = Mutex::new(func);
  180|     71|                HostFunction {
  181|     71|                    func: Arc::new(move |args: ($($P,)*)| {
  182|     23|                        func.try_lock()
  183|     23|                            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?
                                                       ^0                                                            ^0
  184|     23|                            (args)
  185|     71|                    })
                                  ^23
  186|     71|                }
  187|     71|            }
  188|       |        }
  189|       |    };
  190|       |}
  191|       |
  192|       |for_each_tuple!(impl_host_function);
  193|       |
  194|     71|pub(crate) fn register_host_function<Args: ParameterTuple, Output: SupportedReturnType>(
  195|     71|    func: impl Into<HostFunction<Output, Args>>,
  196|     71|    sandbox: &mut UninitializedSandbox,
  197|     71|    name: &str,
  198|     71|    extra_allowed_syscalls: Option<Vec<ExtraAllowedSyscall>>,
  199|     71|) -> Result<()> {
  200|     71|    let func = func.into().into();
  201|     71|
  202|     71|    let entry = FunctionEntry {
  203|     71|        function: func,
  204|     71|        extra_allowed_syscalls: extra_allowed_syscalls.clone(),
  205|     71|        parameter_types: Args::TYPE,
  206|     71|        return_type: Output::TYPE,
  207|     71|    };
  208|     71|
  209|     71|    sandbox
  210|     71|        .host_funcs
  211|     71|        .try_lock()
  212|     71|        .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?
                                   ^0                                                            ^0
  213|     71|        .register_host_function(name.to_string(), entry, sandbox.mgr.unwrap_mgr_mut())?;
                                                                                                    ^0
  214|       |
  215|     71|    Ok(())
  216|     71|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/func/param_type.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use hyperlight_common::flatbuffer_wrappers::function_types::{ParameterType, ParameterValue};
   18|       |use tracing::{Span, instrument};
   19|       |
   20|       |use super::utils::for_each_tuple;
   21|       |use crate::HyperlightError::{ParameterValueConversionFailure, UnexpectedNoOfArguments};
   22|       |use crate::{Result, log_then_return};
   23|       |
   24|       |/// This is a marker trait that is used to indicate that a type is a
   25|       |/// valid Hyperlight parameter type.
   26|       |///
   27|       |/// For each parameter type Hyperlight supports in host functions, we
   28|       |/// provide an implementation for `SupportedParameterType`
   29|       |pub trait SupportedParameterType: Sized + Clone + Send + Sync + 'static {
   30|       |    /// The underlying Hyperlight parameter type representing this `SupportedParameterType`
   31|       |    const TYPE: ParameterType;
   32|       |
   33|       |    /// Get the underling Hyperlight parameter value representing this
   34|       |    /// `SupportedParameterType`
   35|       |    fn into_value(self) -> ParameterValue;
   36|       |    /// Get the actual inner value of this `SupportedParameterType`
   37|       |    fn from_value(value: ParameterValue) -> Result<Self>;
   38|       |}
   39|       |
   40|       |// We can then implement these traits for each type that Hyperlight supports as a parameter or return type
   41|       |macro_rules! for_each_param_type {
   42|       |    ($macro:ident) => {
   43|       |        $macro!(String, String);
   44|       |        $macro!(i32, Int);
   45|       |        $macro!(u32, UInt);
   46|       |        $macro!(i64, Long);
   47|       |        $macro!(u64, ULong);
   48|       |        $macro!(f32, Float);
   49|       |        $macro!(f64, Double);
   50|       |        $macro!(bool, Bool);
   51|       |        $macro!(Vec<u8>, VecBytes);
   52|       |    };
   53|       |}
   54|       |
   55|       |macro_rules! impl_supported_param_type {
   56|       |    ($type:ty, $enum:ident) => {
   57|       |        impl SupportedParameterType for $type {
   58|       |            const TYPE: ParameterType = ParameterType::$enum;
   59|       |
   60|       |            #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   61|      0|            fn into_value(self) -> ParameterValue {
   62|      0|                ParameterValue::$enum(self)
   63|      0|            }
   64|       |
   65|       |            #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   66|     23|            fn from_value(value: ParameterValue) -> Result<Self> {
   67|     23|                match value {
   68|       |                    ParameterValue::$enum(i) => Ok(i),
   69|       |                    other => {
   70|       |                        log_then_return!(ParameterValueConversionFailure(
   71|       |                            other.clone(),
   72|       |                            stringify!($type)
   73|       |                        ));
   74|       |                    }
   75|       |                }
   76|     23|            }
   77|       |        }
   78|       |    };
   79|       |}
   80|       |
   81|       |for_each_param_type!(impl_supported_param_type);
   82|       |
   83|       |/// A trait to describe the tuple of parameters that a host function can take.
   84|       |pub trait ParameterTuple: Sized + Clone + Send + Sync + 'static {
   85|       |    /// The number of parameters in the tuple
   86|       |    const SIZE: usize;
   87|       |
   88|       |    /// The underlying Hyperlight parameter types representing this tuple of `SupportedParameterType`
   89|       |    const TYPE: &[ParameterType];
   90|       |
   91|       |    /// Get the underling Hyperlight parameter value representing this
   92|       |    /// `SupportedParameterType`
   93|       |    fn into_value(self) -> Vec<ParameterValue>;
   94|       |
   95|       |    /// Get the actual inner value of this `SupportedParameterType`
   96|       |    fn from_value(value: Vec<ParameterValue>) -> Result<Self>;
   97|       |}
   98|       |
   99|       |impl<T: SupportedParameterType> ParameterTuple for T {
  100|       |    const SIZE: usize = 1;
  101|       |
  102|       |    const TYPE: &[ParameterType] = &[T::TYPE];
  103|       |
  104|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  105|      0|    fn into_value(self) -> Vec<ParameterValue> {
  106|      0|        vec![self.into_value()]
  107|      0|    }
  108|       |
  109|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  110|      0|    fn from_value(value: Vec<ParameterValue>) -> Result<Self> {
  111|       |        match <[ParameterValue; 1]>::try_from(value) {
  112|       |            Ok([val]) => Ok(T::from_value(val)?),
  113|       |            Err(value) => {
  114|       |                log_then_return!(UnexpectedNoOfArguments(value.len(), 1));
  115|       |            }
  116|       |        }
  117|      0|    }
  118|       |}
  119|       |
  120|       |macro_rules! impl_param_tuple {
  121|       |    ([$N:expr] ($($name:ident: $param:ident),*)) => {
  122|       |        impl<$($param: SupportedParameterType),*> ParameterTuple for ($($param,)*) {
  123|       |            const SIZE: usize = $N;
  124|       |
  125|       |            const TYPE: &[ParameterType] = &[
  126|       |                $($param::TYPE),*
  127|       |            ];
  128|       |
  129|       |            #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  130|      0|            fn into_value(self) -> Vec<ParameterValue> {
  131|      0|                let ($($name,)*) = self;
  132|      0|                vec![$($name.into_value()),*]
  133|      0|            }
  134|       |
  135|       |            #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  136|     23|            fn from_value(value: Vec<ParameterValue>) -> Result<Self> {
  137|       |                match <[ParameterValue; $N]>::try_from(value) {
  138|       |                    Ok([$($name,)*]) => Ok(($($param::from_value($name)?,)*)),
  139|       |                    Err(value) => { log_then_return!(UnexpectedNoOfArguments(value.len(), $N)); }
  140|       |                }
  141|     23|            }
  142|       |        }
  143|       |    };
  144|       |}
  145|       |
  146|       |for_each_tuple!(impl_param_tuple);

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/func/ret_type.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use hyperlight_common::flatbuffer_wrappers::function_types::{ReturnType, ReturnValue};
   18|       |use tracing::{Span, instrument};
   19|       |
   20|       |use crate::HyperlightError::ReturnValueConversionFailure;
   21|       |use crate::{Result, log_then_return};
   22|       |
   23|       |/// This is a marker trait that is used to indicate that a type is a valid Hyperlight return type.
   24|       |pub trait SupportedReturnType: Sized + Clone + Send + Sync + 'static {
   25|       |    /// The return type of the supported return value
   26|       |    const TYPE: ReturnType;
   27|       |
   28|       |    /// Gets the value of the supported return value
   29|       |    fn into_value(self) -> ReturnValue;
   30|       |
   31|       |    /// Gets the inner value of the supported return type
   32|       |    fn from_value(value: ReturnValue) -> Result<Self>;
   33|       |}
   34|       |
   35|       |/// A trait to handle either a [`SupportedReturnType`] or a [`Result<impl SupportedReturnType>`]
   36|       |pub trait ResultType {
   37|       |    /// The return type of the supported return value
   38|       |    type ReturnType: SupportedReturnType;
   39|       |
   40|       |    /// Convert the return type into a `Result<impl SupportedReturnType>`
   41|       |    fn into_result(self) -> Result<Self::ReturnType>;
   42|       |}
   43|       |
   44|       |macro_rules! for_each_return_type {
   45|       |    ($macro:ident) => {
   46|       |        $macro!((), Void);
   47|       |        $macro!(String, String);
   48|       |        $macro!(i32, Int);
   49|       |        $macro!(u32, UInt);
   50|       |        $macro!(i64, Long);
   51|       |        $macro!(u64, ULong);
   52|       |        $macro!(f32, Float);
   53|       |        $macro!(f64, Double);
   54|       |        $macro!(bool, Bool);
   55|       |        $macro!(Vec<u8>, VecBytes);
   56|       |    };
   57|       |}
   58|       |
   59|       |macro_rules! impl_supported_return_type {
   60|       |    ($type:ty, $enum:ident) => {
   61|       |        impl SupportedReturnType for $type {
   62|       |            const TYPE: ReturnType = ReturnType::$enum;
   63|       |
   64|       |            #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   65|     23|            fn into_value(self) -> ReturnValue {
   66|     23|                ReturnValue::$enum(self)
   67|     23|            }
   68|       |
   69|       |            #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   70|      0|            fn from_value(value: ReturnValue) -> Result<Self> {
   71|      0|                match value {
   72|       |                    ReturnValue::$enum(i) => Ok(i),
   73|       |                    other => {
   74|       |                        log_then_return!(ReturnValueConversionFailure(
   75|       |                            other.clone(),
   76|       |                            stringify!($type)
   77|       |                        ));
   78|       |                    }
   79|       |                }
   80|      0|            }
   81|       |        }
   82|       |
   83|       |        impl ResultType for $type {
   84|       |            type ReturnType = $type;
   85|       |
   86|       |            #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   87|      0|            fn into_result(self) -> Result<Self::ReturnType> {
   88|       |                Ok(self)
   89|      0|            }
   90|       |        }
   91|       |
   92|       |        impl ResultType for Result<$type> {
   93|       |            type ReturnType = $type;
   94|       |
   95|       |            #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   96|     23|            fn into_result(self) -> Result<Self::ReturnType> {
   97|       |                self
   98|     23|            }
   99|       |        }
  100|       |    };
  101|       |}
  102|       |
  103|       |for_each_return_type!(impl_supported_return_type);

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/hypervisor/hyperv_linux.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(mshv2)]
   18|       |extern crate mshv_bindings2 as mshv_bindings;
   19|       |#[cfg(mshv2)]
   20|       |extern crate mshv_ioctls2 as mshv_ioctls;
   21|       |
   22|       |#[cfg(mshv3)]
   23|       |extern crate mshv_bindings3 as mshv_bindings;
   24|       |#[cfg(mshv3)]
   25|       |extern crate mshv_ioctls3 as mshv_ioctls;
   26|       |
   27|       |use std::fmt::{Debug, Formatter};
   28|       |use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
   29|       |use std::sync::{Arc, Mutex};
   30|       |
   31|       |use log::{LevelFilter, error};
   32|       |#[cfg(mshv2)]
   33|       |use mshv_bindings::hv_message;
   34|       |use mshv_bindings::{
   35|       |    FloatingPointUnit, SegmentRegister, SpecialRegisters, StandardRegisters, hv_message_type,
   36|       |    hv_message_type_HVMSG_GPA_INTERCEPT, hv_message_type_HVMSG_UNMAPPED_GPA,
   37|       |    hv_message_type_HVMSG_X64_HALT, hv_message_type_HVMSG_X64_IO_PORT_INTERCEPT, hv_register_assoc,
   38|       |    hv_register_name_HV_X64_REGISTER_RIP, hv_register_value, mshv_user_mem_region,
   39|       |};
   40|       |#[cfg(gdb)]
   41|       |use mshv_bindings::{
   42|       |    HV_INTERCEPT_ACCESS_MASK_EXECUTE, hv_intercept_parameters,
   43|       |    hv_intercept_type_HV_INTERCEPT_TYPE_EXCEPTION, hv_message_type_HVMSG_X64_EXCEPTION_INTERCEPT,
   44|       |    mshv_install_intercept,
   45|       |};
   46|       |#[cfg(mshv3)]
   47|       |use mshv_bindings::{
   48|       |    hv_partition_property_code_HV_PARTITION_PROPERTY_SYNTHETIC_PROC_FEATURES,
   49|       |    hv_partition_synthetic_processor_features,
   50|       |};
   51|       |#[cfg(feature = "trace_guest")]
   52|       |use mshv_bindings::{
   53|       |    hv_register_name, hv_register_name_HV_X64_REGISTER_RAX, hv_register_name_HV_X64_REGISTER_RBP,
   54|       |    hv_register_name_HV_X64_REGISTER_RCX, hv_register_name_HV_X64_REGISTER_RSP,
   55|       |};
   56|       |use mshv_ioctls::{Mshv, VcpuFd, VmFd};
   57|       |use tracing::{Span, instrument};
   58|       |#[cfg(crashdump)]
   59|       |use {super::crashdump, std::path::Path};
   60|       |
   61|       |#[cfg(feature = "trace_guest")]
   62|       |use super::TraceRegister;
   63|       |use super::fpu::{FP_CONTROL_WORD_DEFAULT, FP_TAG_WORD_DEFAULT, MXCSR_DEFAULT};
   64|       |#[cfg(gdb)]
   65|       |use super::gdb::{
   66|       |    DebugCommChannel, DebugMsg, DebugResponse, GuestDebug, MshvDebug, VcpuStopReason,
   67|       |};
   68|       |#[cfg(gdb)]
   69|       |use super::handlers::DbgMemAccessHandlerWrapper;
   70|       |#[cfg(feature = "init-paging")]
   71|       |use super::{
   72|       |    CR0_AM, CR0_ET, CR0_MP, CR0_NE, CR0_PE, CR0_PG, CR0_WP, CR4_OSFXSR, CR4_OSXMMEXCPT, CR4_PAE,
   73|       |    EFER_LMA, EFER_LME, EFER_NX, EFER_SCE,
   74|       |};
   75|       |use super::{HyperlightExit, Hypervisor, InterruptHandle, LinuxInterruptHandle, VirtualCPU};
   76|       |#[cfg(gdb)]
   77|       |use crate::HyperlightError;
   78|       |use crate::hypervisor::get_memory_access_violation;
   79|       |use crate::mem::memory_region::{MemoryRegion, MemoryRegionFlags};
   80|       |use crate::mem::ptr::{GuestPtr, RawPtr};
   81|       |use crate::mem::shared_mem::HostSharedMemory;
   82|       |use crate::sandbox::SandboxConfiguration;
   83|       |#[cfg(feature = "trace_guest")]
   84|       |use crate::sandbox::TraceInfo;
   85|       |use crate::sandbox::host_funcs::FunctionRegistry;
   86|       |use crate::sandbox::mem_mgr::MemMgrWrapper;
   87|       |use crate::sandbox::outb::handle_outb;
   88|       |#[cfg(crashdump)]
   89|       |use crate::sandbox::uninitialized::SandboxRuntimeConfig;
   90|       |use crate::{Result, log_then_return, new_error};
   91|       |
   92|       |#[cfg(gdb)]
   93|       |mod debug {
   94|       |    use std::sync::{Arc, Mutex};
   95|       |
   96|       |    use super::mshv_bindings::hv_x64_exception_intercept_message;
   97|       |    use super::{HypervLinuxDriver, *};
   98|       |    use crate::hypervisor::gdb::{DebugMsg, DebugResponse, VcpuStopReason, X86_64Regs};
   99|       |    use crate::hypervisor::handlers::DbgMemAccessHandlerCaller;
  100|       |    use crate::{Result, new_error};
  101|       |
  102|       |    impl HypervLinuxDriver {
  103|       |        /// Resets the debug information to disable debugging
  104|       |        fn disable_debug(&mut self) -> Result<()> {
  105|       |            let mut debug = MshvDebug::default();
  106|       |
  107|       |            debug.set_single_step(&self.vcpu_fd, false)?;
  108|       |
  109|       |            self.debug = Some(debug);
  110|       |
  111|       |            Ok(())
  112|       |        }
  113|       |
  114|       |        /// Get the reason the vCPU has stopped
  115|       |        pub(crate) fn get_stop_reason(
  116|       |            &mut self,
  117|       |            ex_info: hv_x64_exception_intercept_message,
  118|       |        ) -> Result<VcpuStopReason> {
  119|       |            let debug = self
  120|       |                .debug
  121|       |                .as_mut()
  122|       |                .ok_or_else(|| new_error!("Debug is not enabled"))?;
  123|       |
  124|       |            debug.get_stop_reason(&self.vcpu_fd, ex_info.exception_vector, self.entrypoint)
  125|       |        }
  126|       |
  127|       |        pub(crate) fn process_dbg_request(
  128|       |            &mut self,
  129|       |            req: DebugMsg,
  130|       |            dbg_mem_access_fn: Arc<Mutex<dyn DbgMemAccessHandlerCaller>>,
  131|       |        ) -> Result<DebugResponse> {
  132|       |            if let Some(debug) = self.debug.as_mut() {
  133|       |                match req {
  134|       |                    DebugMsg::AddHwBreakpoint(addr) => Ok(DebugResponse::AddHwBreakpoint(
  135|       |                        debug
  136|       |                            .add_hw_breakpoint(&self.vcpu_fd, addr)
  137|       |                            .map_err(|e| {
  138|       |                                log::error!("Failed to add hw breakpoint: {:?}", e);
  139|       |
  140|       |                                e
  141|       |                            })
  142|       |                            .is_ok(),
  143|       |                    )),
  144|       |                    DebugMsg::AddSwBreakpoint(addr) => Ok(DebugResponse::AddSwBreakpoint(
  145|       |                        debug
  146|       |                            .add_sw_breakpoint(&self.vcpu_fd, addr, dbg_mem_access_fn)
  147|       |                            .map_err(|e| {
  148|       |                                log::error!("Failed to add sw breakpoint: {:?}", e);
  149|       |
  150|       |                                e
  151|       |                            })
  152|       |                            .is_ok(),
  153|       |                    )),
  154|       |                    DebugMsg::Continue => {
  155|       |                        debug.set_single_step(&self.vcpu_fd, false).map_err(|e| {
  156|       |                            log::error!("Failed to continue execution: {:?}", e);
  157|       |
  158|       |                            e
  159|       |                        })?;
  160|       |
  161|       |                        Ok(DebugResponse::Continue)
  162|       |                    }
  163|       |                    DebugMsg::DisableDebug => {
  164|       |                        self.disable_debug().map_err(|e| {
  165|       |                            log::error!("Failed to disable debugging: {:?}", e);
  166|       |
  167|       |                            e
  168|       |                        })?;
  169|       |
  170|       |                        Ok(DebugResponse::DisableDebug)
  171|       |                    }
  172|       |                    DebugMsg::GetCodeSectionOffset => {
  173|       |                        let offset = dbg_mem_access_fn
  174|       |                            .try_lock()
  175|       |                            .map_err(|e| {
  176|       |                                new_error!("Error locking at {}:{}: {}", file!(), line!(), e)
  177|       |                            })?
  178|       |                            .get_code_offset()
  179|       |                            .map_err(|e| {
  180|       |                                log::error!("Failed to get code offset: {:?}", e);
  181|       |
  182|       |                                e
  183|       |                            })?;
  184|       |
  185|       |                        Ok(DebugResponse::GetCodeSectionOffset(offset as u64))
  186|       |                    }
  187|       |                    DebugMsg::ReadAddr(addr, len) => {
  188|       |                        let mut data = vec![0u8; len];
  189|       |
  190|       |                        debug
  191|       |                            .read_addrs(&self.vcpu_fd, addr, &mut data, dbg_mem_access_fn)
  192|       |                            .map_err(|e| {
  193|       |                                log::error!("Failed to read from address: {:?}", e);
  194|       |
  195|       |                                e
  196|       |                            })?;
  197|       |
  198|       |                        Ok(DebugResponse::ReadAddr(data))
  199|       |                    }
  200|       |                    DebugMsg::ReadRegisters => {
  201|       |                        let mut regs = X86_64Regs::default();
  202|       |
  203|       |                        debug
  204|       |                            .read_regs(&self.vcpu_fd, &mut regs)
  205|       |                            .map_err(|e| {
  206|       |                                log::error!("Failed to read registers: {:?}", e);
  207|       |
  208|       |                                e
  209|       |                            })
  210|       |                            .map(|_| DebugResponse::ReadRegisters(regs))
  211|       |                    }
  212|       |                    DebugMsg::RemoveHwBreakpoint(addr) => Ok(DebugResponse::RemoveHwBreakpoint(
  213|       |                        debug
  214|       |                            .remove_hw_breakpoint(&self.vcpu_fd, addr)
  215|       |                            .map_err(|e| {
  216|       |                                log::error!("Failed to remove hw breakpoint: {:?}", e);
  217|       |
  218|       |                                e
  219|       |                            })
  220|       |                            .is_ok(),
  221|       |                    )),
  222|       |                    DebugMsg::RemoveSwBreakpoint(addr) => Ok(DebugResponse::RemoveSwBreakpoint(
  223|       |                        debug
  224|       |                            .remove_sw_breakpoint(&self.vcpu_fd, addr, dbg_mem_access_fn)
  225|       |                            .map_err(|e| {
  226|       |                                log::error!("Failed to remove sw breakpoint: {:?}", e);
  227|       |
  228|       |                                e
  229|       |                            })
  230|       |                            .is_ok(),
  231|       |                    )),
  232|       |                    DebugMsg::Step => {
  233|       |                        debug.set_single_step(&self.vcpu_fd, true).map_err(|e| {
  234|       |                            log::error!("Failed to enable step instruction: {:?}", e);
  235|       |
  236|       |                            e
  237|       |                        })?;
  238|       |
  239|       |                        Ok(DebugResponse::Step)
  240|       |                    }
  241|       |                    DebugMsg::WriteAddr(addr, data) => {
  242|       |                        debug
  243|       |                            .write_addrs(&self.vcpu_fd, addr, &data, dbg_mem_access_fn)
  244|       |                            .map_err(|e| {
  245|       |                                log::error!("Failed to write to address: {:?}", e);
  246|       |
  247|       |                                e
  248|       |                            })?;
  249|       |
  250|       |                        Ok(DebugResponse::WriteAddr)
  251|       |                    }
  252|       |                    DebugMsg::WriteRegisters(regs) => debug
  253|       |                        .write_regs(&self.vcpu_fd, &regs)
  254|       |                        .map_err(|e| {
  255|       |                            log::error!("Failed to write registers: {:?}", e);
  256|       |
  257|       |                            e
  258|       |                        })
  259|       |                        .map(|_| DebugResponse::WriteRegisters),
  260|       |                }
  261|       |            } else {
  262|       |                Err(new_error!("Debugging is not enabled"))
  263|       |            }
  264|       |        }
  265|       |
  266|       |        pub(crate) fn recv_dbg_msg(&mut self) -> Result<DebugMsg> {
  267|       |            let gdb_conn = self
  268|       |                .gdb_conn
  269|       |                .as_mut()
  270|       |                .ok_or_else(|| new_error!("Debug is not enabled"))?;
  271|       |
  272|       |            gdb_conn.recv().map_err(|e| {
  273|       |                new_error!(
  274|       |                    "Got an error while waiting to receive a
  275|       |                    message: {:?}",
  276|       |                    e
  277|       |                )
  278|       |            })
  279|       |        }
  280|       |
  281|       |        pub(crate) fn send_dbg_msg(&mut self, cmd: DebugResponse) -> Result<()> {
  282|       |            log::debug!("Sending {:?}", cmd);
  283|       |
  284|       |            let gdb_conn = self
  285|       |                .gdb_conn
  286|       |                .as_mut()
  287|       |                .ok_or_else(|| new_error!("Debug is not enabled"))?;
  288|       |
  289|       |            gdb_conn
  290|       |                .send(cmd)
  291|       |                .map_err(|e| new_error!("Got an error while sending a response message {:?}", e))
  292|       |        }
  293|       |    }
  294|       |}
  295|       |
  296|       |/// Determine whether the HyperV for Linux hypervisor API is present
  297|       |/// and functional.
  298|       |#[instrument(skip_all, parent = Span::current(), level = "Trace")]
  299|      3|pub(crate) fn is_hypervisor_present() -> bool {
  300|      3|    match Mshv::new() {
  301|      0|        Ok(_) => true,
  302|       |        Err(_) => {
  303|      3|            log::info!("MSHV is not available on this system");
                                     ^0
  304|      3|            false
  305|       |        }
  306|       |    }
  307|      3|}
  308|       |
  309|       |/// A Hypervisor driver for HyperV-on-Linux. This hypervisor is often
  310|       |/// called the Microsoft Hypervisor (MSHV)
  311|       |pub(crate) struct HypervLinuxDriver {
  312|       |    _mshv: Mshv,
  313|       |    page_size: usize,
  314|       |    vm_fd: VmFd,
  315|       |    vcpu_fd: VcpuFd,
  316|       |    orig_rsp: GuestPtr,
  317|       |    entrypoint: u64,
  318|       |    interrupt_handle: Arc<LinuxInterruptHandle>,
  319|       |    mem_mgr: Option<MemMgrWrapper<HostSharedMemory>>,
  320|       |    host_funcs: Option<Arc<Mutex<FunctionRegistry>>>,
  321|       |
  322|       |    sandbox_regions: Vec<MemoryRegion>, // Initially mapped regions when sandbox is created
  323|       |    mmap_regions: Vec<MemoryRegion>,    // Later mapped regions
  324|       |
  325|       |    #[cfg(gdb)]
  326|       |    debug: Option<MshvDebug>,
  327|       |    #[cfg(gdb)]
  328|       |    gdb_conn: Option<DebugCommChannel<DebugResponse, DebugMsg>>,
  329|       |    #[cfg(crashdump)]
  330|       |    rt_cfg: SandboxRuntimeConfig,
  331|       |    #[cfg(feature = "trace_guest")]
  332|       |    #[allow(dead_code)]
  333|       |    trace_info: TraceInfo,
  334|       |}
  335|       |
  336|       |impl HypervLinuxDriver {
  337|       |    /// Create a new `HypervLinuxDriver`, complete with all registers
  338|       |    /// set up to execute a Hyperlight binary inside a HyperV-powered
  339|       |    /// sandbox on Linux.
  340|       |    ///
  341|       |    /// While registers are set up, they will not have been applied to
  342|       |    /// the underlying virtual CPU after this function returns. Call the
  343|       |    /// `apply_registers` method to do that, or more likely call
  344|       |    /// `initialise` to do it for you.
  345|       |    #[allow(clippy::too_many_arguments)]
  346|       |    // TODO: refactor this function to take fewer arguments. Add trace_info to rt_cfg
  347|       |    #[instrument(skip_all, parent = Span::current(), level = "Trace")]
  348|      0|    pub(crate) fn new(
  349|      0|        mem_regions: Vec<MemoryRegion>,
  350|      0|        entrypoint_ptr: GuestPtr,
  351|      0|        rsp_ptr: GuestPtr,
  352|      0|        pml4_ptr: GuestPtr,
  353|      0|        config: &SandboxConfiguration,
  354|      0|        #[cfg(gdb)] gdb_conn: Option<DebugCommChannel<DebugResponse, DebugMsg>>,
  355|      0|        #[cfg(crashdump)] rt_cfg: SandboxRuntimeConfig,
  356|      0|        #[cfg(feature = "trace_guest")] trace_info: TraceInfo,
  357|      0|    ) -> Result<Self> {
  358|      0|        let mshv = Mshv::new()?;
  359|      0|        let pr = Default::default();
  360|       |        #[cfg(mshv2)]
  361|       |        let vm_fd = mshv.create_vm_with_config(&pr)?;
  362|       |        #[cfg(mshv3)]
  363|      0|        let vm_fd = {
  364|       |            // It's important to avoid create_vm() and explicitly use
  365|       |            // create_vm_with_args() with an empty arguments structure
  366|       |            // here, because otherwise the partition is set up with a SynIC.
  367|       |
  368|      0|            let vm_fd = mshv.create_vm_with_args(&pr)?;
  369|      0|            let features: hv_partition_synthetic_processor_features = Default::default();
  370|      0|            vm_fd.hvcall_set_partition_property(
  371|      0|                hv_partition_property_code_HV_PARTITION_PROPERTY_SYNTHETIC_PROC_FEATURES,
  372|      0|                unsafe { features.as_uint64[0] },
  373|      0|            )?;
  374|      0|            vm_fd.initialize()?;
  375|      0|            vm_fd
  376|       |        };
  377|       |
  378|      0|        let mut vcpu_fd = vm_fd.create_vcpu(0)?;
  379|       |
  380|       |        #[cfg(gdb)]
  381|       |        let (debug, gdb_conn) = if let Some(gdb_conn) = gdb_conn {
  382|       |            let mut debug = MshvDebug::new();
  383|       |            debug.add_hw_breakpoint(&vcpu_fd, entrypoint_ptr.absolute()?)?;
  384|       |
  385|       |            // The bellow intercepts make the vCPU exit with the Exception Intercept exit code
  386|       |            // Check Table 6-1. Exceptions and Interrupts at Page 6-13 Vol. 1
  387|       |            // of Intel 64 and IA-32 Architectures Software Developer's Manual
  388|       |            // Install intercept for #DB (1) exception
  389|       |            vm_fd
  390|       |                .install_intercept(mshv_install_intercept {
  391|       |                    access_type_mask: HV_INTERCEPT_ACCESS_MASK_EXECUTE,
  392|       |                    intercept_type: hv_intercept_type_HV_INTERCEPT_TYPE_EXCEPTION,
  393|       |                    // Exception handler #DB (1)
  394|       |                    intercept_parameter: hv_intercept_parameters {
  395|       |                        exception_vector: 0x1,
  396|       |                    },
  397|       |                })
  398|       |                .map_err(|e| new_error!("Cannot install debug exception intercept: {}", e))?;
  399|       |
  400|       |            // Install intercept for #BP (3) exception
  401|       |            vm_fd
  402|       |                .install_intercept(mshv_install_intercept {
  403|       |                    access_type_mask: HV_INTERCEPT_ACCESS_MASK_EXECUTE,
  404|       |                    intercept_type: hv_intercept_type_HV_INTERCEPT_TYPE_EXCEPTION,
  405|       |                    // Exception handler #BP (3)
  406|       |                    intercept_parameter: hv_intercept_parameters {
  407|       |                        exception_vector: 0x3,
  408|       |                    },
  409|       |                })
  410|       |                .map_err(|e| new_error!("Cannot install breakpoint exception intercept: {}", e))?;
  411|       |
  412|       |            (Some(debug), Some(gdb_conn))
  413|       |        } else {
  414|       |            (None, None)
  415|       |        };
  416|       |
  417|      0|        mem_regions.iter().try_for_each(|region| {
  418|      0|            let mshv_region = region.to_owned().into();
  419|      0|            vm_fd.map_user_memory(mshv_region)
  420|      0|        })?;
  421|       |
  422|      0|        Self::setup_initial_sregs(&mut vcpu_fd, pml4_ptr.absolute()?)?;
  423|       |
  424|      0|        let interrupt_handle = Arc::new(LinuxInterruptHandle {
  425|      0|            running: AtomicU64::new(0),
  426|      0|            cancel_requested: AtomicBool::new(false),
  427|      0|            #[cfg(gdb)]
  428|      0|            debug_interrupt: AtomicBool::new(false),
  429|      0|            #[cfg(all(
  430|      0|                target_arch = "x86_64",
  431|      0|                target_vendor = "unknown",
  432|      0|                target_os = "linux",
  433|      0|                target_env = "musl"
  434|      0|            ))]
  435|      0|            tid: AtomicU64::new(unsafe { libc::pthread_self() as u64 }),
  436|      0|            #[cfg(not(all(
  437|      0|                target_arch = "x86_64",
  438|      0|                target_vendor = "unknown",
  439|      0|                target_os = "linux",
  440|      0|                target_env = "musl"
  441|      0|            )))]
  442|      0|            tid: AtomicU64::new(unsafe { libc::pthread_self() }),
  443|      0|            retry_delay: config.get_interrupt_retry_delay(),
  444|      0|            sig_rt_min_offset: config.get_interrupt_vcpu_sigrtmin_offset(),
  445|      0|            dropped: AtomicBool::new(false),
  446|      0|        });
  447|       |
  448|       |        #[allow(unused_mut)]
  449|      0|        let mut hv = Self {
  450|      0|            _mshv: mshv,
  451|      0|            page_size: 0,
  452|      0|            vm_fd,
  453|      0|            vcpu_fd,
  454|      0|            sandbox_regions: mem_regions,
  455|      0|            mmap_regions: Vec::new(),
  456|      0|            entrypoint: entrypoint_ptr.absolute()?,
  457|      0|            orig_rsp: rsp_ptr,
  458|      0|            interrupt_handle: interrupt_handle.clone(),
  459|      0|            mem_mgr: None,
  460|      0|            host_funcs: None,
  461|      0|            #[cfg(gdb)]
  462|      0|            debug,
  463|      0|            #[cfg(gdb)]
  464|      0|            gdb_conn,
  465|      0|            #[cfg(crashdump)]
  466|      0|            rt_cfg,
  467|      0|            #[cfg(feature = "trace_guest")]
  468|      0|            trace_info,
  469|      0|        };
  470|      0|
  471|      0|        // Send the interrupt handle to the GDB thread if debugging is enabled
  472|      0|        // This is used to allow the GDB thread to stop the vCPU
  473|      0|        #[cfg(gdb)]
  474|      0|        if hv.debug.is_some() {
  475|      0|            hv.send_dbg_msg(DebugResponse::InterruptHandle(interrupt_handle))?;
  476|      0|        }
  477|      0|
  478|      0|        Ok(hv)
  479|      0|    }
  480|       |
  481|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  482|      0|    fn setup_initial_sregs(vcpu: &mut VcpuFd, _pml4_addr: u64) -> Result<()> {
  483|       |        #[cfg(feature = "init-paging")]
  484|       |        let sregs = SpecialRegisters {
  485|       |            cr0: CR0_PE | CR0_MP | CR0_ET | CR0_NE | CR0_AM | CR0_PG | CR0_WP,
  486|       |            cr4: CR4_PAE | CR4_OSFXSR | CR4_OSXMMEXCPT,
  487|       |            cr3: _pml4_addr,
  488|       |            efer: EFER_LME | EFER_LMA | EFER_SCE | EFER_NX,
  489|       |            cs: SegmentRegister {
  490|       |                type_: 11,
  491|       |                present: 1,
  492|       |                s: 1,
  493|       |                l: 1,
  494|       |                ..Default::default()
  495|       |            },
  496|       |            tr: SegmentRegister {
  497|       |                limit: 65535,
  498|       |                type_: 11,
  499|       |                present: 1,
  500|       |                ..Default::default()
  501|       |            },
  502|       |            ..Default::default()
  503|       |        };
  504|       |
  505|       |        #[cfg(not(feature = "init-paging"))]
  506|       |        let sregs = SpecialRegisters {
  507|       |            cs: SegmentRegister {
  508|       |                base: 0,
  509|       |                selector: 0,
  510|       |                limit: 0xFFFF,
  511|       |                type_: 11,
  512|       |                present: 1,
  513|       |                s: 1,
  514|       |                ..Default::default()
  515|       |            },
  516|       |            ds: SegmentRegister {
  517|       |                base: 0,
  518|       |                selector: 0,
  519|       |                limit: 0xFFFF,
  520|       |                type_: 3,
  521|       |                present: 1,
  522|       |                s: 1,
  523|       |                ..Default::default()
  524|       |            },
  525|       |            tr: SegmentRegister {
  526|       |                base: 0,
  527|       |                selector: 0,
  528|       |                limit: 0xFFFF,
  529|       |                type_: 11,
  530|       |                present: 1,
  531|       |                s: 0,
  532|       |                ..Default::default()
  533|       |            },
  534|       |            ..Default::default()
  535|       |        };
  536|       |        vcpu.set_sregs(&sregs)?;
  537|       |        Ok(())
  538|      0|    }
  539|       |}
  540|       |
  541|       |impl Debug for HypervLinuxDriver {
  542|      0|    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
  543|      0|        let mut f = f.debug_struct("Hyperv Linux Driver");
  544|      0|
  545|      0|        f.field("Entrypoint", &self.entrypoint)
  546|      0|            .field("Original RSP", &self.orig_rsp);
  547|       |
  548|      0|        for region in &self.sandbox_regions {
  549|      0|            f.field("Sandbox Memory Region", &region);
  550|      0|        }
  551|      0|        for region in &self.mmap_regions {
  552|      0|            f.field("Mapped Memory Region", &region);
  553|      0|        }
  554|       |
  555|      0|        let regs = self.vcpu_fd.get_regs();
  556|       |
  557|      0|        if let Ok(regs) = regs {
  558|      0|            f.field("Registers", &regs);
  559|      0|        }
  560|       |
  561|      0|        let sregs = self.vcpu_fd.get_sregs();
  562|       |
  563|      0|        if let Ok(sregs) = sregs {
  564|      0|            f.field("Special Registers", &sregs);
  565|      0|        }
  566|       |
  567|      0|        f.finish()
  568|      0|    }
  569|       |}
  570|       |
  571|       |#[cfg(feature = "trace_guest")]
  572|       |impl From<TraceRegister> for hv_register_name {
  573|       |    fn from(r: TraceRegister) -> Self {
  574|       |        match r {
  575|       |            TraceRegister::RAX => hv_register_name_HV_X64_REGISTER_RAX,
  576|       |            TraceRegister::RCX => hv_register_name_HV_X64_REGISTER_RCX,
  577|       |            TraceRegister::RIP => hv_register_name_HV_X64_REGISTER_RIP,
  578|       |            TraceRegister::RSP => hv_register_name_HV_X64_REGISTER_RSP,
  579|       |            TraceRegister::RBP => hv_register_name_HV_X64_REGISTER_RBP,
  580|       |        }
  581|       |    }
  582|       |}
  583|       |
  584|       |impl Hypervisor for HypervLinuxDriver {
  585|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  586|      0|    fn initialise(
  587|      0|        &mut self,
  588|      0|        peb_addr: RawPtr,
  589|      0|        seed: u64,
  590|      0|        page_size: u32,
  591|      0|        mem_mgr: MemMgrWrapper<HostSharedMemory>,
  592|      0|        host_funcs: Arc<Mutex<FunctionRegistry>>,
  593|      0|        max_guest_log_level: Option<LevelFilter>,
  594|      0|        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
  595|      0|    ) -> Result<()> {
  596|       |        self.mem_mgr = Some(mem_mgr);
  597|       |        self.host_funcs = Some(host_funcs);
  598|       |        self.page_size = page_size as usize;
  599|       |
  600|      0|        let max_guest_log_level: u64 = match max_guest_log_level {
  601|       |            Some(level) => level as u64,
  602|       |            None => self.get_max_log_level().into(),
  603|       |        };
  604|       |
  605|       |        let regs = StandardRegisters {
  606|       |            rip: self.entrypoint,
  607|       |            rsp: self.orig_rsp.absolute()?,
  608|       |            rflags: 2, //bit 1 of rlags is required to be set
  609|       |
  610|       |            // function args
  611|       |            rdi: peb_addr.into(),
  612|       |            rsi: seed,
  613|       |            rdx: page_size.into(),
  614|       |            rcx: max_guest_log_level,
  615|       |
  616|       |            ..Default::default()
  617|       |        };
  618|       |        self.vcpu_fd.set_regs(&regs)?;
  619|       |
  620|       |        VirtualCPU::run(
  621|       |            self.as_mut_hypervisor(),
  622|       |            #[cfg(gdb)]
  623|       |            dbg_mem_access_fn,
  624|       |        )
  625|      0|    }
  626|       |
  627|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  628|      0|    unsafe fn map_region(&mut self, rgn: &MemoryRegion) -> Result<()> {
  629|       |        if [
  630|       |            rgn.guest_region.start,
  631|       |            rgn.guest_region.end,
  632|       |            rgn.host_region.start,
  633|       |            rgn.host_region.end,
  634|       |        ]
  635|       |        .iter()
  636|      0|        .any(|x| x % self.page_size != 0)
  637|       |        {
  638|       |            log_then_return!("region is not page-aligned");
  639|       |        }
  640|       |        let mshv_region: mshv_user_mem_region = rgn.to_owned().into();
  641|       |        self.vm_fd.map_user_memory(mshv_region)?;
  642|       |        self.mmap_regions.push(rgn.to_owned());
  643|       |        Ok(())
  644|      0|    }
  645|       |
  646|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  647|      0|    unsafe fn unmap_region(&mut self, region: &MemoryRegion) -> Result<()> {
  648|      0|        if let Some(pos) = self.mmap_regions.iter().position(|r| r == region) {
  649|       |            let removed_region = self.mmap_regions.remove(pos);
  650|       |            let mshv_region: mshv_user_mem_region = removed_region.into();
  651|       |            self.vm_fd.unmap_user_memory(mshv_region)?;
  652|       |            Ok(())
  653|       |        } else {
  654|       |            Err(new_error!("Tried to unmap region that is not mapped"))
  655|       |        }
  656|      0|    }
  657|       |
  658|      0|    fn get_mapped_regions(&self) -> Box<dyn ExactSizeIterator<Item = &MemoryRegion> + '_> {
  659|      0|        Box::new(self.mmap_regions.iter())
  660|      0|    }
  661|       |
  662|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  663|      0|    fn dispatch_call_from_host(
  664|      0|        &mut self,
  665|      0|        dispatch_func_addr: RawPtr,
  666|      0|        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
  667|      0|    ) -> Result<()> {
  668|       |        // Reset general purpose registers, then set RIP and RSP
  669|       |        let regs = StandardRegisters {
  670|       |            rip: dispatch_func_addr.into(),
  671|       |            rsp: self.orig_rsp.absolute()?,
  672|       |            rflags: 2, //bit 1 of rlags is required to be set
  673|       |            ..Default::default()
  674|       |        };
  675|       |        self.vcpu_fd.set_regs(&regs)?;
  676|       |
  677|       |        // reset fpu state
  678|       |        let fpu = FloatingPointUnit {
  679|       |            fcw: FP_CONTROL_WORD_DEFAULT,
  680|       |            ftwx: FP_TAG_WORD_DEFAULT,
  681|       |            mxcsr: MXCSR_DEFAULT,
  682|       |            ..Default::default() // zero out the rest
  683|       |        };
  684|       |        self.vcpu_fd.set_fpu(&fpu)?;
  685|       |
  686|       |        // run
  687|       |        VirtualCPU::run(
  688|       |            self.as_mut_hypervisor(),
  689|       |            #[cfg(gdb)]
  690|       |            dbg_mem_access_fn,
  691|       |        )?;
  692|       |
  693|       |        Ok(())
  694|      0|    }
  695|       |
  696|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  697|      0|    fn handle_io(
  698|      0|        &mut self,
  699|      0|        port: u16,
  700|      0|        data: Vec<u8>,
  701|      0|        rip: u64,
  702|      0|        instruction_length: u64,
  703|      0|    ) -> Result<()> {
  704|       |        let mut padded = [0u8; 4];
  705|       |        let copy_len = data.len().min(4);
  706|       |        padded[..copy_len].copy_from_slice(&data[..copy_len]);
  707|       |        let val = u32::from_le_bytes(padded);
  708|       |
  709|       |        #[cfg(feature = "trace_guest")]
  710|       |        {
  711|       |            // We need to handle the borrow checker issue where we need both:
  712|       |            // - &mut MemMgrWrapper (from self.mem_mgr.as_mut())
  713|       |            // - &mut dyn Hypervisor (from self)
  714|       |            // We'll use a temporary approach to extract the mem_mgr temporarily
  715|       |            let mem_mgr_option = self.mem_mgr.take();
  716|       |            let mut mem_mgr = mem_mgr_option
  717|       |                .ok_or_else(|| new_error!("mem_mgr should be initialized before handling IO"))?;
  718|       |            let host_funcs = self
  719|       |                .host_funcs
  720|       |                .as_ref()
  721|       |                .ok_or_else(|| new_error!("host_funcs should be initialized before handling IO"))?
  722|       |                .clone();
  723|       |
  724|       |            handle_outb(&mut mem_mgr, host_funcs, self, port, val)?;
  725|       |
  726|       |            // Put the mem_mgr back
  727|       |            self.mem_mgr = Some(mem_mgr);
  728|       |        }
  729|       |
  730|       |        #[cfg(not(feature = "trace_guest"))]
  731|       |        {
  732|       |            let mem_mgr = self
  733|       |                .mem_mgr
  734|       |                .as_mut()
  735|      0|                .ok_or_else(|| new_error!("mem_mgr should be initialized before handling IO"))?;
  736|       |            let host_funcs = self
  737|       |                .host_funcs
  738|       |                .as_ref()
  739|      0|                .ok_or_else(|| new_error!("host_funcs should be initialized before handling IO"))?
  740|       |                .clone();
  741|       |
  742|       |            handle_outb(mem_mgr, host_funcs, port, val)?;
  743|       |        }
  744|       |
  745|       |        // update rip
  746|       |        self.vcpu_fd.set_reg(&[hv_register_assoc {
  747|       |            name: hv_register_name_HV_X64_REGISTER_RIP,
  748|       |            value: hv_register_value {
  749|       |                reg64: rip + instruction_length,
  750|       |            },
  751|       |            ..Default::default()
  752|       |        }])?;
  753|       |        Ok(())
  754|      0|    }
  755|       |
  756|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  757|      0|    fn run(&mut self) -> Result<super::HyperlightExit> {
  758|       |        const HALT_MESSAGE: hv_message_type = hv_message_type_HVMSG_X64_HALT;
  759|       |        const IO_PORT_INTERCEPT_MESSAGE: hv_message_type =
  760|       |            hv_message_type_HVMSG_X64_IO_PORT_INTERCEPT;
  761|       |        const UNMAPPED_GPA_MESSAGE: hv_message_type = hv_message_type_HVMSG_UNMAPPED_GPA;
  762|       |        const INVALID_GPA_ACCESS_MESSAGE: hv_message_type = hv_message_type_HVMSG_GPA_INTERCEPT;
  763|       |        #[cfg(gdb)]
  764|       |        const EXCEPTION_INTERCEPT: hv_message_type = hv_message_type_HVMSG_X64_EXCEPTION_INTERCEPT;
  765|       |
  766|       |        self.interrupt_handle
  767|       |            .tid
  768|       |            .store(unsafe { libc::pthread_self() as u64 }, Ordering::Relaxed);
  769|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  770|       |        // Then this is fine since `cancel_requested` is set to true, so we will skip the `VcpuFd::run()` call
  771|       |        self.interrupt_handle
  772|       |            .set_running_and_increment_generation()
  773|      0|            .map_err(|e| {
  774|      0|                new_error!(
  775|      0|                    "Error setting running state and incrementing generation: {}",
  776|      0|                    e
  777|      0|                )
  778|      0|            })?;
  779|       |        #[cfg(not(gdb))]
  780|       |        let debug_interrupt = false;
  781|       |        #[cfg(gdb)]
  782|       |        let debug_interrupt = self
  783|       |            .interrupt_handle
  784|       |            .debug_interrupt
  785|       |            .load(Ordering::Relaxed);
  786|       |
  787|       |        // Don't run the vcpu if `cancel_requested` is true
  788|       |        //
  789|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  790|       |        // Then this is fine since `cancel_requested` is set to true, so we will skip the `VcpuFd::run()` call
  791|       |        let exit_reason = if self
  792|       |            .interrupt_handle
  793|       |            .cancel_requested
  794|       |            .load(Ordering::Relaxed)
  795|       |            || debug_interrupt
  796|       |        {
  797|       |            Err(mshv_ioctls::MshvError::from(libc::EINTR))
  798|       |        } else {
  799|       |            #[cfg(feature = "trace_guest")]
  800|       |            if self.trace_info.guest_start_epoch.is_none() {
  801|       |                // Store the guest start epoch and cycles to trace the guest execution time
  802|       |                crate::debug!("MSHV - Guest Start Epoch set");
  803|       |                self.trace_info.guest_start_tsc =
  804|       |                    Some(hyperlight_guest_tracing::invariant_tsc::read_tsc());
  805|       |                self.trace_info.guest_start_epoch = Some(std::time::Instant::now());
  806|       |            }
  807|       |            // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  808|       |            // Then the vcpu will run, but we will keep sending signals to this thread
  809|       |            // to interrupt it until `running` is set to false. The `vcpu_fd::run()` call will
  810|       |            // return either normally with an exit reason, or from being "kicked" by out signal handler, with an EINTR error,
  811|       |            // both of which are fine.
  812|       |            #[cfg(mshv2)]
  813|       |            {
  814|       |                let hv_message: hv_message = Default::default();
  815|       |                self.vcpu_fd.run(hv_message)
  816|       |            }
  817|       |            #[cfg(mshv3)]
  818|       |            self.vcpu_fd.run()
  819|       |        };
  820|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  821|       |        // Then signals will be sent to this thread until `running` is set to false.
  822|       |        // This is fine since the signal handler is a no-op.
  823|       |        let cancel_requested = self
  824|       |            .interrupt_handle
  825|       |            .cancel_requested
  826|       |            .load(Ordering::Relaxed);
  827|       |        #[cfg(gdb)]
  828|       |        let debug_interrupt = self
  829|       |            .interrupt_handle
  830|       |            .debug_interrupt
  831|       |            .load(Ordering::Relaxed);
  832|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  833|       |        // Then `cancel_requested` will be set to true again, which will cancel the **next vcpu run**.
  834|       |        // Additionally signals will be sent to this thread until `running` is set to false.
  835|       |        // This is fine since the signal handler is a no-op.
  836|       |        self.interrupt_handle.clear_running_bit();
  837|       |        // At this point, `running` is false so no more signals will be sent to this thread,
  838|       |        // but we may still receive async signals that were sent before this point.
  839|       |        // To prevent those signals from interrupting subsequent calls to `run()`,
  840|       |        // we make sure to check `cancel_requested` before cancelling (see `libc::EINTR` match-arm below).
  841|       |        let result = match exit_reason {
  842|       |            Ok(m) => match m.header.message_type {
  843|       |                HALT_MESSAGE => {
  844|       |                    crate::debug!("mshv - Halt Details : {:#?}", &self);
  845|       |                    HyperlightExit::Halt()
  846|       |                }
  847|       |                IO_PORT_INTERCEPT_MESSAGE => {
  848|       |                    let io_message = m.to_ioport_info().map_err(mshv_ioctls::MshvError::from)?;
  849|       |                    let port_number = io_message.port_number;
  850|       |                    let rip = io_message.header.rip;
  851|       |                    let rax = io_message.rax;
  852|       |                    let instruction_length = io_message.header.instruction_length() as u64;
  853|       |                    crate::debug!("mshv IO Details : \nPort : {}\n{:#?}", port_number, &self);
  854|       |                    HyperlightExit::IoOut(
  855|       |                        port_number,
  856|       |                        rax.to_le_bytes().to_vec(),
  857|       |                        rip,
  858|       |                        instruction_length,
  859|       |                    )
  860|       |                }
  861|       |                UNMAPPED_GPA_MESSAGE => {
  862|       |                    let mimo_message = m.to_memory_info().map_err(mshv_ioctls::MshvError::from)?;
  863|       |                    let addr = mimo_message.guest_physical_address;
  864|       |                    crate::debug!(
  865|       |                        "mshv MMIO unmapped GPA -Details: Address: {} \n {:#?}",
  866|       |                        addr,
  867|       |                        &self
  868|       |                    );
  869|       |                    HyperlightExit::Mmio(addr)
  870|       |                }
  871|       |                INVALID_GPA_ACCESS_MESSAGE => {
  872|       |                    let mimo_message = m.to_memory_info().map_err(mshv_ioctls::MshvError::from)?;
  873|       |                    let gpa = mimo_message.guest_physical_address;
  874|       |                    let access_info = MemoryRegionFlags::try_from(mimo_message)?;
  875|       |                    crate::debug!(
  876|       |                        "mshv MMIO invalid GPA access -Details: Address: {} \n {:#?}",
  877|       |                        gpa,
  878|       |                        &self
  879|       |                    );
  880|       |                    match get_memory_access_violation(
  881|       |                        gpa as usize,
  882|       |                        self.sandbox_regions.iter().chain(self.mmap_regions.iter()),
  883|       |                        access_info,
  884|       |                    ) {
  885|       |                        Some(access_info_violation) => access_info_violation,
  886|       |                        None => HyperlightExit::Mmio(gpa),
  887|       |                    }
  888|       |                }
  889|       |                // The only case an intercept exit is expected is when debugging is enabled
  890|       |                // and the intercepts are installed.
  891|       |                // Provide the extra information about the exception to accurately determine
  892|       |                // the stop reason
  893|       |                #[cfg(gdb)]
  894|       |                EXCEPTION_INTERCEPT => {
  895|       |                    // Extract exception info from the message so we can figure out
  896|       |                    // more information about the vCPU state
  897|       |                    let ex_info = match m.to_exception_info().map_err(mshv_ioctls::MshvError::from)
  898|       |                    {
  899|       |                        Ok(info) => info,
  900|       |                        Err(e) => {
  901|       |                            log_then_return!("Error converting to exception info: {:?}", e);
  902|       |                        }
  903|       |                    };
  904|       |
  905|       |                    match self.get_stop_reason(ex_info) {
  906|       |                        Ok(reason) => HyperlightExit::Debug(reason),
  907|       |                        Err(e) => {
  908|       |                            log_then_return!("Error getting stop reason: {:?}", e);
  909|       |                        }
  910|       |                    }
  911|       |                }
  912|       |                other => {
  913|       |                    crate::debug!("mshv Other Exit: Exit: {:#?} \n {:#?}", other, &self);
  914|       |                    #[cfg(crashdump)]
  915|       |                    let _ = crashdump::generate_crashdump(self);
  916|       |                    log_then_return!("unknown Hyper-V run message type {:?}", other);
  917|       |                }
  918|       |            },
  919|       |            Err(e) => match e.errno() {
  920|       |                // we send a signal to the thread to cancel execution this results in EINTR being returned by KVM so we return Cancelled
  921|       |                libc::EINTR => {
  922|       |                    // If cancellation was not requested for this specific vm, the vcpu was interrupted because of debug interrupt or
  923|       |                    // a stale signal that meant to be delivered to a previous/other vcpu on this same thread, so let's ignore it
  924|       |                    if cancel_requested {
  925|       |                        self.interrupt_handle
  926|       |                            .cancel_requested
  927|       |                            .store(false, Ordering::Relaxed);
  928|       |                        HyperlightExit::Cancelled()
  929|       |                    } else {
  930|       |                        #[cfg(gdb)]
  931|       |                        if debug_interrupt {
  932|       |                            self.interrupt_handle
  933|       |                                .debug_interrupt
  934|       |                                .store(false, Ordering::Relaxed);
  935|       |
  936|       |                            // If the vCPU was stopped because of an interrupt, we need to
  937|       |                            // return a special exit reason so that the gdb thread can handle it
  938|       |                            // and resume execution
  939|       |                            HyperlightExit::Debug(VcpuStopReason::Interrupt)
  940|       |                        } else {
  941|       |                            HyperlightExit::Retry()
  942|       |                        }
  943|       |
  944|       |                        #[cfg(not(gdb))]
  945|       |                        HyperlightExit::Retry()
  946|       |                    }
  947|       |                }
  948|       |                libc::EAGAIN => HyperlightExit::Retry(),
  949|       |                _ => {
  950|       |                    crate::debug!("mshv Error - Details: Error: {} \n {:#?}", e, &self);
  951|       |                    log_then_return!("Error running VCPU {:?}", e);
  952|       |                }
  953|       |            },
  954|       |        };
  955|       |        Ok(result)
  956|      0|    }
  957|       |
  958|       |    #[instrument(skip_all, parent = Span::current(), level = "Trace")]
  959|      0|    fn as_mut_hypervisor(&mut self) -> &mut dyn Hypervisor {
  960|      0|        self as &mut dyn Hypervisor
  961|      0|    }
  962|       |
  963|      0|    fn interrupt_handle(&self) -> Arc<dyn InterruptHandle> {
  964|      0|        self.interrupt_handle.clone()
  965|      0|    }
  966|       |
  967|       |    #[cfg(crashdump)]
  968|       |    fn crashdump_context(&self) -> Result<Option<super::crashdump::CrashDumpContext>> {
  969|       |        if self.rt_cfg.guest_core_dump {
  970|       |            let mut regs = [0; 27];
  971|       |
  972|       |            let vcpu_regs = self.vcpu_fd.get_regs()?;
  973|       |            let sregs = self.vcpu_fd.get_sregs()?;
  974|       |            let xsave = self.vcpu_fd.get_xsave()?;
  975|       |
  976|       |            // Set up the registers for the crash dump
  977|       |            regs[0] = vcpu_regs.r15; // r15
  978|       |            regs[1] = vcpu_regs.r14; // r14
  979|       |            regs[2] = vcpu_regs.r13; // r13
  980|       |            regs[3] = vcpu_regs.r12; // r12
  981|       |            regs[4] = vcpu_regs.rbp; // rbp
  982|       |            regs[5] = vcpu_regs.rbx; // rbx
  983|       |            regs[6] = vcpu_regs.r11; // r11
  984|       |            regs[7] = vcpu_regs.r10; // r10
  985|       |            regs[8] = vcpu_regs.r9; // r9
  986|       |            regs[9] = vcpu_regs.r8; // r8
  987|       |            regs[10] = vcpu_regs.rax; // rax
  988|       |            regs[11] = vcpu_regs.rcx; // rcx
  989|       |            regs[12] = vcpu_regs.rdx; // rdx
  990|       |            regs[13] = vcpu_regs.rsi; // rsi
  991|       |            regs[14] = vcpu_regs.rdi; // rdi
  992|       |            regs[15] = 0; // orig rax
  993|       |            regs[16] = vcpu_regs.rip; // rip
  994|       |            regs[17] = sregs.cs.selector as u64; // cs
  995|       |            regs[18] = vcpu_regs.rflags; // eflags
  996|       |            regs[19] = vcpu_regs.rsp; // rsp
  997|       |            regs[20] = sregs.ss.selector as u64; // ss
  998|       |            regs[21] = sregs.fs.base; // fs_base
  999|       |            regs[22] = sregs.gs.base; // gs_base
 1000|       |            regs[23] = sregs.ds.selector as u64; // ds
 1001|       |            regs[24] = sregs.es.selector as u64; // es
 1002|       |            regs[25] = sregs.fs.selector as u64; // fs
 1003|       |            regs[26] = sregs.gs.selector as u64; // gs
 1004|       |
 1005|       |            // Get the filename from the binary path
 1006|       |            let filename = self.rt_cfg.binary_path.clone().and_then(|path| {
 1007|       |                Path::new(&path)
 1008|       |                    .file_name()
 1009|       |                    .and_then(|name| name.to_os_string().into_string().ok())
 1010|       |            });
 1011|       |
 1012|       |            Ok(Some(crashdump::CrashDumpContext::new(
 1013|       |                &self.sandbox_regions,
 1014|       |                regs,
 1015|       |                xsave.buffer.to_vec(),
 1016|       |                self.entrypoint,
 1017|       |                self.rt_cfg.binary_path.clone(),
 1018|       |                filename,
 1019|       |            )))
 1020|       |        } else {
 1021|       |            Ok(None)
 1022|       |        }
 1023|       |    }
 1024|       |
 1025|       |    #[cfg(gdb)]
 1026|       |    fn handle_debug(
 1027|       |        &mut self,
 1028|       |        dbg_mem_access_fn: std::sync::Arc<
 1029|       |            std::sync::Mutex<dyn super::handlers::DbgMemAccessHandlerCaller>,
 1030|       |        >,
 1031|       |        stop_reason: VcpuStopReason,
 1032|       |    ) -> Result<()> {
 1033|       |        if self.debug.is_none() {
 1034|       |            return Err(new_error!("Debugging is not enabled"));
 1035|       |        }
 1036|       |
 1037|       |        match stop_reason {
 1038|       |            // If the vCPU stopped because of a crash, we need to handle it differently
 1039|       |            // We do not want to allow resuming execution or placing breakpoints
 1040|       |            // because the guest has crashed.
 1041|       |            // We only allow reading registers and memory
 1042|       |            VcpuStopReason::Crash => {
 1043|       |                self.send_dbg_msg(DebugResponse::VcpuStopped(stop_reason))
 1044|       |                    .map_err(|e| {
 1045|       |                        new_error!("Couldn't signal vCPU stopped event to GDB thread: {:?}", e)
 1046|       |                    })?;
 1047|       |
 1048|       |                loop {
 1049|       |                    log::debug!("Debug wait for event to resume vCPU");
 1050|       |                    // Wait for a message from gdb
 1051|       |                    let req = self.recv_dbg_msg()?;
 1052|       |
 1053|       |                    // Flag to store if we should deny continue or step requests
 1054|       |                    let mut deny_continue = false;
 1055|       |                    // Flag to store if we should detach from the gdb session
 1056|       |                    let mut detach = false;
 1057|       |
 1058|       |                    let response = match req {
 1059|       |                        // Allow the detach request to disable debugging by continuing resuming
 1060|       |                        // hypervisor crash error reporting
 1061|       |                        DebugMsg::DisableDebug => {
 1062|       |                            detach = true;
 1063|       |                            DebugResponse::DisableDebug
 1064|       |                        }
 1065|       |                        // Do not allow continue or step requests
 1066|       |                        DebugMsg::Continue | DebugMsg::Step => {
 1067|       |                            deny_continue = true;
 1068|       |                            DebugResponse::NotAllowed
 1069|       |                        }
 1070|       |                        // Do not allow adding/removing breakpoints and writing to memory or registers
 1071|       |                        DebugMsg::AddHwBreakpoint(_)
 1072|       |                        | DebugMsg::AddSwBreakpoint(_)
 1073|       |                        | DebugMsg::RemoveHwBreakpoint(_)
 1074|       |                        | DebugMsg::RemoveSwBreakpoint(_)
 1075|       |                        | DebugMsg::WriteAddr(_, _)
 1076|       |                        | DebugMsg::WriteRegisters(_) => DebugResponse::NotAllowed,
 1077|       |
 1078|       |                        // For all other requests, we will process them normally
 1079|       |                        _ => {
 1080|       |                            let result = self.process_dbg_request(req, dbg_mem_access_fn.clone());
 1081|       |                            match result {
 1082|       |                                Ok(response) => response,
 1083|       |                                Err(HyperlightError::TranslateGuestAddress(_)) => {
 1084|       |                                    // Treat non fatal errors separately so the guest doesn't fail
 1085|       |                                    DebugResponse::ErrorOccurred
 1086|       |                                }
 1087|       |                                Err(e) => {
 1088|       |                                    log::error!("Error processing debug request: {:?}", e);
 1089|       |                                    return Err(e);
 1090|       |                                }
 1091|       |                            }
 1092|       |                        }
 1093|       |                    };
 1094|       |
 1095|       |                    // Send the response to the request back to gdb
 1096|       |                    self.send_dbg_msg(response)
 1097|       |                        .map_err(|e| new_error!("Couldn't send response to gdb: {:?}", e))?;
 1098|       |
 1099|       |                    // If we are denying continue or step requests, the debugger assumes the
 1100|       |                    // execution started so we need to report a stop reason as a crash and let
 1101|       |                    // it request to read registers/memory to figure out what happened
 1102|       |                    if deny_continue {
 1103|       |                        self.send_dbg_msg(DebugResponse::VcpuStopped(VcpuStopReason::Crash))
 1104|       |                            .map_err(|e| new_error!("Couldn't send response to gdb: {:?}", e))?;
 1105|       |                    }
 1106|       |
 1107|       |                    // If we are detaching, we will break the loop and the Hypervisor will continue
 1108|       |                    // to handle the Crash reason
 1109|       |                    if detach {
 1110|       |                        break;
 1111|       |                    }
 1112|       |                }
 1113|       |            }
 1114|       |            // If the vCPU stopped because of any other reason except a crash, we can handle it
 1115|       |            // normally
 1116|       |            _ => {
 1117|       |                // Send the stop reason to the gdb thread
 1118|       |                self.send_dbg_msg(DebugResponse::VcpuStopped(stop_reason))
 1119|       |                    .map_err(|e| {
 1120|       |                        new_error!("Couldn't signal vCPU stopped event to GDB thread: {:?}", e)
 1121|       |                    })?;
 1122|       |
 1123|       |                loop {
 1124|       |                    log::debug!("Debug wait for event to resume vCPU");
 1125|       |                    // Wait for a message from gdb
 1126|       |                    let req = self.recv_dbg_msg()?;
 1127|       |
 1128|       |                    let result = self.process_dbg_request(req, dbg_mem_access_fn.clone());
 1129|       |
 1130|       |                    let response = match result {
 1131|       |                        Ok(response) => response,
 1132|       |                        // Treat non fatal errors separately so the guest doesn't fail
 1133|       |                        Err(HyperlightError::TranslateGuestAddress(_)) => {
 1134|       |                            DebugResponse::ErrorOccurred
 1135|       |                        }
 1136|       |                        Err(e) => {
 1137|       |                            return Err(e);
 1138|       |                        }
 1139|       |                    };
 1140|       |
 1141|       |                    let cont = matches!(
 1142|       |                        response,
 1143|       |                        DebugResponse::Continue | DebugResponse::Step | DebugResponse::DisableDebug
 1144|       |                    );
 1145|       |
 1146|       |                    self.send_dbg_msg(response)
 1147|       |                        .map_err(|e| new_error!("Couldn't send response to gdb: {:?}", e))?;
 1148|       |
 1149|       |                    // Check if we should continue execution
 1150|       |                    // We continue if the response is one of the following: Step, Continue, or DisableDebug
 1151|       |                    if cont {
 1152|       |                        break;
 1153|       |                    }
 1154|       |                }
 1155|       |            }
 1156|       |        }
 1157|       |
 1158|       |        Ok(())
 1159|       |    }
 1160|       |
 1161|      0|    fn check_stack_guard(&self) -> Result<bool> {
 1162|      0|        if let Some(mgr) = self.mem_mgr.as_ref() {
 1163|      0|            mgr.check_stack_guard()
 1164|       |        } else {
 1165|      0|            Err(new_error!("Memory manager is not initialized"))
 1166|       |        }
 1167|      0|    }
 1168|       |
 1169|       |    #[cfg(feature = "trace_guest")]
 1170|       |    fn read_trace_reg(&self, reg: TraceRegister) -> Result<u64> {
 1171|       |        let mut assoc = [hv_register_assoc {
 1172|       |            name: reg.into(),
 1173|       |            ..Default::default()
 1174|       |        }];
 1175|       |        self.vcpu_fd.get_reg(&mut assoc)?;
 1176|       |        // safety: all registers that we currently support are 64-bit
 1177|       |        unsafe { Ok(assoc[0].value.reg64) }
 1178|       |    }
 1179|       |
 1180|       |    #[cfg(feature = "trace_guest")]
 1181|       |    fn trace_info_as_ref(&self) -> &TraceInfo {
 1182|       |        &self.trace_info
 1183|       |    }
 1184|       |    #[cfg(feature = "trace_guest")]
 1185|       |    fn trace_info_as_mut(&mut self) -> &mut TraceInfo {
 1186|       |        &mut self.trace_info
 1187|       |    }
 1188|       |}
 1189|       |
 1190|       |impl Drop for HypervLinuxDriver {
 1191|       |    #[instrument(skip_all, parent = Span::current(), level = "Trace")]
 1192|      0|    fn drop(&mut self) {
 1193|      0|        self.interrupt_handle.dropped.store(true, Ordering::Relaxed);
 1194|      0|        for region in self.sandbox_regions.iter().chain(self.mmap_regions.iter()) {
 1195|      0|            let mshv_region: mshv_user_mem_region = region.to_owned().into();
 1196|      0|            match self.vm_fd.unmap_user_memory(mshv_region) {
 1197|      0|                Ok(_) => (),
 1198|      0|                Err(e) => error!("Failed to unmap user memory in HyperVOnLinux ({:?})", e),
 1199|       |            }
 1200|       |        }
 1201|      0|    }
 1202|       |}
 1203|       |
 1204|       |#[cfg(test)]
 1205|       |mod tests {
 1206|       |    use super::*;
 1207|       |    #[cfg(feature = "unwind_guest")]
 1208|       |    use crate::mem::exe::DummyUnwindInfo;
 1209|       |    use crate::mem::memory_region::MemoryRegionVecBuilder;
 1210|       |    use crate::mem::shared_mem::{ExclusiveSharedMemory, SharedMemory};
 1211|       |
 1212|       |    #[rustfmt::skip]
 1213|       |    const CODE: [u8; 12] = [
 1214|       |        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */
 1215|       |        0x00, 0xd8, /* add %bl, %al */
 1216|       |        0x04, b'0', /* add $'0', %al */
 1217|       |        0xee, /* out %al, (%dx) */
 1218|       |        /* send a 0 to indicate we're done */
 1219|       |        0xb0, b'\0', /* mov $'\0', %al */
 1220|       |        0xee, /* out %al, (%dx) */
 1221|       |        0xf4, /* HLT */
 1222|       |    ];
 1223|       |
 1224|      0|    fn shared_mem_with_code(
 1225|      0|        code: &[u8],
 1226|      0|        mem_size: usize,
 1227|      0|        load_offset: usize,
 1228|      0|    ) -> Result<Box<ExclusiveSharedMemory>> {
 1229|      0|        if load_offset > mem_size {
 1230|      0|            log_then_return!(
 1231|      0|                "code load offset ({}) > memory size ({})",
 1232|      0|                load_offset,
 1233|      0|                mem_size
 1234|      0|            );
 1235|      0|        }
 1236|      0|        let mut shared_mem = ExclusiveSharedMemory::new(mem_size)?;
 1237|      0|        shared_mem.copy_from_slice(code, load_offset)?;
 1238|      0|        Ok(Box::new(shared_mem))
 1239|      0|    }
 1240|       |
 1241|       |    #[test]
 1242|      1|    fn create_driver() {
 1243|      1|        if !super::is_hypervisor_present() {
 1244|      1|            return;
 1245|      0|        }
 1246|       |        const MEM_SIZE: usize = 0x3000;
 1247|      0|        let gm = shared_mem_with_code(CODE.as_slice(), MEM_SIZE, 0).unwrap();
 1248|      0|        let rsp_ptr = GuestPtr::try_from(0).unwrap();
 1249|      0|        let pml4_ptr = GuestPtr::try_from(0).unwrap();
 1250|      0|        let entrypoint_ptr = GuestPtr::try_from(0).unwrap();
 1251|      0|        let mut regions = MemoryRegionVecBuilder::new(0, gm.base_addr());
 1252|      0|        regions.push_page_aligned(
 1253|      0|            MEM_SIZE,
 1254|      0|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE | MemoryRegionFlags::EXECUTE,
 1255|      0|            crate::mem::memory_region::MemoryRegionType::Code,
 1256|      0|        );
 1257|      0|        let config: SandboxConfiguration = Default::default();
 1258|      0|
 1259|      0|        super::HypervLinuxDriver::new(
 1260|      0|            regions.build(),
 1261|      0|            entrypoint_ptr,
 1262|      0|            rsp_ptr,
 1263|      0|            pml4_ptr,
 1264|      0|            &config,
 1265|      0|            #[cfg(gdb)]
 1266|      0|            None,
 1267|      0|            #[cfg(crashdump)]
 1268|      0|            SandboxRuntimeConfig {
 1269|      0|                #[cfg(crashdump)]
 1270|      0|                binary_path: None,
 1271|      0|                #[cfg(gdb)]
 1272|      0|                debug_info: None,
 1273|      0|                #[cfg(crashdump)]
 1274|      0|                guest_core_dump: true,
 1275|      0|            },
 1276|      0|            #[cfg(feature = "trace_guest")]
 1277|      0|            TraceInfo::new(
 1278|      0|                #[cfg(feature = "unwind_guest")]
 1279|      0|                Arc::new(DummyUnwindInfo {}),
 1280|      0|            )
 1281|      0|            .unwrap(),
 1282|      0|        )
 1283|      0|        .unwrap();
 1284|      1|    }
 1285|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/hypervisor/kvm.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::convert::TryFrom;
   18|       |use std::fmt::Debug;
   19|       |use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
   20|       |use std::sync::{Arc, Mutex};
   21|       |
   22|       |use kvm_bindings::{kvm_fpu, kvm_regs, kvm_userspace_memory_region};
   23|       |use kvm_ioctls::Cap::UserMemory;
   24|       |use kvm_ioctls::{Kvm, VcpuExit, VcpuFd, VmFd};
   25|       |use log::LevelFilter;
   26|       |use tracing::{Span, instrument};
   27|       |#[cfg(crashdump)]
   28|       |use {super::crashdump, std::path::Path};
   29|       |
   30|       |#[cfg(feature = "trace_guest")]
   31|       |use super::TraceRegister;
   32|       |use super::fpu::{FP_CONTROL_WORD_DEFAULT, FP_TAG_WORD_DEFAULT, MXCSR_DEFAULT};
   33|       |#[cfg(gdb)]
   34|       |use super::gdb::{DebugCommChannel, DebugMsg, DebugResponse, GuestDebug, KvmDebug, VcpuStopReason};
   35|       |#[cfg(gdb)]
   36|       |use super::handlers::DbgMemAccessHandlerWrapper;
   37|       |#[cfg(feature = "init-paging")]
   38|       |use super::{
   39|       |    CR0_AM, CR0_ET, CR0_MP, CR0_NE, CR0_PE, CR0_PG, CR0_WP, CR4_OSFXSR, CR4_OSXMMEXCPT, CR4_PAE,
   40|       |    EFER_LMA, EFER_LME, EFER_NX, EFER_SCE,
   41|       |};
   42|       |use super::{HyperlightExit, Hypervisor, InterruptHandle, LinuxInterruptHandle, VirtualCPU};
   43|       |#[cfg(gdb)]
   44|       |use crate::HyperlightError;
   45|       |use crate::hypervisor::get_memory_access_violation;
   46|       |use crate::mem::memory_region::{MemoryRegion, MemoryRegionFlags};
   47|       |use crate::mem::ptr::{GuestPtr, RawPtr};
   48|       |use crate::mem::shared_mem::HostSharedMemory;
   49|       |use crate::sandbox::SandboxConfiguration;
   50|       |#[cfg(feature = "trace_guest")]
   51|       |use crate::sandbox::TraceInfo;
   52|       |use crate::sandbox::host_funcs::FunctionRegistry;
   53|       |use crate::sandbox::mem_mgr::MemMgrWrapper;
   54|       |use crate::sandbox::outb::handle_outb;
   55|       |#[cfg(crashdump)]
   56|       |use crate::sandbox::uninitialized::SandboxRuntimeConfig;
   57|       |use crate::{Result, log_then_return, new_error};
   58|       |
   59|       |/// Return `true` if the KVM API is available, version 12, and has UserMemory capability, or `false` otherwise
   60|       |#[instrument(skip_all, parent = Span::current(), level = "Trace")]
   61|      2|pub(crate) fn is_hypervisor_present() -> bool {
   62|      2|    if let Ok(kvm) = Kvm::new() {
                            ^0
   63|      0|        let api_version = kvm.get_api_version();
   64|      0|        match api_version {
   65|      0|            version if version == 12 && kvm.check_extension(UserMemory) => true,
   66|       |            12 => {
   67|      0|                log::info!("KVM does not have KVM_CAP_USER_MEMORY capability");
   68|      0|                false
   69|       |            }
   70|      0|            version => {
   71|      0|                log::info!("KVM GET_API_VERSION returned {}, expected 12", version);
   72|      0|                false
   73|       |            }
   74|       |        }
   75|       |    } else {
   76|      2|        log::info!("KVM is not available on this system");
                                 ^0
   77|      2|        false
   78|       |    }
   79|      2|}
   80|       |
   81|       |#[cfg(gdb)]
   82|       |mod debug {
   83|       |    use std::sync::{Arc, Mutex};
   84|       |
   85|       |    use kvm_bindings::kvm_debug_exit_arch;
   86|       |
   87|       |    use super::KVMDriver;
   88|       |    use crate::hypervisor::gdb::{
   89|       |        DebugMsg, DebugResponse, GuestDebug, KvmDebug, VcpuStopReason, X86_64Regs,
   90|       |    };
   91|       |    use crate::hypervisor::handlers::DbgMemAccessHandlerCaller;
   92|       |    use crate::{Result, new_error};
   93|       |
   94|       |    impl KVMDriver {
   95|       |        /// Resets the debug information to disable debugging
   96|       |        fn disable_debug(&mut self) -> Result<()> {
   97|       |            let mut debug = KvmDebug::default();
   98|       |
   99|       |            debug.set_single_step(&self.vcpu_fd, false)?;
  100|       |
  101|       |            self.debug = Some(debug);
  102|       |
  103|       |            Ok(())
  104|       |        }
  105|       |
  106|       |        /// Get the reason the vCPU has stopped
  107|       |        pub(crate) fn get_stop_reason(
  108|       |            &mut self,
  109|       |            debug_exit: kvm_debug_exit_arch,
  110|       |        ) -> Result<VcpuStopReason> {
  111|       |            let debug = self
  112|       |                .debug
  113|       |                .as_mut()
  114|       |                .ok_or_else(|| new_error!("Debug is not enabled"))?;
  115|       |
  116|       |            debug.get_stop_reason(&self.vcpu_fd, debug_exit, self.entrypoint)
  117|       |        }
  118|       |
  119|       |        pub(crate) fn process_dbg_request(
  120|       |            &mut self,
  121|       |            req: DebugMsg,
  122|       |            dbg_mem_access_fn: Arc<Mutex<dyn DbgMemAccessHandlerCaller>>,
  123|       |        ) -> Result<DebugResponse> {
  124|       |            if let Some(debug) = self.debug.as_mut() {
  125|       |                match req {
  126|       |                    DebugMsg::AddHwBreakpoint(addr) => Ok(DebugResponse::AddHwBreakpoint(
  127|       |                        debug
  128|       |                            .add_hw_breakpoint(&self.vcpu_fd, addr)
  129|       |                            .map_err(|e| {
  130|       |                                log::error!("Failed to add hw breakpoint: {:?}", e);
  131|       |
  132|       |                                e
  133|       |                            })
  134|       |                            .is_ok(),
  135|       |                    )),
  136|       |                    DebugMsg::AddSwBreakpoint(addr) => Ok(DebugResponse::AddSwBreakpoint(
  137|       |                        debug
  138|       |                            .add_sw_breakpoint(&self.vcpu_fd, addr, dbg_mem_access_fn)
  139|       |                            .map_err(|e| {
  140|       |                                log::error!("Failed to add sw breakpoint: {:?}", e);
  141|       |
  142|       |                                e
  143|       |                            })
  144|       |                            .is_ok(),
  145|       |                    )),
  146|       |                    DebugMsg::Continue => {
  147|       |                        debug.set_single_step(&self.vcpu_fd, false).map_err(|e| {
  148|       |                            log::error!("Failed to continue execution: {:?}", e);
  149|       |
  150|       |                            e
  151|       |                        })?;
  152|       |
  153|       |                        Ok(DebugResponse::Continue)
  154|       |                    }
  155|       |                    DebugMsg::DisableDebug => {
  156|       |                        self.disable_debug().map_err(|e| {
  157|       |                            log::error!("Failed to disable debugging: {:?}", e);
  158|       |
  159|       |                            e
  160|       |                        })?;
  161|       |
  162|       |                        Ok(DebugResponse::DisableDebug)
  163|       |                    }
  164|       |                    DebugMsg::GetCodeSectionOffset => {
  165|       |                        let offset = dbg_mem_access_fn
  166|       |                            .try_lock()
  167|       |                            .map_err(|e| {
  168|       |                                new_error!("Error locking at {}:{}: {}", file!(), line!(), e)
  169|       |                            })?
  170|       |                            .get_code_offset()
  171|       |                            .map_err(|e| {
  172|       |                                log::error!("Failed to get code offset: {:?}", e);
  173|       |
  174|       |                                e
  175|       |                            })?;
  176|       |
  177|       |                        Ok(DebugResponse::GetCodeSectionOffset(offset as u64))
  178|       |                    }
  179|       |                    DebugMsg::ReadAddr(addr, len) => {
  180|       |                        let mut data = vec![0u8; len];
  181|       |
  182|       |                        debug
  183|       |                            .read_addrs(&self.vcpu_fd, addr, &mut data, dbg_mem_access_fn)
  184|       |                            .map_err(|e| {
  185|       |                                log::error!("Failed to read from address: {:?}", e);
  186|       |
  187|       |                                e
  188|       |                            })?;
  189|       |
  190|       |                        Ok(DebugResponse::ReadAddr(data))
  191|       |                    }
  192|       |                    DebugMsg::ReadRegisters => {
  193|       |                        let mut regs = X86_64Regs::default();
  194|       |
  195|       |                        debug
  196|       |                            .read_regs(&self.vcpu_fd, &mut regs)
  197|       |                            .map_err(|e| {
  198|       |                                log::error!("Failed to read registers: {:?}", e);
  199|       |
  200|       |                                e
  201|       |                            })
  202|       |                            .map(|_| DebugResponse::ReadRegisters(regs))
  203|       |                    }
  204|       |                    DebugMsg::RemoveHwBreakpoint(addr) => Ok(DebugResponse::RemoveHwBreakpoint(
  205|       |                        debug
  206|       |                            .remove_hw_breakpoint(&self.vcpu_fd, addr)
  207|       |                            .map_err(|e| {
  208|       |                                log::error!("Failed to remove hw breakpoint: {:?}", e);
  209|       |
  210|       |                                e
  211|       |                            })
  212|       |                            .is_ok(),
  213|       |                    )),
  214|       |                    DebugMsg::RemoveSwBreakpoint(addr) => Ok(DebugResponse::RemoveSwBreakpoint(
  215|       |                        debug
  216|       |                            .remove_sw_breakpoint(&self.vcpu_fd, addr, dbg_mem_access_fn)
  217|       |                            .map_err(|e| {
  218|       |                                log::error!("Failed to remove sw breakpoint: {:?}", e);
  219|       |
  220|       |                                e
  221|       |                            })
  222|       |                            .is_ok(),
  223|       |                    )),
  224|       |                    DebugMsg::Step => {
  225|       |                        debug.set_single_step(&self.vcpu_fd, true).map_err(|e| {
  226|       |                            log::error!("Failed to enable step instruction: {:?}", e);
  227|       |
  228|       |                            e
  229|       |                        })?;
  230|       |
  231|       |                        Ok(DebugResponse::Step)
  232|       |                    }
  233|       |                    DebugMsg::WriteAddr(addr, data) => {
  234|       |                        debug
  235|       |                            .write_addrs(&self.vcpu_fd, addr, &data, dbg_mem_access_fn)
  236|       |                            .map_err(|e| {
  237|       |                                log::error!("Failed to write to address: {:?}", e);
  238|       |
  239|       |                                e
  240|       |                            })?;
  241|       |
  242|       |                        Ok(DebugResponse::WriteAddr)
  243|       |                    }
  244|       |                    DebugMsg::WriteRegisters(regs) => debug
  245|       |                        .write_regs(&self.vcpu_fd, &regs)
  246|       |                        .map_err(|e| {
  247|       |                            log::error!("Failed to write registers: {:?}", e);
  248|       |
  249|       |                            e
  250|       |                        })
  251|       |                        .map(|_| DebugResponse::WriteRegisters),
  252|       |                }
  253|       |            } else {
  254|       |                Err(new_error!("Debugging is not enabled"))
  255|       |            }
  256|       |        }
  257|       |
  258|       |        pub(crate) fn recv_dbg_msg(&mut self) -> Result<DebugMsg> {
  259|       |            let gdb_conn = self
  260|       |                .gdb_conn
  261|       |                .as_mut()
  262|       |                .ok_or_else(|| new_error!("Debug is not enabled"))?;
  263|       |
  264|       |            gdb_conn.recv().map_err(|e| {
  265|       |                new_error!(
  266|       |                    "Got an error while waiting to receive a message from the gdb thread: {:?}",
  267|       |                    e
  268|       |                )
  269|       |            })
  270|       |        }
  271|       |
  272|       |        pub(crate) fn send_dbg_msg(&mut self, cmd: DebugResponse) -> Result<()> {
  273|       |            log::debug!("Sending {:?}", cmd);
  274|       |
  275|       |            let gdb_conn = self
  276|       |                .gdb_conn
  277|       |                .as_mut()
  278|       |                .ok_or_else(|| new_error!("Debug is not enabled"))?;
  279|       |
  280|       |            gdb_conn.send(cmd).map_err(|e| {
  281|       |                new_error!(
  282|       |                    "Got an error while sending a response message to the gdb thread: {:?}",
  283|       |                    e
  284|       |                )
  285|       |            })
  286|       |        }
  287|       |    }
  288|       |}
  289|       |
  290|       |/// A Hypervisor driver for KVM on Linux
  291|       |pub(crate) struct KVMDriver {
  292|       |    _kvm: Kvm,
  293|       |    vm_fd: VmFd,
  294|       |    page_size: usize,
  295|       |    vcpu_fd: VcpuFd,
  296|       |    entrypoint: u64,
  297|       |    orig_rsp: GuestPtr,
  298|       |    interrupt_handle: Arc<LinuxInterruptHandle>,
  299|       |    mem_mgr: Option<MemMgrWrapper<HostSharedMemory>>,
  300|       |    host_funcs: Option<Arc<Mutex<FunctionRegistry>>>,
  301|       |
  302|       |    sandbox_regions: Vec<MemoryRegion>, // Initially mapped regions when sandbox is created
  303|       |    mmap_regions: Vec<(MemoryRegion, u32)>, // Later mapped regions (region, slot number)
  304|       |    next_slot: u32,                     // Monotonically increasing slot number
  305|       |    freed_slots: Vec<u32>,              // Reusable slots from unmapped regions
  306|       |
  307|       |    #[cfg(gdb)]
  308|       |    debug: Option<KvmDebug>,
  309|       |    #[cfg(gdb)]
  310|       |    gdb_conn: Option<DebugCommChannel<DebugResponse, DebugMsg>>,
  311|       |    #[cfg(crashdump)]
  312|       |    rt_cfg: SandboxRuntimeConfig,
  313|       |    #[cfg(feature = "trace_guest")]
  314|       |    #[allow(dead_code)]
  315|       |    trace_info: TraceInfo,
  316|       |}
  317|       |
  318|       |impl KVMDriver {
  319|       |    /// Create a new instance of a `KVMDriver`, with only control registers
  320|       |    /// set. Standard registers will not be set, and `initialise` must
  321|       |    /// be called to do so.
  322|       |    #[allow(clippy::too_many_arguments)]
  323|       |    // TODO: refactor this function to take fewer arguments. Add trace_info to rt_cfg
  324|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  325|      0|    pub(crate) fn new(
  326|      0|        mem_regions: Vec<MemoryRegion>,
  327|      0|        pml4_addr: u64,
  328|      0|        entrypoint: u64,
  329|      0|        rsp: u64,
  330|      0|        config: &SandboxConfiguration,
  331|      0|        #[cfg(gdb)] gdb_conn: Option<DebugCommChannel<DebugResponse, DebugMsg>>,
  332|      0|        #[cfg(crashdump)] rt_cfg: SandboxRuntimeConfig,
  333|      0|        #[cfg(feature = "trace_guest")] trace_info: TraceInfo,
  334|      0|    ) -> Result<Self> {
  335|       |        let kvm = Kvm::new()?;
  336|       |
  337|       |        let vm_fd = kvm.create_vm_with_type(0)?;
  338|       |
  339|      0|        mem_regions.iter().enumerate().try_for_each(|(i, region)| {
  340|      0|            let mut kvm_region: kvm_userspace_memory_region = region.clone().into();
  341|      0|            kvm_region.slot = i as u32;
  342|      0|            unsafe { vm_fd.set_user_memory_region(kvm_region) }
  343|      0|        })?;
  344|       |
  345|       |        let mut vcpu_fd = vm_fd.create_vcpu(0)?;
  346|       |        Self::setup_initial_sregs(&mut vcpu_fd, pml4_addr)?;
  347|       |
  348|       |        #[cfg(gdb)]
  349|       |        let (debug, gdb_conn) = if let Some(gdb_conn) = gdb_conn {
  350|       |            let mut debug = KvmDebug::new();
  351|       |            // Add breakpoint to the entry point address
  352|       |            debug.add_hw_breakpoint(&vcpu_fd, entrypoint)?;
  353|       |
  354|       |            (Some(debug), Some(gdb_conn))
  355|       |        } else {
  356|       |            (None, None)
  357|       |        };
  358|       |
  359|       |        let rsp_gp = GuestPtr::try_from(RawPtr::from(rsp))?;
  360|       |
  361|       |        let interrupt_handle = Arc::new(LinuxInterruptHandle {
  362|       |            running: AtomicU64::new(0),
  363|       |            cancel_requested: AtomicBool::new(false),
  364|       |            #[cfg(gdb)]
  365|       |            debug_interrupt: AtomicBool::new(false),
  366|       |            #[cfg(all(
  367|       |                target_arch = "x86_64",
  368|       |                target_vendor = "unknown",
  369|       |                target_os = "linux",
  370|       |                target_env = "musl"
  371|       |            ))]
  372|       |            tid: AtomicU64::new(unsafe { libc::pthread_self() as u64 }),
  373|       |            #[cfg(not(all(
  374|       |                target_arch = "x86_64",
  375|       |                target_vendor = "unknown",
  376|       |                target_os = "linux",
  377|       |                target_env = "musl"
  378|       |            )))]
  379|       |            tid: AtomicU64::new(unsafe { libc::pthread_self() }),
  380|       |            retry_delay: config.get_interrupt_retry_delay(),
  381|       |            dropped: AtomicBool::new(false),
  382|       |            sig_rt_min_offset: config.get_interrupt_vcpu_sigrtmin_offset(),
  383|       |        });
  384|       |
  385|       |        #[allow(unused_mut)]
  386|       |        let mut hv = Self {
  387|       |            _kvm: kvm,
  388|       |            vm_fd,
  389|       |            page_size: 0,
  390|       |            vcpu_fd,
  391|       |            entrypoint,
  392|       |            orig_rsp: rsp_gp,
  393|       |            next_slot: mem_regions.len() as u32,
  394|       |            sandbox_regions: mem_regions,
  395|       |            mmap_regions: Vec::new(),
  396|       |            freed_slots: Vec::new(),
  397|       |            interrupt_handle: interrupt_handle.clone(),
  398|       |            mem_mgr: None,
  399|       |            host_funcs: None,
  400|       |            #[cfg(gdb)]
  401|       |            debug,
  402|       |            #[cfg(gdb)]
  403|       |            gdb_conn,
  404|       |            #[cfg(crashdump)]
  405|       |            rt_cfg,
  406|       |            #[cfg(feature = "trace_guest")]
  407|       |            trace_info,
  408|       |        };
  409|       |
  410|       |        // Send the interrupt handle to the GDB thread if debugging is enabled
  411|       |        // This is used to allow the GDB thread to stop the vCPU
  412|       |        #[cfg(gdb)]
  413|       |        if hv.debug.is_some() {
  414|       |            hv.send_dbg_msg(DebugResponse::InterruptHandle(interrupt_handle))?;
  415|       |        }
  416|       |
  417|       |        Ok(hv)
  418|      0|    }
  419|       |
  420|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  421|      0|    fn setup_initial_sregs(vcpu_fd: &mut VcpuFd, _pml4_addr: u64) -> Result<()> {
  422|       |        // setup paging and IA-32e (64-bit) mode
  423|       |        let mut sregs = vcpu_fd.get_sregs()?;
  424|       |        cfg_if::cfg_if! {
  425|       |            if #[cfg(feature = "init-paging")] {
  426|       |                sregs.cr3 = _pml4_addr;
  427|       |                sregs.cr4 = CR4_PAE | CR4_OSFXSR | CR4_OSXMMEXCPT;
  428|       |                sregs.cr0 = CR0_PE | CR0_MP | CR0_ET | CR0_NE | CR0_AM | CR0_PG | CR0_WP;
  429|       |                sregs.efer = EFER_LME | EFER_LMA | EFER_SCE | EFER_NX;
  430|       |                sregs.cs.l = 1; // required for 64-bit mode
  431|       |            } else {
  432|       |                sregs.cs.base = 0;
  433|       |                sregs.cs.selector = 0;
  434|       |            }
  435|       |        }
  436|       |        vcpu_fd.set_sregs(&sregs)?;
  437|       |        Ok(())
  438|      0|    }
  439|       |}
  440|       |
  441|       |impl Debug for KVMDriver {
  442|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  443|      0|        let mut f = f.debug_struct("KVM Driver");
  444|       |        // Output each memory region
  445|       |
  446|      0|        for region in &self.sandbox_regions {
  447|      0|            f.field("Sandbox Memory Region", &region);
  448|      0|        }
  449|      0|        for region in &self.mmap_regions {
  450|      0|            f.field("Mapped Memory Region", &region);
  451|      0|        }
  452|      0|        let regs = self.vcpu_fd.get_regs();
  453|       |        // check that regs is OK and then set field in debug struct
  454|       |
  455|      0|        if let Ok(regs) = regs {
  456|      0|            f.field("Registers", &regs);
  457|      0|        }
  458|       |
  459|      0|        let sregs = self.vcpu_fd.get_sregs();
  460|       |
  461|       |        // check that sregs is OK and then set field in debug struct
  462|       |
  463|      0|        if let Ok(sregs) = sregs {
  464|      0|            f.field("Special Registers", &sregs);
  465|      0|        }
  466|       |
  467|      0|        f.finish()
  468|      0|    }
  469|       |}
  470|       |
  471|       |impl Hypervisor for KVMDriver {
  472|       |    /// Implementation of initialise for Hypervisor trait.
  473|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  474|      0|    fn initialise(
  475|      0|        &mut self,
  476|      0|        peb_addr: RawPtr,
  477|      0|        seed: u64,
  478|      0|        page_size: u32,
  479|      0|        mem_mgr: MemMgrWrapper<HostSharedMemory>,
  480|      0|        host_funcs: Arc<Mutex<FunctionRegistry>>,
  481|      0|        max_guest_log_level: Option<LevelFilter>,
  482|      0|        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
  483|      0|    ) -> Result<()> {
  484|       |        self.mem_mgr = Some(mem_mgr);
  485|       |        self.host_funcs = Some(host_funcs);
  486|       |        self.page_size = page_size as usize;
  487|       |
  488|      0|        let max_guest_log_level: u64 = match max_guest_log_level {
  489|       |            Some(level) => level as u64,
  490|       |            None => self.get_max_log_level().into(),
  491|       |        };
  492|       |
  493|       |        let regs = kvm_regs {
  494|       |            rip: self.entrypoint,
  495|       |            rsp: self.orig_rsp.absolute()?,
  496|       |
  497|       |            // function args
  498|       |            rdi: peb_addr.into(),
  499|       |            rsi: seed,
  500|       |            rdx: page_size.into(),
  501|       |            rcx: max_guest_log_level,
  502|       |
  503|       |            ..Default::default()
  504|       |        };
  505|       |        self.vcpu_fd.set_regs(&regs)?;
  506|       |
  507|       |        VirtualCPU::run(
  508|       |            self.as_mut_hypervisor(),
  509|       |            #[cfg(gdb)]
  510|       |            dbg_mem_access_fn,
  511|       |        )
  512|      0|    }
  513|       |
  514|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  515|      0|    unsafe fn map_region(&mut self, region: &MemoryRegion) -> Result<()> {
  516|       |        if [
  517|       |            region.guest_region.start,
  518|       |            region.guest_region.end,
  519|       |            region.host_region.start,
  520|       |            region.host_region.end,
  521|       |        ]
  522|       |        .iter()
  523|      0|        .any(|x| x % self.page_size != 0)
  524|       |        {
  525|       |            log_then_return!(
  526|       |                "region is not page-aligned {:x}, {region:?}",
  527|       |                self.page_size
  528|       |            );
  529|       |        }
  530|       |
  531|       |        let mut kvm_region: kvm_userspace_memory_region = region.clone().into();
  532|       |
  533|       |        // Try to reuse a freed slot first, otherwise use next_slot
  534|       |        let slot = if let Some(freed_slot) = self.freed_slots.pop() {
  535|       |            freed_slot
  536|       |        } else {
  537|      0|            let slot = self.next_slot;
  538|       |            self.next_slot += 1;
  539|       |            slot
  540|       |        };
  541|       |
  542|       |        kvm_region.slot = slot;
  543|       |        unsafe { self.vm_fd.set_user_memory_region(kvm_region) }?;
  544|       |        self.mmap_regions.push((region.to_owned(), slot));
  545|       |        Ok(())
  546|      0|    }
  547|       |
  548|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  549|      0|    unsafe fn unmap_region(&mut self, region: &MemoryRegion) -> Result<()> {
  550|      0|        if let Some(idx) = self.mmap_regions.iter().position(|(r, _)| r == region) {
  551|       |            let (region, slot) = self.mmap_regions.remove(idx);
  552|       |            let mut kvm_region: kvm_userspace_memory_region = region.into();
  553|       |            kvm_region.slot = slot;
  554|       |            // Setting memory_size to 0 unmaps the slot's region
  555|       |            // From https://docs.kernel.org/virt/kvm/api.html
  556|       |            // > Deleting a slot is done by passing zero for memory_size.
  557|       |            kvm_region.memory_size = 0;
  558|       |            unsafe { self.vm_fd.set_user_memory_region(kvm_region) }?;
  559|       |
  560|       |            // Add the freed slot to the reuse list
  561|       |            self.freed_slots.push(slot);
  562|       |
  563|       |            Ok(())
  564|       |        } else {
  565|       |            Err(new_error!("Tried to unmap region that is not mapped"))
  566|       |        }
  567|      0|    }
  568|       |
  569|      0|    fn get_mapped_regions(&self) -> Box<dyn ExactSizeIterator<Item = &MemoryRegion> + '_> {
  570|      0|        Box::new(self.mmap_regions.iter().map(|(region, _)| region))
  571|      0|    }
  572|       |
  573|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  574|      0|    fn dispatch_call_from_host(
  575|      0|        &mut self,
  576|      0|        dispatch_func_addr: RawPtr,
  577|      0|        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
  578|      0|    ) -> Result<()> {
  579|       |        // Reset general purpose registers, then set RIP and RSP
  580|       |        let regs = kvm_regs {
  581|       |            rip: dispatch_func_addr.into(),
  582|       |            rsp: self.orig_rsp.absolute()?,
  583|       |            ..Default::default()
  584|       |        };
  585|       |        self.vcpu_fd.set_regs(&regs)?;
  586|       |
  587|       |        // reset fpu state
  588|       |        let fpu = kvm_fpu {
  589|       |            fcw: FP_CONTROL_WORD_DEFAULT,
  590|       |            ftwx: FP_TAG_WORD_DEFAULT,
  591|       |            mxcsr: MXCSR_DEFAULT,
  592|       |            ..Default::default() // zero out the rest
  593|       |        };
  594|       |        self.vcpu_fd.set_fpu(&fpu)?;
  595|       |
  596|       |        // run
  597|       |        VirtualCPU::run(
  598|       |            self.as_mut_hypervisor(),
  599|       |            #[cfg(gdb)]
  600|       |            dbg_mem_access_fn,
  601|       |        )?;
  602|       |
  603|       |        Ok(())
  604|      0|    }
  605|       |
  606|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  607|      0|    fn handle_io(
  608|      0|        &mut self,
  609|      0|        port: u16,
  610|      0|        data: Vec<u8>,
  611|      0|        _rip: u64,
  612|      0|        _instruction_length: u64,
  613|      0|    ) -> Result<()> {
  614|       |        // KVM does not need RIP or instruction length, as it automatically sets the RIP
  615|       |
  616|       |        // The payload param for the outb_handle_fn is the first byte
  617|       |        // of the data array cast to an u64. Thus, we need to make sure
  618|       |        // the data array has at least one u8, then convert that to an u64
  619|       |        if data.is_empty() {
  620|       |            log_then_return!("no data was given in IO interrupt");
  621|       |        } else {
  622|       |            let mut padded = [0u8; 4];
  623|       |            let copy_len = data.len().min(4);
  624|       |            padded[..copy_len].copy_from_slice(&data[..copy_len]);
  625|       |            let value = u32::from_le_bytes(padded);
  626|       |
  627|       |            #[cfg(feature = "trace_guest")]
  628|       |            {
  629|       |                // We need to handle the borrow checker issue where we need both:
  630|       |                // - &mut MemMgrWrapper (from self.mem_mgr.as_mut())
  631|       |                // - &mut dyn Hypervisor (from self)
  632|       |                // We'll use a temporary approach to extract the mem_mgr temporarily
  633|       |                let mem_mgr_option = self.mem_mgr.take();
  634|       |                let mut mem_mgr =
  635|       |                    mem_mgr_option.ok_or_else(|| new_error!("mem_mgr not initialized"))?;
  636|       |                let host_funcs = self
  637|       |                    .host_funcs
  638|       |                    .as_ref()
  639|       |                    .ok_or_else(|| new_error!("host_funcs not initialized"))?
  640|       |                    .clone();
  641|       |
  642|       |                handle_outb(&mut mem_mgr, host_funcs, self, port, value)?;
  643|       |
  644|       |                // Put the mem_mgr back
  645|       |                self.mem_mgr = Some(mem_mgr);
  646|       |            }
  647|       |
  648|       |            #[cfg(not(feature = "trace_guest"))]
  649|       |            {
  650|       |                let mem_mgr = self
  651|       |                    .mem_mgr
  652|       |                    .as_mut()
  653|      0|                    .ok_or_else(|| new_error!("mem_mgr not initialized"))?;
  654|       |                let host_funcs = self
  655|       |                    .host_funcs
  656|       |                    .as_ref()
  657|      0|                    .ok_or_else(|| new_error!("host_funcs not initialized"))?
  658|       |                    .clone();
  659|       |
  660|       |                handle_outb(mem_mgr, host_funcs, port, value)?;
  661|       |            }
  662|       |        }
  663|       |
  664|       |        Ok(())
  665|      0|    }
  666|       |
  667|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  668|      0|    fn run(&mut self) -> Result<HyperlightExit> {
  669|       |        self.interrupt_handle
  670|       |            .tid
  671|       |            .store(unsafe { libc::pthread_self() as u64 }, Ordering::Relaxed);
  672|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  673|       |        // Then this is fine since `cancel_requested` is set to true, so we will skip the `VcpuFd::run()` call
  674|       |        self.interrupt_handle
  675|       |            .set_running_and_increment_generation()
  676|      0|            .map_err(|e| {
  677|      0|                new_error!(
  678|      0|                    "Error setting running state and incrementing generation: {}",
  679|      0|                    e
  680|      0|                )
  681|      0|            })?;
  682|       |        #[cfg(not(gdb))]
  683|       |        let debug_interrupt = false;
  684|       |        #[cfg(gdb)]
  685|       |        let debug_interrupt = self
  686|       |            .interrupt_handle
  687|       |            .debug_interrupt
  688|       |            .load(Ordering::Relaxed);
  689|       |        // Don't run the vcpu if `cancel_requested` is true
  690|       |        //
  691|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  692|       |        // Then this is fine since `cancel_requested` is set to true, so we will skip the `VcpuFd::run()` call
  693|       |        let exit_reason = if self
  694|       |            .interrupt_handle
  695|       |            .cancel_requested
  696|       |            .load(Ordering::Relaxed)
  697|       |            || debug_interrupt
  698|       |        {
  699|       |            Err(kvm_ioctls::Error::new(libc::EINTR))
  700|       |        } else {
  701|       |            #[cfg(feature = "trace_guest")]
  702|       |            if self.trace_info.guest_start_epoch.is_none() {
  703|       |                // Store the guest start epoch and cycles to trace the guest execution time
  704|       |                crate::debug!("KVM - Guest Start Epoch set");
  705|       |                self.trace_info.guest_start_epoch = Some(std::time::Instant::now());
  706|       |                self.trace_info.guest_start_tsc =
  707|       |                    Some(hyperlight_guest_tracing::invariant_tsc::read_tsc());
  708|       |            }
  709|       |
  710|       |            // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  711|       |            // Then the vcpu will run, but we will keep sending signals to this thread
  712|       |            // to interrupt it until `running` is set to false. The `vcpu_fd::run()` call will
  713|       |            // return either normally with an exit reason, or from being "kicked" by out signal handler, with an EINTR error,
  714|       |            // both of which are fine.
  715|       |            self.vcpu_fd.run()
  716|       |        };
  717|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  718|       |        // Then signals will be sent to this thread until `running` is set to false.
  719|       |        // This is fine since the signal handler is a no-op.
  720|       |        let cancel_requested = self
  721|       |            .interrupt_handle
  722|       |            .cancel_requested
  723|       |            .load(Ordering::Relaxed);
  724|       |        #[cfg(gdb)]
  725|       |        let debug_interrupt = self
  726|       |            .interrupt_handle
  727|       |            .debug_interrupt
  728|       |            .load(Ordering::Relaxed);
  729|       |        // Note: if a `InterruptHandle::kill()` called while this thread is **here**
  730|       |        // Then `cancel_requested` will be set to true again, which will cancel the **next vcpu run**.
  731|       |        // Additionally signals will be sent to this thread until `running` is set to false.
  732|       |        // This is fine since the signal handler is a no-op.
  733|       |        self.interrupt_handle.clear_running_bit();
  734|       |        // At this point, `running` is false so no more signals will be sent to this thread,
  735|       |        // but we may still receive async signals that were sent before this point.
  736|       |        // To prevent those signals from interrupting subsequent calls to `run()` (on other vms!),
  737|       |        // we make sure to check `cancel_requested` before cancelling (see `libc::EINTR` match-arm below).
  738|       |        let result = match exit_reason {
  739|       |            Ok(VcpuExit::Hlt) => {
  740|       |                crate::debug!("KVM - Halt Details : {:#?}", &self);
  741|       |                HyperlightExit::Halt()
  742|       |            }
  743|       |            Ok(VcpuExit::IoOut(port, data)) => {
  744|       |                // because vcpufd.run() mutably borrows self we cannot pass self to crate::debug! macro here
  745|       |                crate::debug!("KVM IO Details : \nPort : {}\nData : {:?}", port, data);
  746|       |                // KVM does not need to set RIP or instruction length so these are set to 0
  747|       |                HyperlightExit::IoOut(port, data.to_vec(), 0, 0)
  748|       |            }
  749|       |            Ok(VcpuExit::MmioRead(addr, _)) => {
  750|       |                crate::debug!("KVM MMIO Read -Details: Address: {} \n {:#?}", addr, &self);
  751|       |
  752|       |                match get_memory_access_violation(
  753|       |                    addr as usize,
  754|       |                    self.sandbox_regions
  755|       |                        .iter()
  756|      0|                        .chain(self.mmap_regions.iter().map(|(r, _)| r)),
  757|       |                    MemoryRegionFlags::READ,
  758|       |                ) {
  759|       |                    Some(access_violation_exit) => access_violation_exit,
  760|       |                    None => HyperlightExit::Mmio(addr),
  761|       |                }
  762|       |            }
  763|       |            Ok(VcpuExit::MmioWrite(addr, _)) => {
  764|       |                crate::debug!("KVM MMIO Write -Details: Address: {} \n {:#?}", addr, &self);
  765|       |
  766|       |                match get_memory_access_violation(
  767|       |                    addr as usize,
  768|       |                    self.sandbox_regions
  769|       |                        .iter()
  770|      0|                        .chain(self.mmap_regions.iter().map(|(r, _)| r)),
  771|       |                    MemoryRegionFlags::WRITE,
  772|       |                ) {
  773|       |                    Some(access_violation_exit) => access_violation_exit,
  774|       |                    None => HyperlightExit::Mmio(addr),
  775|       |                }
  776|       |            }
  777|       |            #[cfg(gdb)]
  778|       |            // KVM provides architecture specific information about the vCPU state when exiting
  779|       |            Ok(VcpuExit::Debug(debug_exit)) => match self.get_stop_reason(debug_exit) {
  780|       |                Ok(reason) => HyperlightExit::Debug(reason),
  781|       |                Err(e) => {
  782|       |                    log_then_return!("Error getting stop reason: {:?}", e);
  783|       |                }
  784|       |            },
  785|       |            Err(e) => match e.errno() {
  786|       |                // we send a signal to the thread to cancel execution this results in EINTR being returned by KVM so we return Cancelled
  787|       |                libc::EINTR => {
  788|       |                    // If cancellation was not requested for this specific vm, the vcpu was interrupted because of debug interrupt or
  789|       |                    // a stale signal that meant to be delivered to a previous/other vcpu on this same thread, so let's ignore it
  790|       |                    if cancel_requested {
  791|       |                        self.interrupt_handle
  792|       |                            .cancel_requested
  793|       |                            .store(false, Ordering::Relaxed);
  794|       |                        HyperlightExit::Cancelled()
  795|       |                    } else {
  796|       |                        #[cfg(gdb)]
  797|       |                        if debug_interrupt {
  798|       |                            self.interrupt_handle
  799|       |                                .debug_interrupt
  800|       |                                .store(false, Ordering::Relaxed);
  801|       |
  802|       |                            // If the vCPU was stopped because of an interrupt, we need to
  803|       |                            // return a special exit reason so that the gdb thread can handle it
  804|       |                            // and resume execution
  805|       |                            HyperlightExit::Debug(VcpuStopReason::Interrupt)
  806|       |                        } else {
  807|       |                            HyperlightExit::Retry()
  808|       |                        }
  809|       |
  810|       |                        #[cfg(not(gdb))]
  811|       |                        HyperlightExit::Retry()
  812|       |                    }
  813|       |                }
  814|       |                libc::EAGAIN => HyperlightExit::Retry(),
  815|       |                _ => {
  816|       |                    crate::debug!("KVM Error -Details: Address: {} \n {:#?}", e, &self);
  817|       |                    log_then_return!("Error running VCPU {:?}", e);
  818|       |                }
  819|       |            },
  820|       |            Ok(other) => {
  821|       |                let err_msg = format!("Unexpected KVM Exit {:?}", other);
  822|       |                crate::debug!("KVM Other Exit Details: {:#?}", &self);
  823|       |                HyperlightExit::Unknown(err_msg)
  824|       |            }
  825|       |        };
  826|       |        Ok(result)
  827|      0|    }
  828|       |
  829|       |    #[instrument(skip_all, parent = Span::current(), level = "Trace")]
  830|      0|    fn as_mut_hypervisor(&mut self) -> &mut dyn Hypervisor {
  831|      0|        self as &mut dyn Hypervisor
  832|      0|    }
  833|       |
  834|      0|    fn interrupt_handle(&self) -> Arc<dyn InterruptHandle> {
  835|      0|        self.interrupt_handle.clone()
  836|      0|    }
  837|       |
  838|       |    #[cfg(crashdump)]
  839|       |    fn crashdump_context(&self) -> Result<Option<crashdump::CrashDumpContext>> {
  840|       |        if self.rt_cfg.guest_core_dump {
  841|       |            let mut regs = [0; 27];
  842|       |
  843|       |            let vcpu_regs = self.vcpu_fd.get_regs()?;
  844|       |            let sregs = self.vcpu_fd.get_sregs()?;
  845|       |            let xsave = self.vcpu_fd.get_xsave()?;
  846|       |
  847|       |            // Set the registers in the order expected by the crashdump context
  848|       |            regs[0] = vcpu_regs.r15; // r15
  849|       |            regs[1] = vcpu_regs.r14; // r14
  850|       |            regs[2] = vcpu_regs.r13; // r13
  851|       |            regs[3] = vcpu_regs.r12; // r12
  852|       |            regs[4] = vcpu_regs.rbp; // rbp
  853|       |            regs[5] = vcpu_regs.rbx; // rbx
  854|       |            regs[6] = vcpu_regs.r11; // r11
  855|       |            regs[7] = vcpu_regs.r10; // r10
  856|       |            regs[8] = vcpu_regs.r9; // r9
  857|       |            regs[9] = vcpu_regs.r8; // r8
  858|       |            regs[10] = vcpu_regs.rax; // rax
  859|       |            regs[11] = vcpu_regs.rcx; // rcx
  860|       |            regs[12] = vcpu_regs.rdx; // rdx
  861|       |            regs[13] = vcpu_regs.rsi; // rsi
  862|       |            regs[14] = vcpu_regs.rdi; // rdi
  863|       |            regs[15] = 0; // orig rax
  864|       |            regs[16] = vcpu_regs.rip; // rip
  865|       |            regs[17] = sregs.cs.selector as u64; // cs
  866|       |            regs[18] = vcpu_regs.rflags; // eflags
  867|       |            regs[19] = vcpu_regs.rsp; // rsp
  868|       |            regs[20] = sregs.ss.selector as u64; // ss
  869|       |            regs[21] = sregs.fs.base; // fs_base
  870|       |            regs[22] = sregs.gs.base; // gs_base
  871|       |            regs[23] = sregs.ds.selector as u64; // ds
  872|       |            regs[24] = sregs.es.selector as u64; // es
  873|       |            regs[25] = sregs.fs.selector as u64; // fs
  874|       |            regs[26] = sregs.gs.selector as u64; // gs
  875|       |
  876|       |            // Get the filename from the runtime config
  877|       |            let filename = self.rt_cfg.binary_path.clone().and_then(|path| {
  878|       |                Path::new(&path)
  879|       |                    .file_name()
  880|       |                    .and_then(|name| name.to_os_string().into_string().ok())
  881|       |            });
  882|       |
  883|       |            // The [`CrashDumpContext`] accepts xsave as a vector of u8, so we need to convert the
  884|       |            // xsave region to a vector of u8
  885|       |            Ok(Some(crashdump::CrashDumpContext::new(
  886|       |                &self.sandbox_regions,
  887|       |                regs,
  888|       |                xsave
  889|       |                    .region
  890|       |                    .iter()
  891|       |                    .flat_map(|item| item.to_le_bytes())
  892|       |                    .collect::<Vec<u8>>(),
  893|       |                self.entrypoint,
  894|       |                self.rt_cfg.binary_path.clone(),
  895|       |                filename,
  896|       |            )))
  897|       |        } else {
  898|       |            Ok(None)
  899|       |        }
  900|       |    }
  901|       |
  902|       |    #[cfg(gdb)]
  903|       |    fn handle_debug(
  904|       |        &mut self,
  905|       |        dbg_mem_access_fn: Arc<Mutex<dyn super::handlers::DbgMemAccessHandlerCaller>>,
  906|       |        stop_reason: VcpuStopReason,
  907|       |    ) -> Result<()> {
  908|       |        if self.debug.is_none() {
  909|       |            return Err(new_error!("Debugging is not enabled"));
  910|       |        }
  911|       |
  912|       |        match stop_reason {
  913|       |            // If the vCPU stopped because of a crash, we need to handle it differently
  914|       |            // We do not want to allow resuming execution or placing breakpoints
  915|       |            // because the guest has crashed.
  916|       |            // We only allow reading registers and memory
  917|       |            VcpuStopReason::Crash => {
  918|       |                self.send_dbg_msg(DebugResponse::VcpuStopped(stop_reason))
  919|       |                    .map_err(|e| {
  920|       |                        new_error!("Couldn't signal vCPU stopped event to GDB thread: {:?}", e)
  921|       |                    })?;
  922|       |
  923|       |                loop {
  924|       |                    log::debug!("Debug wait for event to resume vCPU");
  925|       |                    // Wait for a message from gdb
  926|       |                    let req = self.recv_dbg_msg()?;
  927|       |
  928|       |                    // Flag to store if we should deny continue or step requests
  929|       |                    let mut deny_continue = false;
  930|       |                    // Flag to store if we should detach from the gdb session
  931|       |                    let mut detach = false;
  932|       |
  933|       |                    let response = match req {
  934|       |                        // Allow the detach request to disable debugging by continuing resuming
  935|       |                        // hypervisor crash error reporting
  936|       |                        DebugMsg::DisableDebug => {
  937|       |                            detach = true;
  938|       |                            DebugResponse::DisableDebug
  939|       |                        }
  940|       |                        // Do not allow continue or step requests
  941|       |                        DebugMsg::Continue | DebugMsg::Step => {
  942|       |                            deny_continue = true;
  943|       |                            DebugResponse::NotAllowed
  944|       |                        }
  945|       |                        // Do not allow adding/removing breakpoints and writing to memory or registers
  946|       |                        DebugMsg::AddHwBreakpoint(_)
  947|       |                        | DebugMsg::AddSwBreakpoint(_)
  948|       |                        | DebugMsg::RemoveHwBreakpoint(_)
  949|       |                        | DebugMsg::RemoveSwBreakpoint(_)
  950|       |                        | DebugMsg::WriteAddr(_, _)
  951|       |                        | DebugMsg::WriteRegisters(_) => DebugResponse::NotAllowed,
  952|       |
  953|       |                        // For all other requests, we will process them normally
  954|       |                        _ => {
  955|       |                            let result = self.process_dbg_request(req, dbg_mem_access_fn.clone());
  956|       |                            match result {
  957|       |                                Ok(response) => response,
  958|       |                                Err(HyperlightError::TranslateGuestAddress(_)) => {
  959|       |                                    // Treat non fatal errors separately so the guest doesn't fail
  960|       |                                    DebugResponse::ErrorOccurred
  961|       |                                }
  962|       |                                Err(e) => {
  963|       |                                    log::error!("Error processing debug request: {:?}", e);
  964|       |                                    return Err(e);
  965|       |                                }
  966|       |                            }
  967|       |                        }
  968|       |                    };
  969|       |
  970|       |                    // Send the response to the request back to gdb
  971|       |                    self.send_dbg_msg(response)
  972|       |                        .map_err(|e| new_error!("Couldn't send response to gdb: {:?}", e))?;
  973|       |
  974|       |                    // If we are denying continue or step requests, the debugger assumes the
  975|       |                    // execution started so we need to report a stop reason as a crash and let
  976|       |                    // it request to read registers/memory to figure out what happened
  977|       |                    if deny_continue {
  978|       |                        self.send_dbg_msg(DebugResponse::VcpuStopped(VcpuStopReason::Crash))
  979|       |                            .map_err(|e| new_error!("Couldn't send response to gdb: {:?}", e))?;
  980|       |                    }
  981|       |
  982|       |                    // If we are detaching, we will break the loop and the Hypervisor will continue
  983|       |                    // to handle the Crash reason
  984|       |                    if detach {
  985|       |                        break;
  986|       |                    }
  987|       |                }
  988|       |            }
  989|       |            // If the vCPU stopped because of any other reason except a crash, we can handle it
  990|       |            // normally
  991|       |            _ => {
  992|       |                // Send the stop reason to the gdb thread
  993|       |                self.send_dbg_msg(DebugResponse::VcpuStopped(stop_reason))
  994|       |                    .map_err(|e| {
  995|       |                        new_error!("Couldn't signal vCPU stopped event to GDB thread: {:?}", e)
  996|       |                    })?;
  997|       |
  998|       |                loop {
  999|       |                    log::debug!("Debug wait for event to resume vCPU");
 1000|       |                    // Wait for a message from gdb
 1001|       |                    let req = self.recv_dbg_msg()?;
 1002|       |
 1003|       |                    let result = self.process_dbg_request(req, dbg_mem_access_fn.clone());
 1004|       |
 1005|       |                    let response = match result {
 1006|       |                        Ok(response) => response,
 1007|       |                        // Treat non fatal errors separately so the guest doesn't fail
 1008|       |                        Err(HyperlightError::TranslateGuestAddress(_)) => {
 1009|       |                            DebugResponse::ErrorOccurred
 1010|       |                        }
 1011|       |                        Err(e) => {
 1012|       |                            return Err(e);
 1013|       |                        }
 1014|       |                    };
 1015|       |
 1016|       |                    let cont = matches!(
 1017|       |                        response,
 1018|       |                        DebugResponse::Continue | DebugResponse::Step | DebugResponse::DisableDebug
 1019|       |                    );
 1020|       |
 1021|       |                    self.send_dbg_msg(response)
 1022|       |                        .map_err(|e| new_error!("Couldn't send response to gdb: {:?}", e))?;
 1023|       |
 1024|       |                    // Check if we should continue execution
 1025|       |                    // We continue if the response is one of the following: Step, Continue, or DisableDebug
 1026|       |                    if cont {
 1027|       |                        break;
 1028|       |                    }
 1029|       |                }
 1030|       |            }
 1031|       |        }
 1032|       |
 1033|       |        Ok(())
 1034|       |    }
 1035|       |
 1036|      0|    fn check_stack_guard(&self) -> Result<bool> {
 1037|      0|        if let Some(mgr) = self.mem_mgr.as_ref() {
 1038|      0|            mgr.check_stack_guard()
 1039|       |        } else {
 1040|      0|            Err(new_error!("Memory manager is not initialized"))
 1041|       |        }
 1042|      0|    }
 1043|       |
 1044|       |    #[cfg(feature = "trace_guest")]
 1045|       |    fn read_trace_reg(&self, reg: TraceRegister) -> Result<u64> {
 1046|       |        let regs = self.vcpu_fd.get_regs()?;
 1047|       |        Ok(match reg {
 1048|       |            TraceRegister::RAX => regs.rax,
 1049|       |            TraceRegister::RCX => regs.rcx,
 1050|       |            TraceRegister::RIP => regs.rip,
 1051|       |            TraceRegister::RSP => regs.rsp,
 1052|       |            TraceRegister::RBP => regs.rbp,
 1053|       |        })
 1054|       |    }
 1055|       |
 1056|       |    #[cfg(feature = "trace_guest")]
 1057|       |    fn trace_info_as_ref(&self) -> &TraceInfo {
 1058|       |        &self.trace_info
 1059|       |    }
 1060|       |    #[cfg(feature = "trace_guest")]
 1061|       |    fn trace_info_as_mut(&mut self) -> &mut TraceInfo {
 1062|       |        &mut self.trace_info
 1063|       |    }
 1064|       |}
 1065|       |
 1066|       |impl Drop for KVMDriver {
 1067|      0|    fn drop(&mut self) {
 1068|      0|        self.interrupt_handle.dropped.store(true, Ordering::Relaxed);
 1069|      0|    }
 1070|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/hypervisor/mod.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use log::LevelFilter;
   18|       |use tracing::{Span, instrument};
   19|       |
   20|       |use crate::error::HyperlightError::ExecutionCanceledByHost;
   21|       |use crate::mem::memory_region::{MemoryRegion, MemoryRegionFlags};
   22|       |use crate::metrics::METRIC_GUEST_CANCELLATION;
   23|       |#[cfg(feature = "trace_guest")]
   24|       |use crate::sandbox::TraceInfo;
   25|       |use crate::{HyperlightError, Result, log_then_return};
   26|       |
   27|       |/// Util for handling x87 fpu state
   28|       |#[cfg(any(kvm, mshv, target_os = "windows"))]
   29|       |pub mod fpu;
   30|       |/// Handlers for Hypervisor custom logic
   31|       |#[cfg(gdb)]
   32|       |pub mod handlers;
   33|       |/// HyperV-on-linux functionality
   34|       |#[cfg(mshv)]
   35|       |pub mod hyperv_linux;
   36|       |#[cfg(target_os = "windows")]
   37|       |/// Hyperv-on-windows functionality
   38|       |pub(crate) mod hyperv_windows;
   39|       |
   40|       |/// GDB debugging support
   41|       |#[cfg(gdb)]
   42|       |pub(crate) mod gdb;
   43|       |
   44|       |#[cfg(kvm)]
   45|       |/// Functionality to manipulate KVM-based virtual machines
   46|       |pub mod kvm;
   47|       |#[cfg(target_os = "windows")]
   48|       |/// Hyperlight Surrogate Process
   49|       |pub(crate) mod surrogate_process;
   50|       |#[cfg(target_os = "windows")]
   51|       |/// Hyperlight Surrogate Process
   52|       |pub(crate) mod surrogate_process_manager;
   53|       |/// WindowsHypervisorPlatform utilities
   54|       |#[cfg(target_os = "windows")]
   55|       |pub(crate) mod windows_hypervisor_platform;
   56|       |/// Safe wrappers around windows types like `PSTR`
   57|       |#[cfg(target_os = "windows")]
   58|       |pub(crate) mod wrappers;
   59|       |
   60|       |#[cfg(crashdump)]
   61|       |pub(crate) mod crashdump;
   62|       |
   63|       |use std::fmt::Debug;
   64|       |use std::str::FromStr;
   65|       |#[cfg(any(kvm, mshv))]
   66|       |use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
   67|       |use std::sync::{Arc, Mutex};
   68|       |#[cfg(any(kvm, mshv))]
   69|       |use std::time::Duration;
   70|       |
   71|       |#[cfg(gdb)]
   72|       |use gdb::VcpuStopReason;
   73|       |
   74|       |#[cfg(gdb)]
   75|       |use self::handlers::{DbgMemAccessHandlerCaller, DbgMemAccessHandlerWrapper};
   76|       |use crate::mem::ptr::RawPtr;
   77|       |use crate::mem::shared_mem::HostSharedMemory;
   78|       |use crate::sandbox::host_funcs::FunctionRegistry;
   79|       |use crate::sandbox::mem_access::handle_mem_access;
   80|       |use crate::sandbox::mem_mgr::MemMgrWrapper;
   81|       |
   82|       |cfg_if::cfg_if! {
   83|       |    if #[cfg(feature = "init-paging")] {
   84|       |        pub(crate) const CR4_PAE: u64 = 1 << 5;
   85|       |        pub(crate) const CR4_OSFXSR: u64 = 1 << 9;
   86|       |        pub(crate) const CR4_OSXMMEXCPT: u64 = 1 << 10;
   87|       |        pub(crate) const CR0_PE: u64 = 1;
   88|       |        pub(crate) const CR0_MP: u64 = 1 << 1;
   89|       |        pub(crate) const CR0_ET: u64 = 1 << 4;
   90|       |        pub(crate) const CR0_NE: u64 = 1 << 5;
   91|       |        pub(crate) const CR0_WP: u64 = 1 << 16;
   92|       |        pub(crate) const CR0_AM: u64 = 1 << 18;
   93|       |        pub(crate) const CR0_PG: u64 = 1 << 31;
   94|       |        pub(crate) const EFER_LME: u64 = 1 << 8;
   95|       |        pub(crate) const EFER_LMA: u64 = 1 << 10;
   96|       |        pub(crate) const EFER_SCE: u64 = 1;
   97|       |        pub(crate) const EFER_NX: u64 = 1 << 11;
   98|       |    }
   99|       |}
  100|       |
  101|       |/// These are the generic exit reasons that we can handle from a Hypervisor the Hypervisors run method is responsible for mapping from
  102|       |/// the hypervisor specific exit reasons to these generic ones
  103|       |pub enum HyperlightExit {
  104|       |    #[cfg(gdb)]
  105|       |    /// The vCPU has exited due to a debug event
  106|       |    Debug(VcpuStopReason),
  107|       |    /// The vCPU has halted
  108|       |    Halt(),
  109|       |    /// The vCPU has issued a write to the given port with the given value
  110|       |    IoOut(u16, Vec<u8>, u64, u64),
  111|       |    /// The vCPU has attempted to read or write from an unmapped address
  112|       |    Mmio(u64),
  113|       |    /// The vCPU tried to access memory but was missing the required permissions
  114|       |    AccessViolation(u64, MemoryRegionFlags, MemoryRegionFlags),
  115|       |    /// The vCPU execution has been cancelled
  116|       |    Cancelled(),
  117|       |    /// The vCPU has exited for a reason that is not handled by Hyperlight
  118|       |    Unknown(String),
  119|       |    /// The operation should be retried, for example this can happen on Linux where a call to run the CPU can return EAGAIN
  120|       |    Retry(),
  121|       |}
  122|       |
  123|       |/// Registers which may be useful for tracing/stack unwinding
  124|       |#[cfg(feature = "trace_guest")]
  125|       |pub enum TraceRegister {
  126|       |    /// RAX
  127|       |    RAX,
  128|       |    /// RCX
  129|       |    RCX,
  130|       |    /// RIP
  131|       |    RIP,
  132|       |    /// RSP
  133|       |    RSP,
  134|       |    /// RBP
  135|       |    RBP,
  136|       |}
  137|       |
  138|       |/// A common set of hypervisor functionality
  139|       |pub(crate) trait Hypervisor: Debug + Send {
  140|       |    /// Initialise the internally stored vCPU with the given PEB address and
  141|       |    /// random number seed, then run it until a HLT instruction.
  142|       |    #[allow(clippy::too_many_arguments)]
  143|       |    fn initialise(
  144|       |        &mut self,
  145|       |        peb_addr: RawPtr,
  146|       |        seed: u64,
  147|       |        page_size: u32,
  148|       |        mem_mgr: MemMgrWrapper<HostSharedMemory>,
  149|       |        host_funcs: Arc<Mutex<FunctionRegistry>>,
  150|       |        guest_max_log_level: Option<LevelFilter>,
  151|       |        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
  152|       |    ) -> Result<()>;
  153|       |
  154|       |    /// Map a region of host memory into the sandbox.
  155|       |    ///
  156|       |    /// Depending on the host platform, there are likely alignment
  157|       |    /// requirements of at least one page for base and len.
  158|       |    unsafe fn map_region(&mut self, rgn: &MemoryRegion) -> Result<()>;
  159|       |
  160|       |    /// Unmap a memory region from the sandbox
  161|       |    unsafe fn unmap_region(&mut self, rgn: &MemoryRegion) -> Result<()>;
  162|       |
  163|       |    /// Get the currently mapped dynamic memory regions (not including sandbox regions)
  164|       |    ///
  165|       |    /// Note: Box needed for trait to be object-safe :(
  166|       |    fn get_mapped_regions(&self) -> Box<dyn ExactSizeIterator<Item = &MemoryRegion> + '_>;
  167|       |
  168|       |    /// Dispatch a call from the host to the guest using the given pointer
  169|       |    /// to the dispatch function _in the guest's address space_.
  170|       |    ///
  171|       |    /// Do this by setting the instruction pointer to `dispatch_func_addr`
  172|       |    /// and then running the execution loop until a halt instruction.
  173|       |    ///
  174|       |    /// Returns `Ok` if the call succeeded, and an `Err` if it failed
  175|       |    fn dispatch_call_from_host(
  176|       |        &mut self,
  177|       |        dispatch_func_addr: RawPtr,
  178|       |        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
  179|       |    ) -> Result<()>;
  180|       |
  181|       |    /// Handle an IO exit from the internally stored vCPU.
  182|       |    fn handle_io(
  183|       |        &mut self,
  184|       |        port: u16,
  185|       |        data: Vec<u8>,
  186|       |        rip: u64,
  187|       |        instruction_length: u64,
  188|       |    ) -> Result<()>;
  189|       |
  190|       |    /// Run the vCPU
  191|       |    fn run(&mut self) -> Result<HyperlightExit>;
  192|       |
  193|       |    /// Get InterruptHandle to underlying VM
  194|       |    fn interrupt_handle(&self) -> Arc<dyn InterruptHandle>;
  195|       |
  196|       |    /// Get the logging level to pass to the guest entrypoint
  197|      0|    fn get_max_log_level(&self) -> u32 {
  198|      0|        // Check to see if the RUST_LOG environment variable is set
  199|      0|        // and if so, parse it to get the log_level for hyperlight_guest
  200|      0|        // if that is not set get the log level for the hyperlight_host
  201|      0|
  202|      0|        // This is done as the guest will produce logs based on the log level returned here
  203|      0|        // producing those logs is expensive and we don't want to do it if the host is not
  204|      0|        // going to process them
  205|      0|
  206|      0|        let val = std::env::var("RUST_LOG").unwrap_or_default();
  207|       |
  208|      0|        let level = if val.contains("hyperlight_guest") {
  209|      0|            val.split(',')
  210|      0|                .find(|s| s.contains("hyperlight_guest"))
  211|      0|                .unwrap_or("")
  212|      0|                .split('=')
  213|      0|                .nth(1)
  214|      0|                .unwrap_or("")
  215|      0|        } else if val.contains("hyperlight_host") {
  216|      0|            val.split(',')
  217|      0|                .find(|s| s.contains("hyperlight_host"))
  218|      0|                .unwrap_or("")
  219|      0|                .split('=')
  220|      0|                .nth(1)
  221|      0|                .unwrap_or("")
  222|       |        } else {
  223|       |            // look for a value string that does not contain "="
  224|      0|            val.split(',').find(|s| !s.contains("=")).unwrap_or("")
  225|       |        };
  226|       |
  227|      0|        log::info!("Determined guest log level: {}", level);
  228|       |        // Convert the log level string to a LevelFilter
  229|       |        // If no value is found, default to Error
  230|      0|        LevelFilter::from_str(level).unwrap_or(LevelFilter::Error) as u32
  231|      0|    }
  232|       |
  233|       |    /// get a mutable trait object from self
  234|       |    fn as_mut_hypervisor(&mut self) -> &mut dyn Hypervisor;
  235|       |
  236|       |    #[cfg(crashdump)]
  237|       |    fn crashdump_context(&self) -> Result<Option<crashdump::CrashDumpContext>>;
  238|       |
  239|       |    #[cfg(gdb)]
  240|       |    /// handles the cases when the vCPU stops due to a Debug event
  241|       |    fn handle_debug(
  242|       |        &mut self,
  243|       |        _dbg_mem_access_fn: Arc<Mutex<dyn DbgMemAccessHandlerCaller>>,
  244|       |        _stop_reason: VcpuStopReason,
  245|       |    ) -> Result<()> {
  246|       |        unimplemented!()
  247|       |    }
  248|       |
  249|       |    /// Check stack guard to see if the stack is still valid
  250|       |    fn check_stack_guard(&self) -> Result<bool>;
  251|       |
  252|       |    /// Read a register for trace/unwind purposes
  253|       |    #[cfg(feature = "trace_guest")]
  254|       |    fn read_trace_reg(&self, reg: TraceRegister) -> Result<u64>;
  255|       |
  256|       |    /// Get a reference of the trace info for the guest
  257|       |    #[cfg(feature = "trace_guest")]
  258|       |    fn trace_info_as_ref(&self) -> &TraceInfo;
  259|       |    /// Get a mutable reference of the trace info for the guest
  260|       |    #[cfg(feature = "trace_guest")]
  261|       |    fn trace_info_as_mut(&mut self) -> &mut TraceInfo;
  262|       |}
  263|       |
  264|       |/// Returns a Some(HyperlightExit::AccessViolation(..)) if the given gpa doesn't have
  265|       |/// access its corresponding region. Returns None otherwise, or if the region is not found.
  266|      0|pub(crate) fn get_memory_access_violation<'a>(
  267|      0|    gpa: usize,
  268|      0|    mut mem_regions: impl Iterator<Item = &'a MemoryRegion>,
  269|      0|    access_info: MemoryRegionFlags,
  270|      0|) -> Option<HyperlightExit> {
  271|      0|    // find the region containing the given gpa
  272|      0|    let region = mem_regions.find(|region| region.guest_region.contains(&gpa));
  273|       |
  274|      0|    if let Some(region) = region {
  275|      0|        if !region.flags.contains(access_info)
  276|      0|            || region.flags.contains(MemoryRegionFlags::STACK_GUARD)
  277|       |        {
  278|      0|            return Some(HyperlightExit::AccessViolation(
  279|      0|                gpa as u64,
  280|      0|                access_info,
  281|      0|                region.flags,
  282|      0|            ));
  283|      0|        }
  284|      0|    }
  285|      0|    None
  286|      0|}
  287|       |
  288|       |/// A virtual CPU that can be run until an exit occurs
  289|       |pub struct VirtualCPU {}
  290|       |
  291|       |impl VirtualCPU {
  292|       |    /// Run the given hypervisor until a halt instruction is reached
  293|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  294|      0|    pub(crate) fn run(
  295|      0|        hv: &mut dyn Hypervisor,
  296|      0|        #[cfg(gdb)] dbg_mem_access_fn: Arc<Mutex<dyn DbgMemAccessHandlerCaller>>,
  297|      0|    ) -> Result<()> {
  298|       |        loop {
  299|       |            match hv.run() {
  300|       |                #[cfg(gdb)]
  301|       |                Ok(HyperlightExit::Debug(stop_reason)) => {
  302|       |                    if let Err(e) = hv.handle_debug(dbg_mem_access_fn.clone(), stop_reason) {
  303|       |                        log_then_return!(e);
  304|       |                    }
  305|       |                }
  306|       |
  307|       |                Ok(HyperlightExit::Halt()) => {
  308|       |                    break;
  309|       |                }
  310|       |                Ok(HyperlightExit::IoOut(port, data, rip, instruction_length)) => {
  311|       |                    hv.handle_io(port, data, rip, instruction_length)?
  312|       |                }
  313|       |                Ok(HyperlightExit::Mmio(addr)) => {
  314|       |                    #[cfg(crashdump)]
  315|       |                    crashdump::generate_crashdump(hv)?;
  316|       |
  317|       |                    handle_mem_access(hv)?;
  318|       |
  319|       |                    log_then_return!("MMIO access address {:#x}", addr);
  320|       |                }
  321|       |                Ok(HyperlightExit::AccessViolation(addr, tried, region_permission)) => {
  322|       |                    #[cfg(crashdump)]
  323|       |                    crashdump::generate_crashdump(hv)?;
  324|       |
  325|       |                    // If GDB is enabled, we handle the debug memory access
  326|       |                    // Disregard return value as we want to return the error
  327|       |                    #[cfg(gdb)]
  328|       |                    let _ = hv.handle_debug(dbg_mem_access_fn.clone(), VcpuStopReason::Crash);
  329|       |
  330|       |                    if region_permission.intersects(MemoryRegionFlags::STACK_GUARD) {
  331|       |                        return Err(HyperlightError::StackOverflow());
  332|       |                    }
  333|       |                    log_then_return!(HyperlightError::MemoryAccessViolation(
  334|       |                        addr,
  335|       |                        tried,
  336|       |                        region_permission
  337|       |                    ));
  338|       |                }
  339|       |                Ok(HyperlightExit::Cancelled()) => {
  340|       |                    // Shutdown is returned when the host has cancelled execution
  341|       |                    // After termination, the main thread will re-initialize the VM
  342|       |                    metrics::counter!(METRIC_GUEST_CANCELLATION).increment(1);
  343|       |                    log_then_return!(ExecutionCanceledByHost());
  344|       |                }
  345|       |                Ok(HyperlightExit::Unknown(reason)) => {
  346|       |                    #[cfg(crashdump)]
  347|       |                    crashdump::generate_crashdump(hv)?;
  348|       |                    // If GDB is enabled, we handle the debug memory access
  349|       |                    // Disregard return value as we want to return the error
  350|       |                    #[cfg(gdb)]
  351|       |                    let _ = hv.handle_debug(dbg_mem_access_fn.clone(), VcpuStopReason::Crash);
  352|       |
  353|       |                    log_then_return!("Unexpected VM Exit {:?}", reason);
  354|       |                }
  355|       |                Ok(HyperlightExit::Retry()) => continue,
  356|       |                Err(e) => {
  357|       |                    #[cfg(crashdump)]
  358|       |                    crashdump::generate_crashdump(hv)?;
  359|       |                    // If GDB is enabled, we handle the debug memory access
  360|       |                    // Disregard return value as we want to return the error
  361|       |                    #[cfg(gdb)]
  362|       |                    let _ = hv.handle_debug(dbg_mem_access_fn.clone(), VcpuStopReason::Crash);
  363|       |
  364|       |                    return Err(e);
  365|       |                }
  366|       |            }
  367|       |        }
  368|       |
  369|       |        Ok(())
  370|      0|    }
  371|       |}
  372|       |
  373|       |/// A trait for handling interrupts to a sandbox's vcpu
  374|       |pub trait InterruptHandle: Debug + Send + Sync {
  375|       |    /// Interrupt the corresponding sandbox from running.
  376|       |    ///
  377|       |    /// - If this is called while the vcpu is running, then it will interrupt the vcpu and return `true`.
  378|       |    /// - If this is called while the vcpu is not running, (for example during a host call), the
  379|       |    ///   vcpu will not immediately be interrupted, but will prevent the vcpu from running **the next time**
  380|       |    ///   it's scheduled, and returns `false`.
  381|       |    ///
  382|       |    /// # Note
  383|       |    /// This function will block for the duration of the time it takes for the vcpu thread to be interrupted.
  384|       |    fn kill(&self) -> bool;
  385|       |
  386|       |    /// Used by a debugger to interrupt the corresponding sandbox from running.
  387|       |    ///
  388|       |    /// - If this is called while the vcpu is running, then it will interrupt the vcpu and return `true`.
  389|       |    /// - If this is called while the vcpu is not running, (for example during a host call), the
  390|       |    ///   vcpu will not immediately be interrupted, but will prevent the vcpu from running **the next time**
  391|       |    ///   it's scheduled, and returns `false`.
  392|       |    ///
  393|       |    /// # Note
  394|       |    /// This function will block for the duration of the time it takes for the vcpu thread to be interrupted.
  395|       |    #[cfg(gdb)]
  396|       |    fn kill_from_debugger(&self) -> bool;
  397|       |
  398|       |    /// Returns true if the corresponding sandbox has been dropped
  399|       |    fn dropped(&self) -> bool;
  400|       |}
  401|       |
  402|       |#[cfg(any(kvm, mshv))]
  403|       |#[derive(Debug)]
  404|       |pub(super) struct LinuxInterruptHandle {
  405|       |    /// Invariant: vcpu is running => most significant bit (63) of `running` is set. (Neither converse nor inverse is true)
  406|       |    ///
  407|       |    /// Additionally, bit 0-62 tracks how many times the VCPU has been run. Incremented each time `run()` is called.
  408|       |    ///
  409|       |    /// This prevents an ABA problem where:
  410|       |    /// 1. The VCPU is running (generation N),
  411|       |    /// 2. It gets cancelled,
  412|       |    /// 3. Then quickly restarted (generation N+1),
  413|       |    ///    before the original thread has observed that it was cancelled.
  414|       |    ///
  415|       |    /// Without this generation counter, the interrupt logic might assume the VCPU is still
  416|       |    /// in the *original* run (generation N), see that it's `running`, and re-send the signal.
  417|       |    /// But the new VCPU run (generation N+1) would treat this as a stale signal and ignore it,
  418|       |    /// potentially causing an infinite loop where no effective interrupt is delivered.
  419|       |    ///
  420|       |    /// Invariant: If the VCPU is running, `run_generation[bit 0-62]` matches the current run's generation.
  421|       |    running: AtomicU64,
  422|       |    /// Invariant: vcpu is running => `tid` is the thread on which it is running.
  423|       |    /// Note: multiple vms may have the same `tid`, but at most one vm will have `running` set to true.
  424|       |    tid: AtomicU64,
  425|       |    /// True when an "interruptor" has requested the VM to be cancelled. Set immediately when
  426|       |    /// `kill()` is called, and cleared when the vcpu is no longer running.
  427|       |    /// This is used to
  428|       |    /// 1. make sure stale signals do not interrupt the
  429|       |    ///    the wrong vcpu (a vcpu may only be interrupted iff `cancel_requested` is true),
  430|       |    /// 2. ensure that if a vm is killed while a host call is running,
  431|       |    ///    the vm will not re-enter the guest after the host call returns.
  432|       |    cancel_requested: AtomicBool,
  433|       |    /// True when the debugger has requested the VM to be interrupted. Set immediately when
  434|       |    /// `kill_from_debugger()` is called, and cleared when the vcpu is no longer running.
  435|       |    /// This is used to make sure stale signals do not interrupt the the wrong vcpu
  436|       |    /// (a vcpu may only be interrupted by a debugger if `debug_interrupt` is true),
  437|       |    #[cfg(gdb)]
  438|       |    debug_interrupt: AtomicBool,
  439|       |    /// Whether the corresponding vm is dropped
  440|       |    dropped: AtomicBool,
  441|       |    /// Retry delay between signals sent to the vcpu thread
  442|       |    retry_delay: Duration,
  443|       |    /// The offset of the SIGRTMIN signal used to interrupt the vcpu thread
  444|       |    sig_rt_min_offset: u8,
  445|       |}
  446|       |
  447|       |#[cfg(any(kvm, mshv))]
  448|       |impl LinuxInterruptHandle {
  449|       |    const RUNNING_BIT: u64 = 1 << 63;
  450|       |    const MAX_GENERATION: u64 = Self::RUNNING_BIT - 1;
  451|       |
  452|       |    // set running to true and increment the generation. Generation will wrap around at `MAX_GENERATION`.
  453|      0|    fn set_running_and_increment_generation(&self) -> std::result::Result<u64, u64> {
  454|      0|        self.running
  455|      0|            .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |raw| {
  456|      0|                let generation = raw & !Self::RUNNING_BIT;
  457|      0|                if generation == Self::MAX_GENERATION {
  458|       |                    // restart generation from 0
  459|      0|                    return Some(Self::RUNNING_BIT);
  460|      0|                }
  461|      0|                Some((generation + 1) | Self::RUNNING_BIT)
  462|      0|            })
  463|      0|    }
  464|       |
  465|       |    // clear the running bit and return the generation
  466|      0|    fn clear_running_bit(&self) -> u64 {
  467|      0|        self.running
  468|      0|            .fetch_and(!Self::RUNNING_BIT, Ordering::Relaxed)
  469|      0|    }
  470|       |
  471|      0|    fn get_running_and_generation(&self) -> (bool, u64) {
  472|      0|        let raw = self.running.load(Ordering::Relaxed);
  473|      0|        let running = raw & Self::RUNNING_BIT != 0;
  474|      0|        let generation = raw & !Self::RUNNING_BIT;
  475|      0|        (running, generation)
  476|      0|    }
  477|       |
  478|      0|    fn send_signal(&self) -> bool {
  479|      0|        let signal_number = libc::SIGRTMIN() + self.sig_rt_min_offset as libc::c_int;
  480|      0|        let mut sent_signal = false;
  481|      0|        let mut target_generation: Option<u64> = None;
  482|       |
  483|       |        loop {
  484|      0|            let (running, generation) = self.get_running_and_generation();
  485|      0|
  486|      0|            if !running {
  487|      0|                break;
  488|      0|            }
  489|       |
  490|      0|            match target_generation {
  491|      0|                None => target_generation = Some(generation),
  492|       |                // prevent ABA problem
  493|      0|                Some(expected) if expected != generation => break,
  494|      0|                _ => {}
  495|       |            }
  496|       |
  497|      0|            log::info!("Sending signal to kill vcpu thread...");
  498|      0|            sent_signal = true;
  499|      0|            unsafe {
  500|      0|                libc::pthread_kill(self.tid.load(Ordering::Relaxed) as _, signal_number);
  501|      0|            }
  502|      0|            std::thread::sleep(self.retry_delay);
  503|       |        }
  504|       |
  505|      0|        sent_signal
  506|      0|    }
  507|       |}
  508|       |
  509|       |#[cfg(any(kvm, mshv))]
  510|       |impl InterruptHandle for LinuxInterruptHandle {
  511|      0|    fn kill(&self) -> bool {
  512|      0|        self.cancel_requested.store(true, Ordering::Relaxed);
  513|      0|
  514|      0|        self.send_signal()
  515|      0|    }
  516|       |    #[cfg(gdb)]
  517|       |    fn kill_from_debugger(&self) -> bool {
  518|       |        self.debug_interrupt.store(true, Ordering::Relaxed);
  519|       |        self.send_signal()
  520|       |    }
  521|      0|    fn dropped(&self) -> bool {
  522|      0|        self.dropped.load(Ordering::Relaxed)
  523|      0|    }
  524|       |}
  525|       |
  526|       |#[cfg(all(test, any(target_os = "windows", kvm)))]
  527|       |pub(crate) mod tests {
  528|       |    use std::sync::{Arc, Mutex};
  529|       |
  530|       |    use hyperlight_testing::dummy_guest_as_string;
  531|       |
  532|       |    use crate::sandbox::uninitialized::GuestBinary;
  533|       |    #[cfg(any(crashdump, gdb))]
  534|       |    use crate::sandbox::uninitialized::SandboxRuntimeConfig;
  535|       |    use crate::sandbox::uninitialized_evolve::set_up_hypervisor_partition;
  536|       |    use crate::sandbox::{SandboxConfiguration, UninitializedSandbox};
  537|       |    use crate::{Result, is_hypervisor_present, new_error};
  538|       |
  539|       |    #[test]
  540|      1|    fn test_initialise() -> Result<()> {
  541|      1|        if !is_hypervisor_present() {
  542|      1|            return Ok(());
  543|      0|        }
  544|       |
  545|       |        use crate::mem::ptr::RawPtr;
  546|       |        use crate::sandbox::host_funcs::FunctionRegistry;
  547|       |        #[cfg(gdb)]
  548|       |        use crate::sandbox::mem_access::dbg_mem_access_handler_wrapper;
  549|       |
  550|      0|        let filename = dummy_guest_as_string().map_err(|e| new_error!("{}", e))?;
  551|       |
  552|      0|        let config: SandboxConfiguration = Default::default();
  553|       |        #[cfg(any(crashdump, gdb))]
  554|       |        let rt_cfg: SandboxRuntimeConfig = Default::default();
  555|      0|        let sandbox =
  556|      0|            UninitializedSandbox::new(GuestBinary::FilePath(filename.clone()), Some(config))?;
  557|      0|        let (mem_mgr, mut gshm) = sandbox.mgr.build();
  558|      0|        let mut vm = set_up_hypervisor_partition(
  559|      0|            &mut gshm,
  560|      0|            &config,
  561|      0|            #[cfg(any(crashdump, gdb))]
  562|      0|            &rt_cfg,
  563|      0|            sandbox.load_info,
  564|      0|        )?;
  565|       |
  566|       |        // Set up required parameters for initialise
  567|      0|        let peb_addr = RawPtr::from(0x1000u64); // Dummy PEB address
  568|      0|        let seed = 12345u64; // Random seed
  569|      0|        let page_size = 4096u32; // Standard page size
  570|      0|        let host_funcs = Arc::new(Mutex::new(FunctionRegistry::default()));
  571|      0|        let guest_max_log_level = Some(log::LevelFilter::Error);
  572|      0|
  573|      0|        #[cfg(gdb)]
  574|      0|        let dbg_mem_access_fn = dbg_mem_access_handler_wrapper(mem_mgr.clone());
  575|      0|
  576|      0|        // Test the initialise method
  577|      0|        vm.initialise(
  578|      0|            peb_addr,
  579|      0|            seed,
  580|      0|            page_size,
  581|      0|            mem_mgr,
  582|      0|            host_funcs,
  583|      0|            guest_max_log_level,
  584|      0|            #[cfg(gdb)]
  585|      0|            dbg_mem_access_fn,
  586|      0|        )?;
  587|       |
  588|      0|        Ok(())
  589|      1|    }
  590|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/lib.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |#![warn(dead_code, missing_docs, unused_mut)]
   17|       |//! Hyperlight host runtime for executing guest code in lightweight virtual machines.
   18|       |//!
   19|       |//! This crate provides the host-side runtime for Hyperlight, enabling safe execution
   20|       |//! of untrusted guest code within micro virtual machines with minimal overhead.
   21|       |//! The runtime manages sandbox creation, guest function calls, memory isolation,
   22|       |//! and host-guest communication.
   23|       |//!
   24|       |//! The primary entry points are [`UninitializedSandbox`] for initial setup and
   25|       |//! [`MultiUseSandbox`] for executing guest functions.
   26|       |//!
   27|       |//! ## Guest Requirements
   28|       |//!
   29|       |//! Hyperlight requires specially compiled guest binaries and cannot run regular
   30|       |//! container images or executables. Guests must be built using either the Rust
   31|       |//! API ([`hyperlight_guest`] with optional use of [`hyperlight_guest_bin`]),
   32|       |//! or with the C API (`hyperlight_guest_capi`).
   33|       |//!
   34|       |//! [`hyperlight_guest`]: https://docs.rs/hyperlight_guest
   35|       |//! [`hyperlight_guest_bin`]: https://docs.rs/hyperlight_guest_bin
   36|       |//!
   37|       |
   38|       |#![cfg_attr(not(any(test, debug_assertions)), warn(clippy::panic))]
   39|       |#![cfg_attr(not(any(test, debug_assertions)), warn(clippy::expect_used))]
   40|       |#![cfg_attr(not(any(test, debug_assertions)), warn(clippy::unwrap_used))]
   41|       |#![cfg_attr(any(test, debug_assertions), allow(clippy::disallowed_macros))]
   42|       |
   43|       |#[cfg(feature = "build-metadata")]
   44|       |use std::sync::Once;
   45|       |
   46|       |#[cfg(feature = "build-metadata")]
   47|       |/// The `built` crate is used to generate a `built.rs` file that contains
   48|       |/// information about the build environment. This information is used to
   49|       |/// populate the `built_info` module, which is re-exported here.
   50|       |pub(crate) mod built_info {
   51|       |    include!(concat!(env!("OUT_DIR"), "/built.rs"));
   52|       |}
   53|       |/// Dealing with errors, including errors across VM boundaries
   54|       |pub mod error;
   55|       |/// Wrappers for host and guest functions.
   56|       |pub mod func;
   57|       |/// Wrappers for hypervisor implementations
   58|       |pub mod hypervisor;
   59|       |/// Functionality to establish and manage an individual sandbox's
   60|       |/// memory.
   61|       |///
   62|       |/// - Virtual Address
   63|       |///
   64|       |/// 0x0000    PML4
   65|       |/// 0x1000    PDPT
   66|       |/// 0x2000    PD
   67|       |/// 0x3000    The guest PE code (When the code has been loaded using LoadLibrary to debug the guest this will not be
   68|       |/// present and code length will be zero;
   69|       |///
   70|       |/// - The pointer passed to the Entrypoint in the Guest application is the size of page table + size of code,
   71|       |///   at this address structs below are laid out in this order
   72|       |pub mod mem;
   73|       |/// Metric definitions and helpers
   74|       |pub mod metrics;
   75|       |/// The main sandbox implementations. Do not use this module directly in code
   76|       |/// outside this file. Types from this module needed for public consumption are
   77|       |/// re-exported below.
   78|       |pub mod sandbox;
   79|       |#[cfg(all(feature = "seccomp", target_os = "linux"))]
   80|       |pub(crate) mod seccomp;
   81|       |/// Signal handling for Linux
   82|       |#[cfg(target_os = "linux")]
   83|       |pub(crate) mod signal_handlers;
   84|       |/// Utilities for testing including interacting with `simpleguest.exe`
   85|       |/// and `callbackguest.exe`, our two most basic guest binaries for testing
   86|       |#[cfg(test)]
   87|       |pub(crate) mod testing;
   88|       |
   89|       |/// The re-export for the `HyperlightError` type
   90|       |pub use error::HyperlightError;
   91|       |/// Re-export for `HypervisorWrapper` trait
   92|       |/// Re-export for `MemMgrWrapper` type
   93|       |/// A sandbox that can call be used to make multiple calls to guest functions,
   94|       |/// and otherwise reused multiple times
   95|       |pub use sandbox::MultiUseSandbox;
   96|       |/// The re-export for the `UninitializedSandbox` type
   97|       |pub use sandbox::UninitializedSandbox;
   98|       |/// The re-export for the `is_hypervisor_present` type
   99|       |pub use sandbox::is_hypervisor_present;
  100|       |/// The re-export for the `GuestBinary` type
  101|       |pub use sandbox::uninitialized::GuestBinary;
  102|       |
  103|       |/// The universal `Result` type used throughout the Hyperlight codebase.
  104|       |pub type Result<T> = core::result::Result<T, error::HyperlightError>;
  105|       |
  106|       |/// Logs an error then returns with it, more or less equivalent to the bail! macro in anyhow
  107|       |/// but for HyperlightError instead of anyhow::Error
  108|       |#[macro_export]
  109|       |macro_rules! log_then_return {
  110|       |    ($msg:literal $(,)?) => {{
  111|       |        let __args = std::format_args!($msg);
  112|       |        let __err_msg = match __args.as_str() {
  113|       |            Some(msg) => String::from(msg),
  114|       |            None => std::format!($msg),
  115|       |        };
  116|       |        let __err = $crate::HyperlightError::Error(__err_msg);
  117|       |        log::error!("{}", __err);
  118|       |        return Err(__err);
  119|       |    }};
  120|       |    ($err:expr $(,)?) => {
  121|       |        log::error!("{}", $err);
  122|       |        return Err($err);
  123|       |    };
  124|       |    ($err:stmt $(,)?) => {
  125|       |        log::error!("{}", $err);
  126|       |        return Err($err);
  127|       |    };
  128|       |    ($fmtstr:expr, $($arg:tt)*) => {
  129|       |           let __err_msg = std::format!($fmtstr, $($arg)*);
  130|       |           let __err = $crate::error::HyperlightError::Error(__err_msg);
  131|       |           log::error!("{}", __err);
  132|       |           return Err(__err);
  133|       |    };
  134|       |}
  135|       |
  136|       |/// Same as log::debug!, but will additionally print to stdout if the print_debug feature is enabled
  137|       |#[macro_export]
  138|       |macro_rules! debug {
  139|       |    ($($arg:tt)+) =>
  140|       |    {
  141|       |        #[cfg(print_debug)]
  142|       |        println!($($arg)+);
  143|       |        log::debug!($($arg)+);
  144|       |    }
  145|       |}
  146|       |
  147|       |// LOG_ONCE is used to log information about the crate version once
  148|       |#[cfg(feature = "build-metadata")]
  149|       |static LOG_ONCE: Once = Once::new();
  150|       |
  151|       |#[cfg(feature = "build-metadata")]
  152|     66|pub(crate) fn log_build_details() {
  153|       |    use log::info;
  154|     66|    LOG_ONCE.call_once(|| {
  155|      2|        info!("Package name: {}", built_info::PKG_NAME);
                            ^0
  156|      2|        info!("Package version: {}", built_info::PKG_VERSION);
                            ^0
  157|      2|        info!("Package features: {:?}", built_info::FEATURES);
                            ^0
  158|      2|        info!("Target triple: {}", built_info::TARGET);
                            ^0
  159|      2|        info!("Optimization level: {}", built_info::OPT_LEVEL);
                            ^0
  160|      2|        info!("Profile: {}", built_info::PROFILE);
                            ^0
  161|      2|        info!("Debug: {}", built_info::DEBUG);
                            ^0
  162|      2|        info!("Rustc: {}", built_info::RUSTC);
                            ^0
  163|      2|        info!("Built at: {}", built_info::BUILT_TIME_UTC);
                            ^0
  164|      2|        match built_info::CI_PLATFORM.unwrap_or("") {
  165|      2|            "" => info!("Not built on  a CI platform"),
                                ^0    ^0
  166|      2|            other => info!("Built on : {}", other),
                                         ^0
  167|       |        }
  168|      2|        match built_info::GIT_COMMIT_HASH.unwrap_or("") {
  169|      2|            "" => info!("No git commit hash found"),
                                ^0    ^0
  170|      2|            other => info!("Git commit hash: {}", other),
                                         ^0
  171|       |        }
  172|       |
  173|      2|        let git = match built_info::GIT_HEAD_REF.unwrap_or("") {
  174|      2|            "" => {
  175|      0|                info!("No git head ref found");
  176|      0|                false
  177|       |            }
  178|      2|            other => {
  179|      2|                info!("Git head ref: {}", other);
                                    ^0
  180|      2|                true
  181|       |            }
  182|       |        };
  183|      2|        match built_info::GIT_VERSION.unwrap_or("") {
  184|      2|            "" => info!("No git version found"),
                                ^0    ^0
  185|      2|            other => info!("Git version: {}", other),
                                         ^0
  186|       |        }
  187|      2|        match built_info::GIT_DIRTY.unwrap_or(false) {
  188|      0|            true => info!("Repo had uncommitted changes"),
  189|       |            false => {
  190|      2|                if git {
  191|      2|                    info!("Repo had no uncommitted changes")
                                        ^0
  192|       |                } else {
  193|      0|                    info!("No git repo found")
  194|       |                }
  195|       |            }
  196|       |        }
  197|     66|    });
                  ^2
  198|     66|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/elf.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(feature = "unwind_guest")]
   18|       |use std::sync::Arc;
   19|       |
   20|       |#[cfg(target_arch = "aarch64")]
   21|       |use goblin::elf::reloc::{R_AARCH64_NONE, R_AARCH64_RELATIVE};
   22|       |#[cfg(target_arch = "x86_64")]
   23|       |use goblin::elf::reloc::{R_X86_64_NONE, R_X86_64_RELATIVE};
   24|       |use goblin::elf::{Elf, ProgramHeaders, Reloc};
   25|       |#[cfg(not(feature = "init-paging"))]
   26|       |use goblin::elf32::program_header::PT_LOAD;
   27|       |#[cfg(feature = "init-paging")]
   28|       |use goblin::elf64::program_header::PT_LOAD;
   29|       |
   30|       |use crate::{Result, log_then_return, new_error};
   31|       |
   32|       |#[cfg(feature = "unwind_guest")]
   33|       |struct ResolvedSectionHeader {
   34|       |    name: String,
   35|       |    addr: u64,
   36|       |    offset: u64,
   37|       |    size: u64,
   38|       |}
   39|       |
   40|       |pub(crate) struct ElfInfo {
   41|       |    payload: Vec<u8>,
   42|       |    phdrs: ProgramHeaders,
   43|       |    #[cfg(feature = "unwind_guest")]
   44|       |    shdrs: Vec<ResolvedSectionHeader>,
   45|       |    entry: u64,
   46|       |    relocs: Vec<Reloc>,
   47|       |}
   48|       |
   49|       |#[cfg(feature = "unwind_guest")]
   50|       |struct UnwindInfo {
   51|       |    payload: Vec<u8>,
   52|       |    load_addr: u64,
   53|       |    va_size: u64,
   54|       |    base_svma: u64,
   55|       |    shdrs: Vec<ResolvedSectionHeader>,
   56|       |}
   57|       |
   58|       |#[cfg(feature = "unwind_guest")]
   59|       |impl super::exe::UnwindInfo for UnwindInfo {
   60|       |    fn as_module(&self) -> framehop::Module<Vec<u8>> {
   61|       |        framehop::Module::new(
   62|       |            // TODO: plumb through a name from from_file if this
   63|       |            // came from a file
   64|       |            "guest".to_string(),
   65|       |            self.load_addr..self.load_addr + self.va_size,
   66|       |            self.load_addr,
   67|       |            self,
   68|       |        )
   69|       |    }
   70|       |    fn hash(&self) -> blake3::Hash {
   71|       |        blake3::hash(&self.payload)
   72|       |    }
   73|       |}
   74|       |
   75|       |#[cfg(feature = "unwind_guest")]
   76|       |impl UnwindInfo {
   77|       |    fn resolved_section_header(&self, name: &[u8]) -> Option<&ResolvedSectionHeader> {
   78|       |        self.shdrs
   79|       |            .iter()
   80|       |            .find(|&sh| sh.name.as_bytes()[0..core::cmp::min(name.len(), sh.name.len())] == *name)
   81|       |    }
   82|       |}
   83|       |
   84|       |#[cfg(feature = "unwind_guest")]
   85|       |impl framehop::ModuleSectionInfo<Vec<u8>> for &UnwindInfo {
   86|       |    fn base_svma(&self) -> u64 {
   87|       |        self.base_svma
   88|       |    }
   89|       |    fn section_svma_range(&mut self, name: &[u8]) -> Option<std::ops::Range<u64>> {
   90|       |        let shdr = self.resolved_section_header(name)?;
   91|       |        Some(shdr.addr..shdr.addr + shdr.size)
   92|       |    }
   93|       |    fn section_data(&mut self, name: &[u8]) -> Option<Vec<u8>> {
   94|       |        if name == b".eh_frame" && self.resolved_section_header(b".debug_frame").is_some() {
   95|       |            /* Rustc does not always emit enough information for stack
   96|       |             * unwinding in .eh_frame, presumably because we use panic =
   97|       |             * abort in the guest. Framehop defaults to ignoring
   98|       |             * .debug_frame if .eh_frame exists, but we want the opposite
   99|       |             * behaviour here, since .debug_frame will actually contain
  100|       |             * frame information whereas .eh_frame often doesn't because
  101|       |             * of the aforementioned behaviour.  Consequently, we hack
  102|       |             * around this by pretending that .eh_frame doesn't exist if
  103|       |             * .debug_frame does. */
  104|       |            return None;
  105|       |        }
  106|       |        let shdr = self.resolved_section_header(name)?;
  107|       |        Some(self.payload[shdr.offset as usize..(shdr.offset + shdr.size) as usize].to_vec())
  108|       |    }
  109|       |}
  110|       |
  111|       |impl ElfInfo {
  112|     66|    pub(crate) fn new(bytes: &[u8]) -> Result<Self> {
  113|     66|        let elf = Elf::parse(bytes)?;
                                                 ^0
  114|     66|        let relocs = elf.dynrels.iter().chain(elf.dynrelas.iter()).collect();
  115|     66|        if !elf
  116|     66|            .program_headers
  117|     66|            .iter()
  118|    132|            .any(|phdr| phdr.p_type == PT_LOAD)
                                                            ^66
  119|       |        {
  120|      0|            log_then_return!("ELF must have at least one PT_LOAD header");
  121|     66|        }
  122|     66|        Ok(ElfInfo {
  123|     66|            payload: bytes.to_vec(),
  124|     66|            phdrs: elf.program_headers,
  125|     66|            #[cfg(feature = "unwind_guest")]
  126|     66|            shdrs: elf
  127|     66|                .section_headers
  128|     66|                .iter()
  129|     66|                .filter_map(|sh| {
  130|     66|                    Some(ResolvedSectionHeader {
  131|     66|                        name: elf.shdr_strtab.get_at(sh.sh_name)?.to_string(),
  132|     66|                        addr: sh.sh_addr,
  133|     66|                        offset: sh.sh_offset,
  134|     66|                        size: sh.sh_size,
  135|     66|                    })
  136|     66|                })
  137|     66|                .collect(),
  138|     66|            entry: elf.entry,
  139|     66|            relocs,
  140|     66|        })
  141|     66|    }
  142|     65|    pub(crate) fn entrypoint_va(&self) -> u64 {
  143|     65|        self.entry
  144|     65|    }
  145|    130|    pub(crate) fn get_base_va(&self) -> u64 {
  146|    130|        #[allow(clippy::unwrap_used)] // guaranteed not to panic because of the check in new()
  147|    130|        let min_phdr = self
  148|    130|            .phdrs
  149|    130|            .iter()
  150|    260|            .find(|phdr| phdr.p_type == PT_LOAD)
  151|    130|            .unwrap();
  152|    130|        min_phdr.p_vaddr
  153|    130|    }
  154|     65|    pub(crate) fn get_va_size(&self) -> usize {
  155|     65|        #[allow(clippy::unwrap_used)] // guaranteed not to panic because of the check in new()
  156|     65|        let max_phdr = self
  157|     65|            .phdrs
  158|     65|            .iter()
  159|     65|            .rev()
  160|    322|            .find(|phdr| phdr.p_type == PT_LOAD)
  161|     65|            .unwrap();
  162|     65|        (max_phdr.p_vaddr + max_phdr.p_memsz - self.get_base_va()) as usize
  163|     65|    }
  164|     65|    pub(crate) fn load_at(
  165|     65|        self,
  166|     65|        load_addr: usize,
  167|     65|        target: &mut [u8],
  168|     65|    ) -> Result<super::exe::LoadInfo> {
  169|     65|        let base_va = self.get_base_va();
  170|    582|        for phdr in self.phdrs.iter().filter(|phdr| phdr.p_type == PT_LOAD) {
                          ^260    ^65                                                   ^65
  171|    260|            let start_va = (phdr.p_vaddr - base_va) as usize;
  172|    260|            let payload_offset = phdr.p_offset as usize;
  173|    260|            let payload_len = phdr.p_filesz as usize;
  174|    260|            target[start_va..start_va + payload_len]
  175|    260|                .copy_from_slice(&self.payload[payload_offset..payload_offset + payload_len]);
  176|    260|            target[start_va + payload_len..start_va + phdr.p_memsz as usize].fill(0);
  177|    260|        }
  178|   177k|        let get_addend = |name, r: &Reloc| {
                          ^65
  179|   177k|            r.r_addend
  180|   177k|                .ok_or_else(|| new_error!("{} missing addend", name))
                                             ^0
  181|   177k|        };
  182|   177k|        for r in self.relocs.iter() {
                               ^65
  183|       |            #[cfg(target_arch = "aarch64")]
  184|       |            match r.r_type {
  185|       |                R_AARCH64_RELATIVE => {
  186|       |                    let addend = get_addend("R_AARCH64_RELATIVE", r)?;
  187|       |                    target[r.r_offset as usize..r.r_offset as usize + 8]
  188|       |                        .copy_from_slice(&(load_addr as i64 + addend).to_le_bytes());
  189|       |                }
  190|       |                R_AARCH64_NONE => {}
  191|       |                _ => {
  192|       |                    log_then_return!("unsupported aarch64 relocation {}", r.r_type);
  193|       |                }
  194|       |            }
  195|       |            #[cfg(target_arch = "x86_64")]
  196|   177k|            match r.r_type {
  197|       |                R_X86_64_RELATIVE => {
  198|   177k|                    let addend = get_addend("R_X86_64_RELATIVE", r)?;
                                                                                 ^0
  199|   177k|                    target[r.r_offset as usize..r.r_offset as usize + 8]
  200|   177k|                        .copy_from_slice(&(load_addr as i64 + addend).to_le_bytes());
  201|       |                }
  202|      0|                R_X86_64_NONE => {}
  203|       |                _ => {
  204|      0|                    log_then_return!("unsupported x86_64 relocation {}", r.r_type);
  205|       |                }
  206|       |            }
  207|       |        }
  208|       |        cfg_if::cfg_if! {
  209|       |            if #[cfg(feature = "unwind_guest")] {
  210|       |                let va_size = self.get_va_size() as u64;
  211|       |                let base_svma = self.get_base_va();
  212|       |                Ok(Arc::new(UnwindInfo {
  213|       |                    payload: self.payload,
  214|       |                    load_addr: load_addr as u64,
  215|       |                    va_size,
  216|       |                    base_svma,
  217|       |                    shdrs: self.shdrs,
  218|       |                }))
  219|       |            } else {
  220|     65|                Ok(())
  221|       |            }
  222|       |        }
  223|     65|    }
  224|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/exe.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::fs::File;
   18|       |use std::io::Read;
   19|       |#[cfg(feature = "unwind_guest")]
   20|       |use std::sync::Arc;
   21|       |use std::vec::Vec;
   22|       |
   23|       |use super::elf::ElfInfo;
   24|       |use super::ptr_offset::Offset;
   25|       |use crate::Result;
   26|       |
   27|       |// This is used extremely infrequently, so being unusually large for PE
   28|       |// files _really_ doesn't matter, and probably isn't really worth the
   29|       |// cost of an indirection.
   30|       |#[allow(clippy::large_enum_variant)]
   31|       |pub enum ExeInfo {
   32|       |    Elf(ElfInfo),
   33|       |}
   34|       |
   35|       |// There isn't a commonly-used standard convention for heap and stack
   36|       |// limits to be included in ELF files as they are in
   37|       |// PEs. Consequently, we use these static defaults as the default
   38|       |// limits, unless overwritten when setting up the sandbox.
   39|       |const DEFAULT_ELF_STACK_RESERVE: u64 = 65536;
   40|       |const DEFAULT_ELF_HEAP_RESERVE: u64 = 131072;
   41|       |
   42|       |#[cfg(feature = "unwind_guest")]
   43|       |pub(crate) trait UnwindInfo: Send + Sync {
   44|       |    fn as_module(&self) -> framehop::Module<Vec<u8>>;
   45|       |    fn hash(&self) -> blake3::Hash;
   46|       |}
   47|       |
   48|       |#[cfg(feature = "unwind_guest")]
   49|       |pub(crate) struct DummyUnwindInfo {}
   50|       |#[cfg(feature = "unwind_guest")]
   51|       |impl UnwindInfo for DummyUnwindInfo {
   52|       |    fn as_module(&self) -> framehop::Module<Vec<u8>> {
   53|       |        framehop::Module::new("unsupported".to_string(), 0..0, 0, self)
   54|       |    }
   55|       |    fn hash(&self) -> blake3::Hash {
   56|       |        blake3::Hash::from_bytes([0; 32])
   57|       |    }
   58|       |}
   59|       |#[cfg(feature = "unwind_guest")]
   60|       |impl<A> framehop::ModuleSectionInfo<A> for &DummyUnwindInfo {
   61|       |    fn base_svma(&self) -> u64 {
   62|       |        0
   63|       |    }
   64|       |    fn section_svma_range(&mut self, _name: &[u8]) -> Option<std::ops::Range<u64>> {
   65|       |        None
   66|       |    }
   67|       |    fn section_data(&mut self, _name: &[u8]) -> Option<A> {
   68|       |        None
   69|       |    }
   70|       |}
   71|       |
   72|       |#[cfg(feature = "unwind_guest")]
   73|       |pub(crate) type LoadInfo = Arc<dyn UnwindInfo>;
   74|       |#[cfg(not(feature = "unwind_guest"))]
   75|       |pub(crate) type LoadInfo = ();
   76|       |
   77|       |impl ExeInfo {
   78|     65|    pub fn from_file(path: &str) -> Result<Self> {
   79|     65|        let mut file = File::open(path)?;
                                                     ^0
   80|     65|        let mut contents = Vec::new();
   81|     65|        file.read_to_end(&mut contents)?;
                                                     ^0
   82|     65|        Self::from_buf(&contents)
   83|     65|    }
   84|     66|    pub fn from_buf(buf: &[u8]) -> Result<Self> {
   85|     66|        ElfInfo::new(buf).map(ExeInfo::Elf)
   86|     66|    }
   87|     63|    pub fn stack_reserve(&self) -> u64 {
   88|     63|        match self {
   89|     63|            ExeInfo::Elf(_) => DEFAULT_ELF_STACK_RESERVE,
   90|     63|        }
   91|     63|    }
   92|     63|    pub fn heap_reserve(&self) -> u64 {
   93|     63|        match self {
   94|     63|            ExeInfo::Elf(_) => DEFAULT_ELF_HEAP_RESERVE,
   95|     63|        }
   96|     63|    }
   97|     65|    pub fn entrypoint(&self) -> Offset {
   98|     65|        match self {
   99|     65|            ExeInfo::Elf(elf) => Offset::from(elf.entrypoint_va()),
  100|     65|        }
  101|     65|    }
  102|     65|    pub fn loaded_size(&self) -> usize {
  103|     65|        match self {
  104|     65|            ExeInfo::Elf(elf) => elf.get_va_size(),
  105|     65|        }
  106|     65|    }
  107|       |    // todo: this doesn't morally need to be &mut self, since we're
  108|       |    // copying into target, but the PE loader chooses to apply
  109|       |    // relocations in its owned representation of the PE contents,
  110|       |    // which requires it to be &mut.
  111|     65|    pub fn load(self, load_addr: usize, target: &mut [u8]) -> Result<LoadInfo> {
  112|     65|        match self {
  113|     65|            ExeInfo::Elf(elf) => elf.load_at(load_addr, target),
  114|     65|        }
  115|     65|    }
  116|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/layout.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |use std::fmt::Debug;
   17|       |use std::mem::{offset_of, size_of};
   18|       |
   19|       |use hyperlight_common::mem::{GuestMemoryRegion, HyperlightPEB, PAGE_SIZE_USIZE};
   20|       |use rand::{RngCore, rng};
   21|       |use tracing::{Span, instrument};
   22|       |
   23|       |#[cfg(feature = "init-paging")]
   24|       |use super::memory_region::MemoryRegionType::PageTables;
   25|       |use super::memory_region::MemoryRegionType::{
   26|       |    Code, GuardPage, Heap, HostFunctionDefinitions, InitData, InputData, OutputData, Peb, Stack,
   27|       |};
   28|       |use super::memory_region::{
   29|       |    DEFAULT_GUEST_BLOB_MEM_FLAGS, MemoryRegion, MemoryRegionFlags, MemoryRegionVecBuilder,
   30|       |};
   31|       |#[cfg(feature = "init-paging")]
   32|       |use super::mgr::AMOUNT_OF_MEMORY_PER_PT;
   33|       |use super::shared_mem::{ExclusiveSharedMemory, GuestSharedMemory, SharedMemory};
   34|       |use crate::error::HyperlightError::{GuestOffsetIsInvalid, MemoryRequestTooBig};
   35|       |use crate::sandbox::SandboxConfiguration;
   36|       |use crate::{Result, new_error};
   37|       |
   38|       |// +-------------------------------------------+
   39|       |// |              Init Data                    | (GuestBlob size)
   40|       |// +-------------------------------------------+
   41|       |// |             Guest (User) Stack            |
   42|       |// +-------------------------------------------+
   43|       |// |             Guard Page (4KiB)             |
   44|       |// +-------------------------------------------+
   45|       |// |             Guest Heap                    |
   46|       |// +-------------------------------------------+
   47|       |// |             Output Data                   |
   48|       |// +-------------------------------------------+
   49|       |// |              Input Data                   |
   50|       |// +-------------------------------------------+
   51|       |// |        Host Function Definitions          |
   52|       |// +-------------------------------------------+
   53|       |// |                PEB Struct                 | (HyperlightPEB size)
   54|       |// +-------------------------------------------+
   55|       |// |               Guest Code                  |
   56|       |// +-------------------------------------------+
   57|       |// |                    PT                     |
   58|       |// +-------------------------------------------+ 0x3_000
   59|       |// |                    PD                     |
   60|       |// +-------------------------------------------+ 0x2_000
   61|       |// |                   PDPT                    |
   62|       |// +-------------------------------------------+ 0x1_000
   63|       |// |                   PML4                    |
   64|       |// +-------------------------------------------+ 0x0_000
   65|       |
   66|       |/// - `InitData` - some extra data that can be loaded onto the sandbox during
   67|       |///   initialization.
   68|       |///
   69|       |/// - `HostDefinitions` - the length of this is the `HostFunctionDefinitionSize`
   70|       |///   field from `SandboxConfiguration`
   71|       |///
   72|       |/// - `InputData` -  this is a buffer that is used for input data to the host program.
   73|       |///   the length of this field is `InputDataSize` from `SandboxConfiguration`
   74|       |///
   75|       |/// - `OutputData` - this is a buffer that is used for output data from host program.
   76|       |///   the length of this field is `OutputDataSize` from `SandboxConfiguration`
   77|       |///
   78|       |/// - `GuestHeap` - this is a buffer that is used for heap data in the guest. the length
   79|       |///   of this field is returned by the `heap_size()` method of this struct
   80|       |///
   81|       |/// - `GuestStack` - this is a buffer that is used for stack data in the guest. the length
   82|       |///   of this field is returned by the `stack_size()` method of this struct. in reality,
   83|       |///   the stack might be slightly bigger or smaller than this value since total memory
   84|       |///   size is rounded up to the nearest 4K, and there is a 16-byte stack guard written
   85|       |///   to the top of the stack. (see below for more details)
   86|       |
   87|       |#[derive(Copy, Clone)]
   88|       |pub(crate) struct SandboxMemoryLayout {
   89|       |    pub(super) sandbox_memory_config: SandboxConfiguration,
   90|       |    /// The total stack size of this sandbox.
   91|       |    pub(super) stack_size: usize,
   92|       |    /// The heap size of this sandbox.
   93|       |    pub(super) heap_size: usize,
   94|       |    init_data_size: usize,
   95|       |
   96|       |    /// The following fields are offsets to the actual PEB struct fields.
   97|       |    /// They are used when writing the PEB struct itself
   98|       |    peb_offset: usize,
   99|       |    peb_security_cookie_seed_offset: usize,
  100|       |    peb_guest_dispatch_function_ptr_offset: usize, // set by guest in guest entrypoint
  101|       |    peb_code_pointer_offset: usize,
  102|       |    pub(super) peb_host_function_definitions_offset: usize,
  103|       |    peb_input_data_offset: usize,
  104|       |    peb_output_data_offset: usize,
  105|       |    peb_init_data_offset: usize,
  106|       |    peb_heap_data_offset: usize,
  107|       |    peb_guest_stack_data_offset: usize,
  108|       |
  109|       |    // The following are the actual values
  110|       |    // that are written to the PEB struct
  111|       |    pub(crate) host_function_definitions_buffer_offset: usize,
  112|       |    pub(super) input_data_buffer_offset: usize,
  113|       |    pub(super) output_data_buffer_offset: usize,
  114|       |    guest_heap_buffer_offset: usize,
  115|       |    guard_page_offset: usize,
  116|       |    guest_user_stack_buffer_offset: usize, // the lowest address of the user stack
  117|       |    init_data_offset: usize,
  118|       |
  119|       |    // other
  120|       |    pub(crate) peb_address: usize,
  121|       |    code_size: usize,
  122|       |    // The total size of the page tables
  123|       |    total_page_table_size: usize,
  124|       |    // The offset in the sandbox memory where the code starts
  125|       |    guest_code_offset: usize,
  126|       |    pub(crate) init_data_permissions: Option<MemoryRegionFlags>,
  127|       |}
  128|       |
  129|       |impl Debug for SandboxMemoryLayout {
  130|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  131|      0|        f.debug_struct("SandboxMemoryLayout")
  132|      0|            .field(
  133|      0|                "Total Memory Size",
  134|      0|                &format_args!("{:#x}", self.get_memory_size().unwrap_or(0)),
  135|      0|            )
  136|      0|            .field("Stack Size", &format_args!("{:#x}", self.stack_size))
  137|      0|            .field("Heap Size", &format_args!("{:#x}", self.heap_size))
  138|      0|            .field(
  139|      0|                "Init Data Size",
  140|      0|                &format_args!("{:#x}", self.init_data_size),
  141|      0|            )
  142|      0|            .field("PEB Address", &format_args!("{:#x}", self.peb_address))
  143|      0|            .field("PEB Offset", &format_args!("{:#x}", self.peb_offset))
  144|      0|            .field("Code Size", &format_args!("{:#x}", self.code_size))
  145|      0|            .field(
  146|      0|                "Security Cookie Seed Offset",
  147|      0|                &format_args!("{:#x}", self.peb_security_cookie_seed_offset),
  148|      0|            )
  149|      0|            .field(
  150|      0|                "Guest Dispatch Function Pointer Offset",
  151|      0|                &format_args!("{:#x}", self.peb_guest_dispatch_function_ptr_offset),
  152|      0|            )
  153|      0|            .field(
  154|      0|                "Host Function Definitions Offset",
  155|      0|                &format_args!("{:#x}", self.peb_host_function_definitions_offset),
  156|      0|            )
  157|      0|            .field(
  158|      0|                "Code Pointer Offset",
  159|      0|                &format_args!("{:#x}", self.peb_code_pointer_offset),
  160|      0|            )
  161|      0|            .field(
  162|      0|                "Input Data Offset",
  163|      0|                &format_args!("{:#x}", self.peb_input_data_offset),
  164|      0|            )
  165|      0|            .field(
  166|      0|                "Output Data Offset",
  167|      0|                &format_args!("{:#x}", self.peb_output_data_offset),
  168|      0|            )
  169|      0|            .field(
  170|      0|                "Init Data Offset",
  171|      0|                &format_args!("{:#x}", self.peb_init_data_offset),
  172|      0|            )
  173|      0|            .field(
  174|      0|                "Guest Heap Offset",
  175|      0|                &format_args!("{:#x}", self.peb_heap_data_offset),
  176|      0|            )
  177|      0|            .field(
  178|      0|                "Guest Stack Offset",
  179|      0|                &format_args!("{:#x}", self.peb_guest_stack_data_offset),
  180|      0|            )
  181|      0|            .field(
  182|      0|                "Host Function Definitions Buffer Offset",
  183|      0|                &format_args!("{:#x}", self.host_function_definitions_buffer_offset),
  184|      0|            )
  185|      0|            .field(
  186|      0|                "Input Data Buffer Offset",
  187|      0|                &format_args!("{:#x}", self.input_data_buffer_offset),
  188|      0|            )
  189|      0|            .field(
  190|      0|                "Output Data Buffer Offset",
  191|      0|                &format_args!("{:#x}", self.output_data_buffer_offset),
  192|      0|            )
  193|      0|            .field(
  194|      0|                "Guest Heap Buffer Offset",
  195|      0|                &format_args!("{:#x}", self.guest_heap_buffer_offset),
  196|      0|            )
  197|      0|            .field(
  198|      0|                "Guard Page Offset",
  199|      0|                &format_args!("{:#x}", self.guard_page_offset),
  200|      0|            )
  201|      0|            .field(
  202|      0|                "Guest User Stack Buffer Offset",
  203|      0|                &format_args!("{:#x}", self.guest_user_stack_buffer_offset),
  204|      0|            )
  205|      0|            .field(
  206|      0|                "Init Data Offset",
  207|      0|                &format_args!("{:#x}", self.init_data_offset),
  208|      0|            )
  209|      0|            .field(
  210|      0|                "Page Table Size",
  211|      0|                &format_args!("{:#x}", self.total_page_table_size),
  212|      0|            )
  213|      0|            .field(
  214|      0|                "Guest Code Offset",
  215|      0|                &format_args!("{:#x}", self.guest_code_offset),
  216|      0|            )
  217|      0|            .finish()
  218|      0|    }
  219|       |}
  220|       |
  221|       |impl SandboxMemoryLayout {
  222|       |    /// The offset into the sandbox's memory where the PML4 Table is located.
  223|       |    /// See https://www.pagetable.com/?p=14 for more information.
  224|       |    pub(crate) const PML4_OFFSET: usize = 0x0000;
  225|       |    /// The offset into the sandbox's memory where the Page Directory Pointer
  226|       |    /// Table starts.
  227|       |    #[cfg(feature = "init-paging")]
  228|       |    pub(super) const PDPT_OFFSET: usize = 0x1000;
  229|       |    /// The offset into the sandbox's memory where the Page Directory starts.
  230|       |    #[cfg(feature = "init-paging")]
  231|       |    pub(super) const PD_OFFSET: usize = 0x2000;
  232|       |    /// The offset into the sandbox's memory where the Page Tables start.
  233|       |    #[cfg(feature = "init-paging")]
  234|       |    pub(super) const PT_OFFSET: usize = 0x3000;
  235|       |    /// The address (not the offset) to the start of the page directory
  236|       |    #[cfg(feature = "init-paging")]
  237|       |    pub(super) const PD_GUEST_ADDRESS: usize = Self::BASE_ADDRESS + Self::PD_OFFSET;
  238|       |    /// The address (not the offset) into sandbox memory where the Page
  239|       |    /// Directory Pointer Table starts
  240|       |    #[cfg(feature = "init-paging")]
  241|       |    pub(super) const PDPT_GUEST_ADDRESS: usize = Self::BASE_ADDRESS + Self::PDPT_OFFSET;
  242|       |    /// The address (not the offset) into sandbox memory where the Page
  243|       |    /// Tables start
  244|       |    #[cfg(feature = "init-paging")]
  245|       |    pub(super) const PT_GUEST_ADDRESS: usize = Self::BASE_ADDRESS + Self::PT_OFFSET;
  246|       |    /// The maximum amount of memory a single sandbox will be allowed.
  247|       |    /// The addressable virtual memory with current paging setup is virtual address 0x0 - 0x40000000 (excl.),
  248|       |    /// However, the memory up to Self::BASE_ADDRESS is not used.
  249|       |    const MAX_MEMORY_SIZE: usize = 0x40000000 - Self::BASE_ADDRESS;
  250|       |
  251|       |    /// The base address of the sandbox's memory.
  252|       |    pub(crate) const BASE_ADDRESS: usize = 0x0;
  253|       |
  254|       |    // the offset into a sandbox's input/output buffer where the stack starts
  255|       |    const STACK_POINTER_SIZE_BYTES: u64 = 8;
  256|       |
  257|       |    /// Create a new `SandboxMemoryLayout` with the given
  258|       |    /// `SandboxConfiguration`, code size and stack/heap size.
  259|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  260|     66|    pub(super) fn new(
  261|     66|        cfg: SandboxConfiguration,
  262|     66|        code_size: usize,
  263|     66|        stack_size: usize,
  264|     66|        heap_size: usize,
  265|     66|        init_data_size: usize,
  266|     66|        init_data_permissions: Option<MemoryRegionFlags>,
  267|     66|    ) -> Result<Self> {
  268|       |        #[cfg(feature = "init-paging")]
  269|       |        let base = Self::get_total_page_table_size(cfg, code_size, stack_size, heap_size);
  270|       |        #[cfg(not(feature = "init-paging"))]
  271|       |        let base = Self::BASE_ADDRESS;
  272|       |        let guest_code_offset = base;
  273|       |        // The following offsets are to the fields of the PEB struct itself!
  274|       |        let peb_offset = base + round_up_to(code_size, PAGE_SIZE_USIZE);
  275|       |        let peb_security_cookie_seed_offset =
  276|       |            peb_offset + offset_of!(HyperlightPEB, security_cookie_seed);
  277|       |        let peb_guest_dispatch_function_ptr_offset =
  278|       |            peb_offset + offset_of!(HyperlightPEB, guest_function_dispatch_ptr);
  279|       |        let peb_code_pointer_offset = peb_offset + offset_of!(HyperlightPEB, code_ptr);
  280|       |        let peb_input_data_offset = peb_offset + offset_of!(HyperlightPEB, input_stack);
  281|       |        let peb_output_data_offset = peb_offset + offset_of!(HyperlightPEB, output_stack);
  282|       |        let peb_init_data_offset = peb_offset + offset_of!(HyperlightPEB, init_data);
  283|       |        let peb_heap_data_offset = peb_offset + offset_of!(HyperlightPEB, guest_heap);
  284|       |        let peb_guest_stack_data_offset = peb_offset + offset_of!(HyperlightPEB, guest_stack);
  285|       |        let peb_host_function_definitions_offset =
  286|       |            peb_offset + offset_of!(HyperlightPEB, host_function_definitions);
  287|       |
  288|       |        // The following offsets are the actual values that relate to memory layout,
  289|       |        // which are written to PEB struct
  290|       |        let peb_address = Self::BASE_ADDRESS + peb_offset;
  291|       |        // make sure host function definitions buffer starts at 4K boundary
  292|       |        let host_function_definitions_buffer_offset = round_up_to(
  293|       |            peb_host_function_definitions_offset + size_of::<GuestMemoryRegion>(),
  294|       |            PAGE_SIZE_USIZE,
  295|       |        );
  296|       |        let input_data_buffer_offset = round_up_to(
  297|       |            host_function_definitions_buffer_offset + cfg.get_host_function_definition_size(),
  298|       |            PAGE_SIZE_USIZE,
  299|       |        );
  300|       |        let output_data_buffer_offset = round_up_to(
  301|       |            input_data_buffer_offset + cfg.get_input_data_size(),
  302|       |            PAGE_SIZE_USIZE,
  303|       |        );
  304|       |        // make sure heap buffer starts at 4K boundary
  305|       |        let guest_heap_buffer_offset = round_up_to(
  306|       |            output_data_buffer_offset + cfg.get_output_data_size(),
  307|       |            PAGE_SIZE_USIZE,
  308|       |        );
  309|       |        // make sure guard page starts at 4K boundary
  310|       |        let guard_page_offset = round_up_to(guest_heap_buffer_offset + heap_size, PAGE_SIZE_USIZE);
  311|       |        let guest_user_stack_buffer_offset = guard_page_offset + PAGE_SIZE_USIZE;
  312|       |        // round up stack size to page size. This is needed for MemoryRegion
  313|       |        let stack_size_rounded = round_up_to(stack_size, PAGE_SIZE_USIZE);
  314|       |        let init_data_offset = guest_user_stack_buffer_offset + stack_size_rounded;
  315|       |
  316|       |        Ok(Self {
  317|       |            peb_offset,
  318|       |            stack_size: stack_size_rounded,
  319|       |            heap_size,
  320|       |            peb_security_cookie_seed_offset,
  321|       |            peb_guest_dispatch_function_ptr_offset,
  322|       |            peb_code_pointer_offset,
  323|       |            peb_host_function_definitions_offset,
  324|       |            peb_input_data_offset,
  325|       |            peb_output_data_offset,
  326|       |            peb_init_data_offset,
  327|       |            peb_heap_data_offset,
  328|       |            peb_guest_stack_data_offset,
  329|       |            sandbox_memory_config: cfg,
  330|       |            code_size,
  331|       |            host_function_definitions_buffer_offset,
  332|       |            input_data_buffer_offset,
  333|       |            output_data_buffer_offset,
  334|       |            guest_heap_buffer_offset,
  335|       |            guest_user_stack_buffer_offset,
  336|       |            peb_address,
  337|       |            guard_page_offset,
  338|       |            total_page_table_size: base,
  339|       |            guest_code_offset,
  340|       |            init_data_offset,
  341|       |            init_data_size,
  342|       |            init_data_permissions,
  343|       |        })
  344|     66|    }
  345|       |
  346|       |    /// Get the offset in guest memory to the output data size
  347|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  348|    128|    pub(super) fn get_output_data_size_offset(&self) -> usize {
  349|       |        // The size field is the first field in the `OutputData` struct
  350|    128|        self.peb_output_data_offset
  351|    128|    }
  352|       |
  353|       |    /// Get the offset in guest memory to the host function definitions
  354|       |    /// size
  355|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  356|    135|    pub(super) fn get_host_function_definitions_size_offset(&self) -> usize {
  357|       |        // The size field is the first field in the `HostFunctions` struct
  358|    135|        self.peb_host_function_definitions_offset
  359|    135|    }
  360|       |
  361|       |    /// Get the offset in guest memory to the host function definitions
  362|       |    /// pointer.
  363|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  364|     64|    fn get_host_function_definitions_pointer_offset(&self) -> usize {
  365|       |        // The size field is the field after the size field in the `HostFunctions` struct which is a u64
  366|     64|        self.peb_host_function_definitions_offset + size_of::<u64>()
  367|     64|    }
  368|       |
  369|       |    /// Get the offset in guest memory to the init data size
  370|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  371|    128|    pub(super) fn get_init_data_size_offset(&self) -> usize {
  372|       |        // The init data size is the first field in the `GuestMemoryRegion` struct
  373|    128|        self.peb_init_data_offset
  374|    128|    }
  375|       |
  376|       |    /// Get the offset in guest memory to the minimum guest stack address.
  377|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  378|    128|    fn get_min_guest_stack_address_offset(&self) -> usize {
  379|       |        // The minimum guest user stack address is the start of the guest stack
  380|    128|        self.peb_guest_stack_data_offset
  381|    128|    }
  382|       |
  383|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  384|    118|    pub(super) fn get_guest_stack_size(&self) -> usize {
  385|    118|        self.stack_size
  386|    118|    }
  387|       |
  388|       |    /// Get the offset in guest memory to the OutB pointer.
  389|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  390|       |    #[allow(dead_code)]
  391|      0|    pub(super) fn get_outb_pointer_offset(&self) -> usize {
  392|       |        // The outb pointer is immediately after the code pointer
  393|       |        // in the `CodeAndOutBPointers` struct which is a u64
  394|      0|        self.peb_code_pointer_offset + size_of::<u64>()
  395|      0|    }
  396|       |
  397|       |    /// Get the offset in guest memory to the OutB context.
  398|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  399|       |    #[allow(dead_code)]
  400|      0|    pub(super) fn get_outb_context_offset(&self) -> usize {
  401|       |        // The outb context is immediately after the outb pointer
  402|       |        // in the `CodeAndOutBPointers` struct which is a u64
  403|      0|        self.get_outb_pointer_offset() + size_of::<u64>()
  404|      0|    }
  405|       |
  406|       |    /// Get the offset in guest memory to the output data pointer.
  407|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  408|     64|    fn get_output_data_pointer_offset(&self) -> usize {
  409|       |        // This field is immediately after the output data size field,
  410|       |        // which is a `u64`.
  411|     64|        self.get_output_data_size_offset() + size_of::<u64>()
  412|     64|    }
  413|       |
  414|       |    /// Get the offset in guest memory to the init data pointer.
  415|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  416|     64|    pub(super) fn get_init_data_pointer_offset(&self) -> usize {
  417|       |        // The init data pointer is immediately after the init data size field,
  418|       |        // which is a `u64`.
  419|     64|        self.get_init_data_size_offset() + size_of::<u64>()
  420|     64|    }
  421|       |
  422|       |    /// Get the offset in guest memory to the start of output data.
  423|       |    ///
  424|       |    /// This function exists to accommodate the macro that generates C API
  425|       |    /// compatible functions.
  426|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  427|       |    #[allow(dead_code)]
  428|      0|    pub(crate) fn get_output_data_offset(&self) -> usize {
  429|      0|        self.output_data_buffer_offset
  430|      0|    }
  431|       |
  432|       |    /// Get the offset in guest memory to the input data size.
  433|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  434|    128|    pub(super) fn get_input_data_size_offset(&self) -> usize {
  435|       |        // The input data size is the first field in the input stack's `GuestMemoryRegion` struct
  436|    128|        self.peb_input_data_offset
  437|    128|    }
  438|       |
  439|       |    /// Get the offset in guest memory to the input data pointer.
  440|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  441|     64|    fn get_input_data_pointer_offset(&self) -> usize {
  442|       |        // The input data pointer is immediately after the input
  443|       |        // data size field in the input data `GuestMemoryRegion` struct which is a `u64`.
  444|     64|        self.get_input_data_size_offset() + size_of::<u64>()
  445|     64|    }
  446|       |
  447|       |    /// Get the offset in guest memory to the code pointer
  448|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  449|     65|    pub(super) fn get_code_pointer_offset(&self) -> usize {
  450|       |        // The code pointer is the first field
  451|       |        // in the `CodeAndOutBPointers` struct which is a u64
  452|     65|        self.peb_code_pointer_offset
  453|     65|    }
  454|       |
  455|       |    /// Get the offset in guest memory to where the guest dispatch function
  456|       |    /// pointer is written
  457|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  458|      0|    pub(super) fn get_dispatch_function_pointer_offset(&self) -> usize {
  459|      0|        self.peb_guest_dispatch_function_ptr_offset
  460|      0|    }
  461|       |
  462|       |    /// Get the offset in guest memory to the PEB address
  463|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  464|       |    #[allow(dead_code)]
  465|      0|    pub(super) fn get_in_process_peb_offset(&self) -> usize {
  466|      0|        self.peb_offset
  467|      0|    }
  468|       |
  469|       |    /// Get the offset in guest memory to the heap size
  470|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  471|    128|    fn get_heap_size_offset(&self) -> usize {
  472|    128|        self.peb_heap_data_offset
  473|    128|    }
  474|       |
  475|       |    /// Get the offset of the heap pointer in guest memory,
  476|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  477|     64|    fn get_heap_pointer_offset(&self) -> usize {
  478|       |        // The heap pointer is immediately after the
  479|       |        // heap size field in the guest heap's `GuestMemoryRegion` struct which is a `u64`.
  480|     64|        self.get_heap_size_offset() + size_of::<u64>()
  481|     64|    }
  482|       |
  483|       |    /// Get the offset to the top of the stack in guest memory
  484|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  485|    123|    pub(super) fn get_top_of_user_stack_offset(&self) -> usize {
  486|    123|        self.guest_user_stack_buffer_offset
  487|    123|    }
  488|       |
  489|       |    /// Get the offset of the user stack pointer in guest memory,
  490|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  491|     64|    fn get_user_stack_pointer_offset(&self) -> usize {
  492|       |        // The userStackAddress is immediately after the
  493|       |        // minUserStackAddress (top of user stack) field in the `GuestStackData` struct which is a `u64`.
  494|     64|        self.get_min_guest_stack_address_offset() + size_of::<u64>()
  495|     64|    }
  496|       |
  497|       |    /// Get the offset to the guest guard page
  498|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  499|       |    #[allow(dead_code)]
  500|      0|    pub fn get_guard_page_offset(&self) -> usize {
  501|      0|        self.guard_page_offset
  502|      0|    }
  503|       |
  504|       |    /// Get the total size of guest memory in `self`'s memory
  505|       |    /// layout.
  506|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  507|    248|    fn get_unaligned_memory_size(&self) -> usize {
  508|    248|        self.init_data_offset + self.init_data_size
  509|    248|    }
  510|       |
  511|       |    /// get the code offset
  512|       |    /// This is the offset in the sandbox memory where the code starts
  513|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  514|     65|    pub(super) fn get_guest_code_offset(&self) -> usize {
  515|     65|        self.guest_code_offset
  516|     65|    }
  517|       |
  518|       |    /// Get the guest address of the code section in the sandbox
  519|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  520|     65|    pub(crate) fn get_guest_code_address(&self) -> usize {
  521|     65|        Self::BASE_ADDRESS + self.guest_code_offset
  522|     65|    }
  523|       |
  524|       |    #[cfg(test)]
  525|       |    #[cfg(feature = "init-paging")]
  526|       |    /// Get the page table size
  527|      1|    fn get_page_table_size(&self) -> usize {
  528|      1|        self.total_page_table_size
  529|      1|    }
  530|       |
  531|       |    // This function calculates the page table size for the sandbox
  532|       |    // We need enough memory to store the PML4, PDPT, PD and PTs
  533|       |    // The size of a single table is 4K, we can map up to 1GB total memory which requires 1 PML4, 1 PDPT, 1 PD and 512 PTs
  534|       |    // but we only need enough PTs to map the memory we are using. (In other words we only need 512 PTs to map the memory if the memory size is 1GB)
  535|       |    //
  536|       |    // We can calculate the amount of memory needed for the PTs by calculating how much memory is needed for the sandbox configuration in total,
  537|       |    // and then add 3 * 4K (for the PML4, PDPT and PD)  to that,
  538|       |    // then add 2MB to that (the maximum size of memory required for the PTs themselves is 2MB when we map 1GB of memory in 4K pages),
  539|       |    // then divide that by 0x200_000 (as we can map 2MB in each PT).
  540|       |    // This will give us the total size of the PTs required for the sandbox to which we can add the size of the PML4, PDPT and PD.
  541|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  542|       |    #[cfg(feature = "init-paging")]
  543|     66|    fn get_total_page_table_size(
  544|     66|        cfg: SandboxConfiguration,
  545|     66|        code_size: usize,
  546|     66|        stack_size: usize,
  547|     66|        heap_size: usize,
  548|     66|    ) -> usize {
  549|       |        // Get the configured memory size (assume each section is 4K aligned)
  550|       |
  551|     66|        let mut total_mapped_memory_size: usize = round_up_to(code_size, PAGE_SIZE_USIZE);
  552|     66|        total_mapped_memory_size += round_up_to(stack_size, PAGE_SIZE_USIZE);
  553|     66|        total_mapped_memory_size += round_up_to(heap_size, PAGE_SIZE_USIZE);
  554|     66|        total_mapped_memory_size +=
  555|     66|            round_up_to(cfg.get_host_function_definition_size(), PAGE_SIZE_USIZE);
  556|     66|        total_mapped_memory_size += round_up_to(cfg.get_input_data_size(), PAGE_SIZE_USIZE);
  557|     66|        total_mapped_memory_size += round_up_to(cfg.get_output_data_size(), PAGE_SIZE_USIZE);
  558|     66|        total_mapped_memory_size += round_up_to(size_of::<HyperlightPEB>(), PAGE_SIZE_USIZE);
  559|     66|
  560|     66|        // Add the base address of the sandbox
  561|     66|        total_mapped_memory_size += Self::BASE_ADDRESS;
  562|     66|
  563|     66|        // Add the size of  the PML4, PDPT and PD
  564|     66|        total_mapped_memory_size += 3 * PAGE_SIZE_USIZE;
  565|     66|
  566|     66|        // Add the maximum possible size of the PTs
  567|     66|        total_mapped_memory_size += 512 * PAGE_SIZE_USIZE;
  568|     66|
  569|     66|        // Get the number of pages needed for the PTs
  570|     66|
  571|     66|        let num_pages: usize = total_mapped_memory_size.div_ceil(AMOUNT_OF_MEMORY_PER_PT) + 3; // PML4, PDPT, PD
  572|     66|
  573|     66|        num_pages * PAGE_SIZE_USIZE
  574|     66|    }
  575|       |
  576|       |    /// Get the total size of guest memory in `self`'s memory
  577|       |    /// layout aligned to page size boundaries.
  578|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  579|    184|    pub(super) fn get_memory_size(&self) -> Result<usize> {
  580|    184|        let total_memory = self.get_unaligned_memory_size();
  581|    184|
  582|    184|        // Size should be a multiple of page size.
  583|    184|        let remainder = total_memory % PAGE_SIZE_USIZE;
  584|    184|        let multiples = total_memory / PAGE_SIZE_USIZE;
  585|    184|        let size = match remainder {
  586|    181|            0 => total_memory,
  587|      3|            _ => (multiples + 1) * PAGE_SIZE_USIZE,
  588|       |        };
  589|       |
  590|    184|        if size > Self::MAX_MEMORY_SIZE {
  591|      0|            Err(MemoryRequestTooBig(size, Self::MAX_MEMORY_SIZE))
  592|       |        } else {
  593|    184|            Ok(size)
  594|       |        }
  595|    184|    }
  596|       |
  597|       |    /// Returns the memory regions associated with this memory layout,
  598|       |    /// suitable for passing to a hypervisor for mapping into memory
  599|    118|    pub fn get_memory_regions(&self, shared_mem: &GuestSharedMemory) -> Result<Vec<MemoryRegion>> {
  600|    118|        let mut builder = MemoryRegionVecBuilder::new(Self::BASE_ADDRESS, shared_mem.base_addr());
  601|    118|
  602|    118|        cfg_if::cfg_if! {
  603|    118|            if #[cfg(feature = "init-paging")] {
  604|    118|                // PML4, PDPT, PD
  605|    118|                let code_offset = builder.push_page_aligned(
  606|    118|                    self.total_page_table_size,
  607|    118|                    MemoryRegionFlags::READ | MemoryRegionFlags::WRITE,
  608|    118|                    PageTables,
  609|    118|                );
  610|    118|
  611|    118|                if code_offset != self.guest_code_offset {
  612|      0|                    return Err(new_error!(
  613|      0|                        "Code offset does not match expected code offset expected:  {}, actual:  {}",
  614|      0|                        self.guest_code_offset,
  615|      0|                        code_offset
  616|      0|                    ));
  617|    118|                }
  618|    118|            }
  619|    118|        }
  620|    118|
  621|    118|        // code
  622|    118|        let peb_offset = builder.push_page_aligned(
  623|    118|            self.code_size,
  624|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE | MemoryRegionFlags::EXECUTE,
  625|    118|            Code,
  626|    118|        );
  627|       |
  628|    118|        let expected_peb_offset = TryInto::<usize>::try_into(self.peb_offset)?;
                                                                                           ^0
  629|       |
  630|    118|        if peb_offset != expected_peb_offset {
  631|      0|            return Err(new_error!(
  632|      0|                "PEB offset does not match expected PEB offset expected:  {}, actual:  {}",
  633|      0|                expected_peb_offset,
  634|      0|                peb_offset
  635|      0|            ));
  636|    118|        }
  637|    118|
  638|    118|        // PEB
  639|    118|        let host_functions_definitions_offset = builder.push_page_aligned(
  640|    118|            size_of::<HyperlightPEB>(),
  641|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE,
  642|    118|            Peb,
  643|    118|        );
  644|       |
  645|    118|        let expected_host_functions_definitions_offset =
  646|    118|            TryInto::<usize>::try_into(self.host_function_definitions_buffer_offset)?;
                                                                                                  ^0
  647|       |
  648|    118|        if host_functions_definitions_offset != expected_host_functions_definitions_offset {
  649|      0|            return Err(new_error!(
  650|      0|                "Host Function Definitions offset does not match expected Host Function Definitions offset expected:  {}, actual:  {}",
  651|      0|                expected_host_functions_definitions_offset,
  652|      0|                host_functions_definitions_offset
  653|      0|            ));
  654|    118|        }
  655|    118|
  656|    118|        // host function definitions
  657|    118|        let input_data_offset = builder.push_page_aligned(
  658|    118|            self.sandbox_memory_config
  659|    118|                .get_host_function_definition_size(),
  660|    118|            MemoryRegionFlags::READ,
  661|    118|            HostFunctionDefinitions,
  662|    118|        );
  663|       |
  664|    118|        let expected_input_data_offset = TryInto::<usize>::try_into(self.input_data_buffer_offset)?;
                                                                                                                ^0
  665|       |
  666|    118|        if input_data_offset != expected_input_data_offset {
  667|      0|            return Err(new_error!(
  668|      0|                "Input Data offset does not match expected Input Data offset expected:  {}, actual:  {}",
  669|      0|                expected_input_data_offset,
  670|      0|                input_data_offset
  671|      0|            ));
  672|    118|        }
  673|    118|
  674|    118|        // guest input data
  675|    118|        let output_data_offset = builder.push_page_aligned(
  676|    118|            self.sandbox_memory_config.get_input_data_size(),
  677|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE,
  678|    118|            InputData,
  679|    118|        );
  680|       |
  681|    118|        let expected_output_data_offset =
  682|    118|            TryInto::<usize>::try_into(self.output_data_buffer_offset)?;
                                                                                    ^0
  683|       |
  684|    118|        if output_data_offset != expected_output_data_offset {
  685|      0|            return Err(new_error!(
  686|      0|                "Output Data offset does not match expected Output Data offset expected:  {}, actual:  {}",
  687|      0|                expected_output_data_offset,
  688|      0|                output_data_offset
  689|      0|            ));
  690|    118|        }
  691|    118|
  692|    118|        // guest output data
  693|    118|        let heap_offset = builder.push_page_aligned(
  694|    118|            self.sandbox_memory_config.get_output_data_size(),
  695|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE,
  696|    118|            OutputData,
  697|    118|        );
  698|       |
  699|    118|        let expected_heap_offset = TryInto::<usize>::try_into(self.guest_heap_buffer_offset)?;
                                                                                                          ^0
  700|       |
  701|    118|        if heap_offset != expected_heap_offset {
  702|      0|            return Err(new_error!(
  703|      0|                "Guest Heap offset does not match expected Guest Heap offset expected:  {}, actual:  {}",
  704|      0|                expected_heap_offset,
  705|      0|                heap_offset
  706|      0|            ));
  707|    118|        }
  708|    118|
  709|    118|        // heap
  710|    118|        #[cfg(feature = "executable_heap")]
  711|    118|        let guard_page_offset = builder.push_page_aligned(
  712|    118|            self.heap_size,
  713|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE | MemoryRegionFlags::EXECUTE,
  714|    118|            Heap,
  715|    118|        );
  716|    118|        #[cfg(not(feature = "executable_heap"))]
  717|    118|        let guard_page_offset = builder.push_page_aligned(
  718|    118|            self.heap_size,
  719|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE,
  720|    118|            Heap,
  721|    118|        );
  722|       |
  723|    118|        let expected_guard_page_offset = TryInto::<usize>::try_into(self.guard_page_offset)?;
                                                                                                         ^0
  724|       |
  725|    118|        if guard_page_offset != expected_guard_page_offset {
  726|      0|            return Err(new_error!(
  727|      0|                "Guard Page offset does not match expected Guard Page offset expected:  {}, actual:  {}",
  728|      0|                expected_guard_page_offset,
  729|      0|                guard_page_offset
  730|      0|            ));
  731|    118|        }
  732|    118|
  733|    118|        // guard page
  734|    118|        let stack_offset = builder.push_page_aligned(
  735|    118|            PAGE_SIZE_USIZE,
  736|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::STACK_GUARD,
  737|    118|            GuardPage,
  738|    118|        );
  739|       |
  740|    118|        let expected_stack_offset =
  741|    118|            TryInto::<usize>::try_into(self.guest_user_stack_buffer_offset)?;
                                                                                         ^0
  742|       |
  743|    118|        if stack_offset != expected_stack_offset {
  744|      0|            return Err(new_error!(
  745|      0|                "Stack offset does not match expected Stack offset expected:  {}, actual:  {}",
  746|      0|                expected_stack_offset,
  747|      0|                stack_offset
  748|      0|            ));
  749|    118|        }
  750|    118|
  751|    118|        // stack
  752|    118|        let init_data_offset = builder.push_page_aligned(
  753|    118|            self.get_guest_stack_size(),
  754|    118|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE,
  755|    118|            Stack,
  756|    118|        );
  757|       |
  758|    118|        let expected_init_data_offset = TryInto::<usize>::try_into(self.init_data_offset)?;
                                                                                                       ^0
  759|       |
  760|    118|        if init_data_offset != expected_init_data_offset {
  761|      0|            return Err(new_error!(
  762|      0|                "Init Data offset does not match expected Init Data offset expected:  {}, actual:  {}",
  763|      0|                expected_init_data_offset,
  764|      0|                init_data_offset
  765|      0|            ));
  766|    118|        }
  767|       |
  768|    118|        let final_offset = if self.init_data_size > 0 {
  769|      2|            let mem_flags = self
  770|      2|                .init_data_permissions
  771|      2|                .unwrap_or(DEFAULT_GUEST_BLOB_MEM_FLAGS);
  772|      2|            builder.push_page_aligned(self.init_data_size, mem_flags, InitData)
  773|       |        } else {
  774|    116|            init_data_offset
  775|       |        };
  776|       |
  777|    118|        let expected_final_offset = TryInto::<usize>::try_into(self.get_memory_size()?)?;
                                                                                                   ^0^0
  778|       |
  779|    118|        if final_offset != expected_final_offset {
  780|      0|            return Err(new_error!(
  781|      0|                "Final offset does not match expected Final offset expected:  {}, actual:  {}",
  782|      0|                expected_final_offset,
  783|      0|                final_offset
  784|      0|            ));
  785|    118|        }
  786|    118|
  787|    118|        Ok(builder.build())
  788|    118|    }
  789|       |
  790|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  791|      1|    pub(crate) fn write_init_data(
  792|      1|        &self,
  793|      1|        shared_mem: &mut ExclusiveSharedMemory,
  794|      1|        bytes: &[u8],
  795|      1|    ) -> Result<()> {
  796|       |        shared_mem.copy_from_slice(bytes, self.init_data_offset)?;
  797|       |        Ok(())
  798|      1|    }
  799|       |
  800|       |    /// Write the finished memory layout to `shared_mem` and return
  801|       |    /// `Ok` if successful.
  802|       |    ///
  803|       |    /// Note: `shared_mem` may have been modified, even if `Err` was returned
  804|       |    /// from this function.
  805|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  806|     64|    pub(crate) fn write(
  807|     64|        &self,
  808|     64|        shared_mem: &mut ExclusiveSharedMemory,
  809|     64|        guest_offset: usize,
  810|     64|        size: usize,
  811|     64|    ) -> Result<()> {
  812|       |        macro_rules! get_address {
  813|       |            ($something:ident) => {
  814|       |                u64::try_from(guest_offset + self.$something)?
  815|       |            };
  816|       |        }
  817|       |
  818|       |        if guest_offset != SandboxMemoryLayout::BASE_ADDRESS
  819|       |            && guest_offset != shared_mem.base_addr()
  820|       |        {
  821|       |            return Err(GuestOffsetIsInvalid(guest_offset));
  822|       |        }
  823|       |
  824|       |        // Start of setting up the PEB. The following are in the order of the PEB fields
  825|       |
  826|       |        // Set up the security cookie seed
  827|       |        let mut security_cookie_seed = [0u8; 8];
  828|       |        rng().fill_bytes(&mut security_cookie_seed);
  829|       |        shared_mem.copy_from_slice(&security_cookie_seed, self.peb_security_cookie_seed_offset)?;
  830|       |
  831|       |        // Skip guest_dispatch_function_ptr_offset because it is set by the guest
  832|       |
  833|       |        // Set up Host Function Definition
  834|       |        shared_mem.write_u64(
  835|       |            self.get_host_function_definitions_size_offset(),
  836|       |            self.sandbox_memory_config
  837|       |                .get_host_function_definition_size()
  838|       |                .try_into()?,
  839|       |        )?;
  840|       |        let addr = get_address!(host_function_definitions_buffer_offset);
  841|       |        shared_mem.write_u64(self.get_host_function_definitions_pointer_offset(), addr)?;
  842|       |
  843|       |        // Skip code, is set when loading binary
  844|       |        // skip outb and outb context, is set when running in_proc
  845|       |
  846|       |        // Set up input buffer pointer
  847|       |        shared_mem.write_u64(
  848|       |            self.get_input_data_size_offset(),
  849|       |            self.sandbox_memory_config
  850|       |                .get_input_data_size()
  851|       |                .try_into()?,
  852|       |        )?;
  853|       |        let addr = get_address!(input_data_buffer_offset);
  854|       |        shared_mem.write_u64(self.get_input_data_pointer_offset(), addr)?;
  855|       |
  856|       |        // Set up output buffer pointer
  857|       |        shared_mem.write_u64(
  858|       |            self.get_output_data_size_offset(),
  859|       |            self.sandbox_memory_config
  860|       |                .get_output_data_size()
  861|       |                .try_into()?,
  862|       |        )?;
  863|       |        let addr = get_address!(output_data_buffer_offset);
  864|       |        shared_mem.write_u64(self.get_output_data_pointer_offset(), addr)?;
  865|       |
  866|       |        // Set up init data pointer
  867|       |        shared_mem.write_u64(
  868|       |            self.get_init_data_size_offset(),
  869|       |            (self.get_unaligned_memory_size() - self.init_data_offset).try_into()?,
  870|       |        )?;
  871|       |        let addr = get_address!(init_data_offset);
  872|       |        shared_mem.write_u64(self.get_init_data_pointer_offset(), addr)?;
  873|       |
  874|       |        // Set up heap buffer pointer
  875|       |        let addr = get_address!(guest_heap_buffer_offset);
  876|       |        shared_mem.write_u64(self.get_heap_size_offset(), self.heap_size.try_into()?)?;
  877|       |        shared_mem.write_u64(self.get_heap_pointer_offset(), addr)?;
  878|       |
  879|       |        // Set up user stack pointers
  880|       |
  881|       |        // Set up Min Guest User Stack Address
  882|       |
  883|       |        // The top of the user stack is calculated as the size of the guest memory + the guest offset which gives us the
  884|       |        // address at the bottom of the guest memory.
  885|       |
  886|       |        let bottom = guest_offset + size;
  887|       |        let min_user_stack_address = bottom - self.stack_size;
  888|       |
  889|       |        // Top of user stack
  890|       |
  891|       |        shared_mem.write_u64(
  892|       |            self.get_min_guest_stack_address_offset(),
  893|       |            min_user_stack_address.try_into()?,
  894|       |        )?;
  895|       |
  896|       |        // Start of user stack
  897|       |
  898|       |        let start_of_user_stack: u64 = (min_user_stack_address + self.stack_size).try_into()?;
  899|       |
  900|       |        shared_mem.write_u64(self.get_user_stack_pointer_offset(), start_of_user_stack)?;
  901|       |
  902|       |        // End of setting up the PEB
  903|       |
  904|       |        // Initialize the stack pointers of input data and output data
  905|       |        // to point to the ninth (index 8) byte, which is the first free address
  906|       |        // of the each respective stack. The first 8 bytes are the stack pointer itself.
  907|       |        shared_mem.write_u64(
  908|       |            self.input_data_buffer_offset,
  909|       |            Self::STACK_POINTER_SIZE_BYTES,
  910|       |        )?;
  911|       |        shared_mem.write_u64(
  912|       |            self.output_data_buffer_offset,
  913|       |            Self::STACK_POINTER_SIZE_BYTES,
  914|       |        )?;
  915|       |
  916|       |        Ok(())
  917|     64|    }
  918|       |}
  919|       |
  920|    944|fn round_up_to(value: usize, multiple: usize) -> usize {
  921|    944|    (value + multiple - 1) & !(multiple - 1)
  922|    944|}
  923|       |
  924|       |#[cfg(test)]
  925|       |mod tests {
  926|       |    use hyperlight_common::mem::PAGE_SIZE_USIZE;
  927|       |
  928|       |    use super::*;
  929|       |
  930|       |    #[test]
  931|      1|    fn test_round_up() {
  932|      1|        assert_eq!(0, round_up_to(0, 4));
  933|      1|        assert_eq!(4, round_up_to(1, 4));
  934|      1|        assert_eq!(4, round_up_to(2, 4));
  935|      1|        assert_eq!(4, round_up_to(3, 4));
  936|      1|        assert_eq!(4, round_up_to(4, 4));
  937|      1|        assert_eq!(8, round_up_to(5, 4));
  938|      1|        assert_eq!(8, round_up_to(6, 4));
  939|      1|        assert_eq!(8, round_up_to(7, 4));
  940|      1|        assert_eq!(8, round_up_to(8, 4));
  941|      1|        assert_eq!(PAGE_SIZE_USIZE, round_up_to(44, PAGE_SIZE_USIZE));
  942|      1|        assert_eq!(PAGE_SIZE_USIZE, round_up_to(4095, PAGE_SIZE_USIZE));
  943|      1|        assert_eq!(PAGE_SIZE_USIZE, round_up_to(4096, PAGE_SIZE_USIZE));
  944|      1|        assert_eq!(PAGE_SIZE_USIZE * 2, round_up_to(4097, PAGE_SIZE_USIZE));
  945|      1|        assert_eq!(PAGE_SIZE_USIZE * 2, round_up_to(8191, PAGE_SIZE_USIZE));
  946|      1|    }
  947|       |
  948|       |    // helper func for testing
  949|      1|    fn get_expected_memory_size(layout: &SandboxMemoryLayout) -> usize {
  950|      1|        let cfg = layout.sandbox_memory_config;
  951|      1|        let mut expected_size = 0;
  952|      1|        // in order of layout
  953|      1|        #[cfg(feature = "init-paging")]
  954|      1|        {
  955|      1|            expected_size += layout.get_page_table_size();
  956|      1|        }
  957|      1|        expected_size += layout.code_size;
  958|      1|
  959|      1|        expected_size += round_up_to(size_of::<HyperlightPEB>(), PAGE_SIZE_USIZE);
  960|      1|
  961|      1|        expected_size += round_up_to(cfg.get_host_function_definition_size(), PAGE_SIZE_USIZE);
  962|      1|
  963|      1|        expected_size += round_up_to(cfg.get_input_data_size(), PAGE_SIZE_USIZE);
  964|      1|
  965|      1|        expected_size += round_up_to(cfg.get_output_data_size(), PAGE_SIZE_USIZE);
  966|      1|
  967|      1|        expected_size += round_up_to(layout.heap_size, PAGE_SIZE_USIZE);
  968|      1|
  969|      1|        expected_size += PAGE_SIZE_USIZE; // guard page
  970|      1|
  971|      1|        expected_size += round_up_to(layout.stack_size, PAGE_SIZE_USIZE);
  972|      1|
  973|      1|        expected_size
  974|      1|    }
  975|       |
  976|       |    #[test]
  977|      1|    fn test_get_memory_size() {
  978|      1|        let sbox_cfg = SandboxConfiguration::default();
  979|      1|        let sbox_mem_layout =
  980|      1|            SandboxMemoryLayout::new(sbox_cfg, 4096, 2048, 4096, 0, None).unwrap();
  981|      1|        assert_eq!(
  982|      1|            sbox_mem_layout.get_memory_size().unwrap(),
  983|      1|            get_expected_memory_size(&sbox_mem_layout)
  984|      1|        );
  985|      1|    }
  986|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/memory_region.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(mshv2)]
   18|       |extern crate mshv_bindings2 as mshv_bindings;
   19|       |#[cfg(mshv2)]
   20|       |extern crate mshv_ioctls2 as mshv_ioctls;
   21|       |
   22|       |#[cfg(mshv3)]
   23|       |extern crate mshv_bindings3 as mshv_bindings;
   24|       |#[cfg(mshv3)]
   25|       |extern crate mshv_ioctls3 as mshv_ioctls;
   26|       |
   27|       |use std::ops::Range;
   28|       |
   29|       |use bitflags::bitflags;
   30|       |#[cfg(mshv)]
   31|       |use hyperlight_common::mem::PAGE_SHIFT;
   32|       |use hyperlight_common::mem::PAGE_SIZE_USIZE;
   33|       |#[cfg(kvm)]
   34|       |use kvm_bindings::{KVM_MEM_READONLY, kvm_userspace_memory_region};
   35|       |#[cfg(mshv2)]
   36|       |use mshv_bindings::{
   37|       |    HV_MAP_GPA_EXECUTABLE, HV_MAP_GPA_PERMISSIONS_NONE, HV_MAP_GPA_READABLE, HV_MAP_GPA_WRITABLE,
   38|       |};
   39|       |#[cfg(mshv3)]
   40|       |use mshv_bindings::{
   41|       |    MSHV_SET_MEM_BIT_EXECUTABLE, MSHV_SET_MEM_BIT_UNMAP, MSHV_SET_MEM_BIT_WRITABLE,
   42|       |};
   43|       |#[cfg(mshv)]
   44|       |use mshv_bindings::{hv_x64_memory_intercept_message, mshv_user_mem_region};
   45|       |#[cfg(target_os = "windows")]
   46|       |use windows::Win32::System::Hypervisor::{self, WHV_MEMORY_ACCESS_TYPE};
   47|       |
   48|       |#[cfg(feature = "init-paging")]
   49|       |use super::mgr::{PAGE_NX, PAGE_PRESENT, PAGE_RW, PAGE_USER};
   50|       |
   51|       |pub(crate) const DEFAULT_GUEST_BLOB_MEM_FLAGS: MemoryRegionFlags = MemoryRegionFlags::READ;
   52|       |
   53|       |bitflags! {
   54|       |    /// flags representing memory permission for a memory region
   55|       |    #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
   56|       |    pub struct MemoryRegionFlags: u32 {
   57|       |        /// no permissions
   58|       |        const NONE = 0;
   59|       |        /// allow guest to read
   60|       |        const READ = 1;
   61|       |        /// allow guest to write
   62|       |        const WRITE = 2;
   63|       |        /// allow guest to execute
   64|       |        const EXECUTE = 4;
   65|       |        /// identifier that this is a stack guard page
   66|       |        const STACK_GUARD = 8;
   67|       |    }
   68|       |}
   69|       |
   70|       |impl MemoryRegionFlags {
   71|       |    #[cfg(feature = "init-paging")]
   72|      2|    pub(crate) fn translate_flags(&self) -> u64 {
   73|      2|        let mut page_flags = 0;
   74|      2|
   75|      2|        page_flags |= PAGE_PRESENT; // Mark page as present
   76|      2|
   77|      2|        if self.contains(MemoryRegionFlags::WRITE) {
   78|      0|            page_flags |= PAGE_RW; // Allow read/write
   79|      2|        }
   80|       |
   81|      2|        if self.contains(MemoryRegionFlags::STACK_GUARD) {
   82|      0|            page_flags |= PAGE_RW; // The guard page is marked RW so that if it gets written to we can detect it in the host
   83|      2|        }
   84|       |
   85|      2|        if self.contains(MemoryRegionFlags::EXECUTE) {
   86|      0|            page_flags |= PAGE_USER; // Allow user access
   87|      2|        } else {
   88|      2|            page_flags |= PAGE_NX; // Mark as non-executable if EXECUTE is not set
   89|      2|        }
   90|       |
   91|      2|        page_flags
   92|      2|    }
   93|       |}
   94|       |
   95|       |impl std::fmt::Display for MemoryRegionFlags {
   96|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   97|      0|        if self.is_empty() {
   98|      0|            write!(f, "NONE")
   99|       |        } else {
  100|      0|            let mut first = true;
  101|      0|            if self.contains(MemoryRegionFlags::READ) {
  102|      0|                write!(f, "READ")?;
  103|      0|                first = false;
  104|      0|            }
  105|      0|            if self.contains(MemoryRegionFlags::WRITE) {
  106|      0|                if !first {
  107|      0|                    write!(f, " | ")?;
  108|      0|                }
  109|      0|                write!(f, "WRITE")?;
  110|      0|                first = false;
  111|      0|            }
  112|      0|            if self.contains(MemoryRegionFlags::EXECUTE) {
  113|      0|                if !first {
  114|      0|                    write!(f, " | ")?;
  115|      0|                }
  116|      0|                write!(f, "EXECUTE")?;
  117|      0|            }
  118|      0|            Ok(())
  119|       |        }
  120|      0|    }
  121|       |}
  122|       |
  123|       |#[cfg(target_os = "windows")]
  124|       |impl TryFrom<WHV_MEMORY_ACCESS_TYPE> for MemoryRegionFlags {
  125|       |    type Error = crate::HyperlightError;
  126|       |
  127|       |    fn try_from(flags: WHV_MEMORY_ACCESS_TYPE) -> crate::Result<Self> {
  128|       |        match flags {
  129|       |            Hypervisor::WHvMemoryAccessRead => Ok(MemoryRegionFlags::READ),
  130|       |            Hypervisor::WHvMemoryAccessWrite => Ok(MemoryRegionFlags::WRITE),
  131|       |            Hypervisor::WHvMemoryAccessExecute => Ok(MemoryRegionFlags::EXECUTE),
  132|       |            _ => Err(crate::HyperlightError::Error(
  133|       |                "unknown memory access type".to_string(),
  134|       |            )),
  135|       |        }
  136|       |    }
  137|       |}
  138|       |
  139|       |#[cfg(mshv)]
  140|       |impl TryFrom<hv_x64_memory_intercept_message> for MemoryRegionFlags {
  141|       |    type Error = crate::HyperlightError;
  142|       |
  143|      0|    fn try_from(msg: hv_x64_memory_intercept_message) -> crate::Result<Self> {
  144|      0|        let access_type = msg.header.intercept_access_type;
  145|      0|        match access_type {
  146|      0|            0 => Ok(MemoryRegionFlags::READ),
  147|      0|            1 => Ok(MemoryRegionFlags::WRITE),
  148|      0|            2 => Ok(MemoryRegionFlags::EXECUTE),
  149|      0|            _ => Err(crate::HyperlightError::Error(
  150|      0|                "unknown memory access type".to_string(),
  151|      0|            )),
  152|       |        }
  153|      0|    }
  154|       |}
  155|       |
  156|       |// only used for debugging
  157|       |#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]
  158|       |/// The type of memory region
  159|       |pub enum MemoryRegionType {
  160|       |    /// The region contains the guest's page tables
  161|       |    PageTables,
  162|       |    /// The region contains the guest's code
  163|       |    Code,
  164|       |    /// The region contains the guest's init data
  165|       |    InitData,
  166|       |    /// The region contains the PEB
  167|       |    Peb,
  168|       |    /// The region contains the Host Function Definitions
  169|       |    HostFunctionDefinitions,
  170|       |    /// The region contains the Input Data
  171|       |    InputData,
  172|       |    /// The region contains the Output Data
  173|       |    OutputData,
  174|       |    /// The region contains the Heap
  175|       |    Heap,
  176|       |    /// The region contains the Guard Page
  177|       |    GuardPage,
  178|       |    /// The region contains the Stack
  179|       |    Stack,
  180|       |}
  181|       |
  182|       |/// represents a single memory region inside the guest. All memory within a region has
  183|       |/// the same memory permissions
  184|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
  185|       |pub struct MemoryRegion {
  186|       |    /// the range of guest memory addresses
  187|       |    pub guest_region: Range<usize>,
  188|       |    /// the range of host memory addresses
  189|       |    pub host_region: Range<usize>,
  190|       |    /// memory access flags for the given region
  191|       |    pub flags: MemoryRegionFlags,
  192|       |    /// the type of memory region
  193|       |    pub region_type: MemoryRegionType,
  194|       |}
  195|       |
  196|       |pub(crate) struct MemoryRegionVecBuilder {
  197|       |    guest_base_phys_addr: usize,
  198|       |    host_base_virt_addr: usize,
  199|       |    regions: Vec<MemoryRegion>,
  200|       |}
  201|       |
  202|       |impl MemoryRegionVecBuilder {
  203|    118|    pub(crate) fn new(guest_base_phys_addr: usize, host_base_virt_addr: usize) -> Self {
  204|    118|        Self {
  205|    118|            guest_base_phys_addr,
  206|    118|            host_base_virt_addr,
  207|    118|            regions: Vec::new(),
  208|    118|        }
  209|    118|    }
  210|       |
  211|  1.06k|    fn push(
  212|  1.06k|        &mut self,
  213|  1.06k|        size: usize,
  214|  1.06k|        flags: MemoryRegionFlags,
  215|  1.06k|        region_type: MemoryRegionType,
  216|  1.06k|    ) -> usize {
  217|  1.06k|        if self.regions.is_empty() {
  218|    118|            let guest_end = self.guest_base_phys_addr + size;
  219|    118|            let host_end = self.host_base_virt_addr + size;
  220|    118|            self.regions.push(MemoryRegion {
  221|    118|                guest_region: self.guest_base_phys_addr..guest_end,
  222|    118|                host_region: self.host_base_virt_addr..host_end,
  223|    118|                flags,
  224|    118|                region_type,
  225|    118|            });
  226|    118|            return guest_end - self.guest_base_phys_addr;
  227|    946|        }
  228|    946|
  229|    946|        #[allow(clippy::unwrap_used)]
  230|    946|        // we know this is safe because we check if the regions are empty above
  231|    946|        let last_region = self.regions.last().unwrap();
  232|    946|        let new_region = MemoryRegion {
  233|    946|            guest_region: last_region.guest_region.end..last_region.guest_region.end + size,
  234|    946|            host_region: last_region.host_region.end..last_region.host_region.end + size,
  235|    946|            flags,
  236|    946|            region_type,
  237|    946|        };
  238|    946|        let ret = new_region.guest_region.end;
  239|    946|        self.regions.push(new_region);
  240|    946|        ret - self.guest_base_phys_addr
  241|  1.06k|    }
  242|       |
  243|       |    /// Pushes a memory region with the given size. Will round up the size to the nearest page.
  244|       |    /// Returns the current size of the all memory regions in the builder after adding the given region.
  245|       |    /// # Note:
  246|       |    /// Memory regions pushed MUST match the guest's memory layout, in SandboxMemoryLayout::new(..)
  247|  1.06k|    pub(crate) fn push_page_aligned(
  248|  1.06k|        &mut self,
  249|  1.06k|        size: usize,
  250|  1.06k|        flags: MemoryRegionFlags,
  251|  1.06k|        region_type: MemoryRegionType,
  252|  1.06k|    ) -> usize {
  253|  1.06k|        let aligned_size = (size + PAGE_SIZE_USIZE - 1) & !(PAGE_SIZE_USIZE - 1);
  254|  1.06k|        self.push(aligned_size, flags, region_type)
  255|  1.06k|    }
  256|       |
  257|       |    /// Consumes the builder and returns a vec of memory regions. The regions are guaranteed to be a contiguous chunk
  258|       |    /// of memory, in other words, there will be any memory gaps between them.
  259|    118|    pub(crate) fn build(self) -> Vec<MemoryRegion> {
  260|    118|        self.regions
  261|    118|    }
  262|       |}
  263|       |
  264|       |#[cfg(mshv)]
  265|       |impl From<MemoryRegion> for mshv_user_mem_region {
  266|      0|    fn from(region: MemoryRegion) -> Self {
  267|      0|        let size = (region.guest_region.end - region.guest_region.start) as u64;
  268|      0|        let guest_pfn = region.guest_region.start as u64 >> PAGE_SHIFT;
  269|      0|        let userspace_addr = region.host_region.start as u64;
  270|      0|
  271|      0|        #[cfg(mshv2)]
  272|      0|        {
  273|      0|            let flags = region.flags.iter().fold(0, |acc, flag| {
  274|      0|                let flag_value = match flag {
  275|      0|                    MemoryRegionFlags::NONE => HV_MAP_GPA_PERMISSIONS_NONE,
  276|      0|                    MemoryRegionFlags::READ => HV_MAP_GPA_READABLE,
  277|      0|                    MemoryRegionFlags::WRITE => HV_MAP_GPA_WRITABLE,
  278|      0|                    MemoryRegionFlags::EXECUTE => HV_MAP_GPA_EXECUTABLE,
  279|      0|                    _ => 0, // ignore any unknown flags
  280|      0|                };
  281|      0|                acc | flag_value
  282|      0|            });
  283|      0|            mshv_user_mem_region {
  284|      0|                guest_pfn,
  285|      0|                size,
  286|      0|                userspace_addr,
  287|      0|                flags,
  288|      0|            }
  289|      0|        }
  290|      0|        #[cfg(mshv3)]
  291|      0|        {
  292|      0|            let flags: u8 = region.flags.iter().fold(0, |acc, flag| {
  293|      0|                let flag_value = match flag {
  294|      0|                    MemoryRegionFlags::NONE => 1 << MSHV_SET_MEM_BIT_UNMAP,
  295|      0|                    MemoryRegionFlags::READ => 0,
  296|      0|                    MemoryRegionFlags::WRITE => 1 << MSHV_SET_MEM_BIT_WRITABLE,
  297|      0|                    MemoryRegionFlags::EXECUTE => 1 << MSHV_SET_MEM_BIT_EXECUTABLE,
  298|      0|                    _ => 0, // ignore any unknown flags
  299|       |                };
  300|      0|                acc | flag_value
  301|      0|            });
  302|      0|
  303|      0|            mshv_user_mem_region {
  304|      0|                guest_pfn,
  305|      0|                size,
  306|      0|                userspace_addr,
  307|      0|                flags,
  308|      0|                ..Default::default()
  309|      0|            }
  310|      0|        }
  311|      0|    }
  312|       |}
  313|       |
  314|       |#[cfg(kvm)]
  315|       |impl From<MemoryRegion> for kvm_bindings::kvm_userspace_memory_region {
  316|      0|    fn from(region: MemoryRegion) -> Self {
  317|      0|        let perm_flags =
  318|      0|            MemoryRegionFlags::READ | MemoryRegionFlags::WRITE | MemoryRegionFlags::EXECUTE;
  319|      0|
  320|      0|        let perm_flags = perm_flags.intersection(region.flags);
  321|      0|
  322|      0|        kvm_userspace_memory_region {
  323|      0|            slot: 0,
  324|      0|            guest_phys_addr: region.guest_region.start as u64,
  325|      0|            memory_size: (region.guest_region.end - region.guest_region.start) as u64,
  326|      0|            userspace_addr: region.host_region.start as u64,
  327|      0|            flags: if perm_flags.contains(MemoryRegionFlags::WRITE) {
  328|      0|                0 // RWX
  329|       |            } else {
  330|       |                // Note: KVM_MEM_READONLY is executable
  331|      0|                KVM_MEM_READONLY // RX 
  332|       |            },
  333|       |        }
  334|      0|    }
  335|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/mgr.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::cmp::Ordering;
   18|       |
   19|       |use hyperlight_common::flatbuffer_wrappers::function_call::{
   20|       |    FunctionCall, validate_guest_function_call_buffer,
   21|       |};
   22|       |use hyperlight_common::flatbuffer_wrappers::function_types::ReturnValue;
   23|       |use hyperlight_common::flatbuffer_wrappers::guest_error::GuestError;
   24|       |use hyperlight_common::flatbuffer_wrappers::guest_log_data::GuestLogData;
   25|       |use hyperlight_common::flatbuffer_wrappers::host_function_details::HostFunctionDetails;
   26|       |use tracing::{Span, instrument};
   27|       |
   28|       |use super::exe::ExeInfo;
   29|       |use super::layout::SandboxMemoryLayout;
   30|       |use super::memory_region::MemoryRegion;
   31|       |#[cfg(feature = "init-paging")]
   32|       |use super::memory_region::{DEFAULT_GUEST_BLOB_MEM_FLAGS, MemoryRegionType};
   33|       |use super::ptr::{GuestPtr, RawPtr};
   34|       |use super::ptr_offset::Offset;
   35|       |use super::shared_mem::{ExclusiveSharedMemory, GuestSharedMemory, HostSharedMemory, SharedMemory};
   36|       |use super::shared_mem_snapshot::SharedMemorySnapshot;
   37|       |use crate::sandbox::SandboxConfiguration;
   38|       |use crate::sandbox::uninitialized::GuestBlob;
   39|       |use crate::{Result, log_then_return, new_error};
   40|       |
   41|       |cfg_if::cfg_if! {
   42|       |    if #[cfg(feature = "init-paging")] {
   43|       |        /// Paging Flags
   44|       |        ///
   45|       |        /// See the following links explaining paging, also see paging-development-notes.md in docs:
   46|       |        ///
   47|       |        /// * Very basic description: https://stackoverflow.com/a/26945892
   48|       |        /// * More in-depth descriptions: https://wiki.osdev.org/Paging
   49|       |        pub(crate) const PAGE_PRESENT: u64 = 1; // Page is Present
   50|       |        pub(crate) const PAGE_RW: u64 = 1 << 1; // Page is Read/Write (if not set page is read only so long as the WP bit in CR0 is set to 1 - which it is in Hyperlight)
   51|       |        pub(crate) const PAGE_USER: u64 = 1 << 2; // User/Supervisor (if this bit is set then the page is accessible by user mode code)
   52|       |        pub(crate) const PAGE_NX: u64 = 1 << 63; // Execute Disable (if this bit is set then data in the page cannot be executed)`
   53|       |        // The amount of memory that can be mapped per page table
   54|       |        pub(super) const AMOUNT_OF_MEMORY_PER_PT: usize = 0x200_000;
   55|       |    }
   56|       |}
   57|       |
   58|       |/// Read/write permissions flag for the 64-bit PDE
   59|       |/// The page size for the 64-bit PDE
   60|       |/// The size of stack guard cookies
   61|       |pub(crate) const STACK_COOKIE_LEN: usize = 16;
   62|       |
   63|       |/// A struct that is responsible for laying out and managing the memory
   64|       |/// for a given `Sandbox`.
   65|       |#[derive(Clone)]
   66|       |pub(crate) struct SandboxMemoryManager<S> {
   67|       |    /// Shared memory for the Sandbox
   68|       |    pub(crate) shared_mem: S,
   69|       |    /// The memory layout of the underlying shared memory
   70|       |    pub(crate) layout: SandboxMemoryLayout,
   71|       |    /// Pointer to where to load memory from
   72|       |    pub(crate) load_addr: RawPtr,
   73|       |    /// Offset for the execution entrypoint from `load_addr`
   74|       |    pub(crate) entrypoint_offset: Offset,
   75|       |    /// How many memory regions were mapped after sandbox creation
   76|       |    pub(crate) mapped_rgns: u64,
   77|       |}
   78|       |
   79|       |impl<S> SandboxMemoryManager<S>
   80|       |where
   81|       |    S: SharedMemory,
   82|       |{
   83|       |    /// Create a new `SandboxMemoryManager` with the given parameters
   84|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   85|     65|    fn new(
   86|     65|        layout: SandboxMemoryLayout,
   87|     65|        shared_mem: S,
   88|     65|        load_addr: RawPtr,
   89|     65|        entrypoint_offset: Offset,
   90|     65|    ) -> Self {
   91|     65|        Self {
   92|     65|            layout,
   93|     65|            shared_mem,
   94|     65|            load_addr,
   95|     65|            entrypoint_offset,
   96|     65|            mapped_rgns: 0,
   97|     65|        }
   98|     65|    }
   99|       |
  100|       |    /// Get `SharedMemory` in `self` as a mutable reference
  101|     65|    pub(crate) fn get_shared_mem_mut(&mut self) -> &mut S {
  102|     65|        &mut self.shared_mem
  103|     65|    }
  104|       |
  105|       |    /// Set up the hypervisor partition in the given `SharedMemory` parameter
  106|       |    /// `shared_mem`, with the given memory size `mem_size`
  107|       |    // TODO: This should perhaps happen earlier and use an
  108|       |    // ExclusiveSharedMemory from the beginning.
  109|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  110|       |    #[cfg(feature = "init-paging")]
  111|     59|    pub(crate) fn set_up_shared_memory(
  112|     59|        &mut self,
  113|     59|        mem_size: u64,
  114|     59|        regions: &mut [MemoryRegion],
  115|     59|    ) -> Result<u64> {
  116|       |        let rsp: u64 = self.layout.get_top_of_user_stack_offset() as u64
  117|       |            + SandboxMemoryLayout::BASE_ADDRESS as u64
  118|       |            + self.layout.stack_size as u64
  119|       |            // TODO: subtracting 0x28 was a requirement for MSVC. It should no longer be
  120|       |            // necessary now, but, for some reason, without this, the `multiple_parameters`
  121|       |            // test from `sandbox_host_tests` fails. We should investigate this further.
  122|       |            // See issue #498 for more details.
  123|       |            - 0x28;
  124|       |
  125|     59|        self.shared_mem.with_exclusivity(|shared_mem| {
  126|     59|            // Create PDL4 table with only 1 PML4E
  127|     59|            shared_mem.write_u64(
  128|     59|                SandboxMemoryLayout::PML4_OFFSET,
  129|     59|                SandboxMemoryLayout::PDPT_GUEST_ADDRESS as u64 | PAGE_PRESENT | PAGE_RW,
  130|     59|            )?;
                           ^0
  131|       |
  132|       |            // Create PDPT with only 1 PDPTE
  133|     59|            shared_mem.write_u64(
  134|     59|                SandboxMemoryLayout::PDPT_OFFSET,
  135|     59|                SandboxMemoryLayout::PD_GUEST_ADDRESS as u64 | PAGE_PRESENT | PAGE_RW,
  136|     59|            )?;
                           ^0
  137|       |
  138|  30.2k|            for i in 0..512 {
                              ^30.2k
  139|  30.2k|                let offset = SandboxMemoryLayout::PD_OFFSET + (i * 8);
  140|  30.2k|                let val_to_write: u64 = (SandboxMemoryLayout::PT_GUEST_ADDRESS as u64
  141|  30.2k|                    + (i * 4096) as u64)
  142|  30.2k|                    | PAGE_PRESENT
  143|  30.2k|                    | PAGE_RW;
  144|  30.2k|                shared_mem.write_u64(offset, val_to_write)?;
                                                                        ^0
  145|       |            }
  146|       |
  147|       |            // We only need to create enough PTEs to map the amount of memory we have
  148|       |            // We need one PT for every 2MB of memory that is mapped
  149|       |            // We can use the memory size to calculate the number of PTs we need
  150|       |            // We round up mem_size/2MB
  151|       |
  152|     59|            let mem_size = usize::try_from(mem_size)?;
                                                                  ^0
  153|       |
  154|     59|            let num_pages: usize = mem_size.div_ceil(AMOUNT_OF_MEMORY_PER_PT);
  155|     59|
  156|     59|            // Create num_pages PT with 512 PTEs
  157|     59|            // Pre-allocate buffer for all page table entries to minimize shared memory writes
  158|     59|            let total_ptes = num_pages * 512;
  159|     59|            let mut pte_buffer = vec![0u64; total_ptes]; // Pre-allocate u64 buffer directly
  160|     59|            let mut cached_region_idx: Option<usize> = None; // Cache for optimized region lookup
  161|     59|            let mut pte_index = 0;
  162|       |
  163|    170|            for p in 0..num_pages {
                                      ^59
  164|  87.2k|                for i in 0..512 {
                                  ^87.0k
  165|       |                    // Each PTE maps a 4KB page
  166|  87.0k|                    let flags = match Self::get_page_flags(p, i, regions, &mut cached_region_idx) {
  167|  69.0k|                        Ok(region_type) => match region_type {
  168|       |                            // TODO: We parse and load the exe according to its sections and then
  169|       |                            // have the correct flags set rather than just marking the entire binary as executable
  170|  65.2k|                            MemoryRegionType::Code => PAGE_PRESENT | PAGE_RW | PAGE_USER,
  171|      1|                            MemoryRegionType::InitData => self
  172|      1|                                .layout
  173|      1|                                .init_data_permissions
  174|      1|                                .map(|perm| perm.translate_flags())
  175|      1|                                .unwrap_or(DEFAULT_GUEST_BLOB_MEM_FLAGS.translate_flags()),
  176|    932|                            MemoryRegionType::Stack => PAGE_PRESENT | PAGE_RW | PAGE_USER | PAGE_NX,
  177|       |                            #[cfg(feature = "executable_heap")]
  178|       |                            MemoryRegionType::Heap => PAGE_PRESENT | PAGE_RW | PAGE_USER,
  179|       |                            #[cfg(not(feature = "executable_heap"))]
  180|  1.86k|                            MemoryRegionType::Heap => PAGE_PRESENT | PAGE_RW | PAGE_USER | PAGE_NX,
  181|       |                            // The guard page is marked RW and User so that if it gets written to we can detect it in the host
  182|       |                            // If/When we implement an interrupt handler for page faults in the guest then we can remove this access and handle things properly there
  183|       |                            MemoryRegionType::GuardPage => {
  184|     59|                                PAGE_PRESENT | PAGE_RW | PAGE_USER | PAGE_NX
  185|       |                            }
  186|    236|                            MemoryRegionType::InputData => PAGE_PRESENT | PAGE_RW | PAGE_NX,
  187|    236|                            MemoryRegionType::OutputData => PAGE_PRESENT | PAGE_RW | PAGE_NX,
  188|     59|                            MemoryRegionType::Peb => PAGE_PRESENT | PAGE_RW | PAGE_NX,
  189|       |                            // Host Function Definitions are readonly in the guest
  190|     59|                            MemoryRegionType::HostFunctionDefinitions => PAGE_PRESENT | PAGE_NX,
  191|    406|                            MemoryRegionType::PageTables => PAGE_PRESENT | PAGE_RW | PAGE_NX,
  192|       |                        },
  193|       |                        // If there is an error then the address isn't mapped so mark it as not present
  194|  17.9k|                        Err(_) => 0,
  195|       |                    };
  196|  87.0k|                    let val_to_write = ((p << 21) as u64 | (i << 12) as u64) | flags;
  197|  87.0k|                    // Write u64 directly to buffer - more efficient than converting to bytes
  198|  87.0k|                    pte_buffer[pte_index] = val_to_write.to_le();
  199|  87.0k|                    pte_index += 1;
  200|       |                }
  201|       |            }
  202|       |
  203|       |            // Write the entire PTE buffer to shared memory in a single operation
  204|       |            // Convert u64 buffer to bytes for writing to shared memory
  205|     59|            let pte_bytes = unsafe {
  206|     59|                std::slice::from_raw_parts(pte_buffer.as_ptr() as *const u8, pte_buffer.len() * 8)
  207|     59|            };
  208|     59|            shared_mem.copy_from_slice(pte_bytes, SandboxMemoryLayout::PT_OFFSET)?;
                                                                                               ^0
  209|     59|            Ok::<(), crate::HyperlightError>(())
  210|     59|        })??;
  211|       |
  212|       |        Ok(rsp)
  213|     59|    }
  214|       |
  215|       |    /// Optimized page flags getter that maintains state for sequential access patterns
  216|       |    #[cfg(feature = "init-paging")]
  217|  87.0k|    fn get_page_flags(
  218|  87.0k|        p: usize,
  219|  87.0k|        i: usize,
  220|  87.0k|        regions: &[MemoryRegion],
  221|  87.0k|        cached_region_idx: &mut Option<usize>,
  222|  87.0k|    ) -> Result<MemoryRegionType> {
  223|  87.0k|        let addr = (p << 21) + (i << 12);
  224|       |
  225|       |        // First check if we're still in the cached region
  226|  87.0k|        if let Some(cached_idx) = *cached_region_idx {
                                  ^86.9k
  227|  86.9k|            if cached_idx < regions.len() && regions[cached_idx].guest_region.contains(&addr) {
  228|  68.5k|                return Ok(regions[cached_idx].region_type);
  229|  18.4k|            }
  230|     59|        }
  231|       |
  232|       |        // If not in cached region, try adjacent regions first (common for sequential access)
  233|  18.5k|        if let Some(cached_idx) = *cached_region_idx {
                                  ^18.4k
  234|       |            // Check next region
  235|  18.4k|            if cached_idx + 1 < regions.len()
  236|    473|                && regions[cached_idx + 1].guest_region.contains(&addr)
  237|       |            {
  238|    473|                *cached_region_idx = Some(cached_idx + 1);
  239|    473|                return Ok(regions[cached_idx + 1].region_type);
  240|  17.9k|            }
  241|     59|        }
  242|       |
  243|       |        // Fall back to binary search for non-sequential access
  244|  90.1k|        let idx = regions.binary_search_by(|region| {
                          ^18.0k
  245|  90.1k|            if region.guest_region.contains(&addr) {
  246|     59|                std::cmp::Ordering::Equal
  247|  90.0k|            } else if region.guest_region.start > addr {
  248|    236|                std::cmp::Ordering::Greater
  249|       |            } else {
  250|  89.8k|                std::cmp::Ordering::Less
  251|       |            }
  252|  90.1k|        });
  253|  18.0k|
  254|  18.0k|        match idx {
  255|     59|            Ok(index) => {
  256|     59|                *cached_region_idx = Some(index);
  257|     59|                Ok(regions[index].region_type)
  258|       |            }
  259|  17.9k|            Err(_) => Err(new_error!("Could not find region for address: {}", addr)),
  260|       |        }
  261|  87.0k|    }
  262|       |
  263|       |    /// Create a snapshot with the given mapped regions
  264|      0|    pub(crate) fn snapshot(
  265|      0|        &mut self,
  266|      0|        sandbox_id: u64,
  267|      0|        mapped_regions: Vec<MemoryRegion>,
  268|      0|    ) -> Result<SharedMemorySnapshot> {
  269|      0|        SharedMemorySnapshot::new(&mut self.shared_mem, sandbox_id, mapped_regions)
  270|      0|    }
  271|       |
  272|       |    /// This function restores a memory snapshot from a given snapshot.
  273|      0|    pub(crate) fn restore_snapshot(&mut self, snapshot: &SharedMemorySnapshot) -> Result<()> {
  274|      0|        if self.shared_mem.mem_size() != snapshot.mem_size() {
  275|      0|            return Err(new_error!(
  276|      0|                "Snapshot size does not match current memory size: {} != {}",
  277|      0|                self.shared_mem.raw_mem_size(),
  278|      0|                snapshot.mem_size()
  279|      0|            ));
  280|      0|        }
  281|      0|        snapshot.restore_from_snapshot(&mut self.shared_mem)?;
  282|      0|        Ok(())
  283|      0|    }
  284|       |
  285|       |    /// Sets `addr` to the correct offset in the memory referenced by
  286|       |    /// `shared_mem` to indicate the address of the outb pointer and context
  287|       |    /// for calling outb function
  288|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  289|       |    #[allow(dead_code)]
  290|      0|    pub(crate) fn set_outb_address_and_context(&mut self, addr: u64, context: u64) -> Result<()> {
  291|       |        let pointer_offset = self.layout.get_outb_pointer_offset();
  292|       |        let context_offset = self.layout.get_outb_context_offset();
  293|      0|        self.shared_mem.with_exclusivity(|excl| -> Result<()> {
  294|      0|            excl.write_u64(pointer_offset, addr)?;
  295|      0|            excl.write_u64(context_offset, context)?;
  296|      0|            Ok(())
  297|      0|        })?
  298|      0|    }
  299|       |}
  300|       |
  301|       |impl SandboxMemoryManager<ExclusiveSharedMemory> {
  302|       |    /// Load the binary represented by `pe_info` into memory, ensuring
  303|       |    /// all necessary relocations are made prior to completing the load
  304|       |    /// operation, then create a new `SharedMemory` to store the new PE
  305|       |    /// file and a `SandboxMemoryLayout` to describe the layout of that
  306|       |    /// new `SharedMemory`.
  307|       |    ///
  308|       |    /// Returns the following:
  309|       |    ///
  310|       |    /// - The newly-created `SharedMemory`
  311|       |    /// - The `SandboxMemoryLayout` describing that `SharedMemory`
  312|       |    /// - The offset to the entrypoint.
  313|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  314|     65|    pub(crate) fn load_guest_binary_into_memory(
  315|     65|        cfg: SandboxConfiguration,
  316|     65|        exe_info: ExeInfo,
  317|     65|        guest_blob: Option<&GuestBlob>,
  318|     65|    ) -> Result<(Self, super::exe::LoadInfo)> {
  319|      1|        let guest_blob_size = guest_blob.map(|b| b.data.len()).unwrap_or(0);
  320|      1|        let guest_blob_mem_flags = guest_blob.map(|b| b.permissions);
  321|       |
  322|       |        let layout = SandboxMemoryLayout::new(
  323|       |            cfg,
  324|       |            exe_info.loaded_size(),
  325|       |            usize::try_from(cfg.get_stack_size(&exe_info))?,
  326|       |            usize::try_from(cfg.get_heap_size(&exe_info))?,
  327|       |            guest_blob_size,
  328|       |            guest_blob_mem_flags,
  329|       |        )?;
  330|       |        let mut shared_mem = ExclusiveSharedMemory::new(layout.get_memory_size()?)?;
  331|       |
  332|       |        let load_addr: RawPtr = RawPtr::try_from(layout.get_guest_code_address())?;
  333|       |
  334|       |        let entrypoint_offset = exe_info.entrypoint();
  335|       |
  336|       |        let offset = layout.get_code_pointer_offset();
  337|       |
  338|       |        {
  339|       |            // write the code pointer to shared memory
  340|       |            let load_addr_u64: u64 = load_addr.clone().into();
  341|       |            shared_mem.write_u64(offset, load_addr_u64)?;
  342|       |        }
  343|       |
  344|       |        // The load method returns a LoadInfo which can also be a different type once the
  345|       |        // `unwind_guest` feature is enabled.
  346|       |        #[allow(clippy::let_unit_value)]
  347|       |        let load_info = exe_info.load(
  348|       |            load_addr.clone().try_into()?,
  349|       |            &mut shared_mem.as_mut_slice()[layout.get_guest_code_offset()..],
  350|       |        )?;
  351|       |
  352|       |        Ok((
  353|       |            Self::new(layout, shared_mem, load_addr, entrypoint_offset),
  354|       |            load_info,
  355|       |        ))
  356|     65|    }
  357|       |
  358|       |    /// Writes host function details to memory
  359|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  360|     71|    pub(crate) fn write_buffer_host_function_details(&mut self, buffer: &[u8]) -> Result<()> {
  361|      0|        let host_function_details = HostFunctionDetails::try_from(buffer).map_err(|e| {
  362|      0|            new_error!(
  363|      0|                "write_buffer_host_function_details: failed to convert buffer to HostFunctionDetails: {}",
  364|      0|                e
  365|      0|            )
  366|      0|        })?;
  367|       |
  368|      0|        let host_function_call_buffer: Vec<u8> = (&host_function_details).try_into().map_err(|_| {
  369|      0|            new_error!(
  370|      0|                "write_buffer_host_function_details: failed to convert HostFunctionDetails to Vec<u8>"
  371|       |            )
  372|      0|        })?;
  373|       |
  374|       |        let buffer_size = {
  375|       |            let size_u64 = self
  376|       |                .shared_mem
  377|       |                .read_u64(self.layout.get_host_function_definitions_size_offset())?;
  378|       |            usize::try_from(size_u64)
  379|       |        }?;
  380|       |
  381|       |        if host_function_call_buffer.len() > buffer_size {
  382|       |            log_then_return!(
  383|       |                "Host Function Details buffer is too big for the host_function_definitions buffer"
  384|       |            );
  385|       |        }
  386|       |
  387|       |        self.shared_mem.copy_from_slice(
  388|       |            host_function_call_buffer.as_slice(),
  389|       |            self.layout.host_function_definitions_buffer_offset,
  390|       |        )?;
  391|       |        Ok(())
  392|     71|    }
  393|       |
  394|       |    /// Set the stack guard to `cookie` using `layout` to calculate
  395|       |    /// its location and `shared_mem` to write it.
  396|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  397|     64|    pub(crate) fn set_stack_guard(&mut self, cookie: &[u8; STACK_COOKIE_LEN]) -> Result<()> {
  398|       |        let stack_offset = self.layout.get_top_of_user_stack_offset();
  399|       |        self.shared_mem.copy_from_slice(cookie, stack_offset)
  400|     64|    }
  401|       |
  402|       |    /// Wraps ExclusiveSharedMemory::build
  403|     59|    pub fn build(
  404|     59|        self,
  405|     59|    ) -> (
  406|     59|        SandboxMemoryManager<HostSharedMemory>,
  407|     59|        SandboxMemoryManager<GuestSharedMemory>,
  408|     59|    ) {
  409|     59|        let (hshm, gshm) = self.shared_mem.build();
  410|     59|        (
  411|     59|            SandboxMemoryManager {
  412|     59|                shared_mem: hshm,
  413|     59|                layout: self.layout,
  414|     59|                load_addr: self.load_addr.clone(),
  415|     59|                entrypoint_offset: self.entrypoint_offset,
  416|     59|                mapped_rgns: 0,
  417|     59|            },
  418|     59|            SandboxMemoryManager {
  419|     59|                shared_mem: gshm,
  420|     59|                layout: self.layout,
  421|     59|                load_addr: self.load_addr.clone(),
  422|     59|                entrypoint_offset: self.entrypoint_offset,
  423|     59|                mapped_rgns: 0,
  424|     59|            },
  425|     59|        )
  426|     59|    }
  427|       |}
  428|       |
  429|       |impl SandboxMemoryManager<HostSharedMemory> {
  430|       |    /// Check the stack guard of the memory in `shared_mem`, using
  431|       |    /// `layout` to calculate its location.
  432|       |    ///
  433|       |    /// Return `true`
  434|       |    /// if `shared_mem` could be accessed properly and the guard
  435|       |    /// matches `cookie`. If it could be accessed properly and the
  436|       |    /// guard doesn't match `cookie`, return `false`. Otherwise, return
  437|       |    /// a descriptive error.
  438|       |    ///
  439|       |    /// This method could be an associated function instead. See
  440|       |    /// documentation at the bottom `set_stack_guard` for description
  441|       |    /// of why it isn't.
  442|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  443|      0|    pub(crate) fn check_stack_guard(&self, cookie: [u8; STACK_COOKIE_LEN]) -> Result<bool> {
  444|       |        let offset = self.layout.get_top_of_user_stack_offset();
  445|       |        let test_cookie: [u8; STACK_COOKIE_LEN] = self.shared_mem.read(offset)?;
  446|       |        let cmp_res = cookie.iter().cmp(test_cookie.iter());
  447|       |        Ok(cmp_res == Ordering::Equal)
  448|      0|    }
  449|       |
  450|       |    /// Get the address of the dispatch function in memory
  451|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  452|      0|    pub(crate) fn get_pointer_to_dispatch_function(&self) -> Result<u64> {
  453|       |        let guest_dispatch_function_ptr = self
  454|       |            .shared_mem
  455|       |            .read::<u64>(self.layout.get_dispatch_function_pointer_offset())?;
  456|       |
  457|       |        // This pointer is written by the guest library but is accessible to
  458|       |        // the guest engine so we should bounds check it before we return it.
  459|       |
  460|       |        let guest_ptr = GuestPtr::try_from(RawPtr::from(guest_dispatch_function_ptr))?;
  461|       |        guest_ptr.absolute()
  462|      0|    }
  463|       |
  464|       |    /// Reads a host function call from memory
  465|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  466|      0|    pub(crate) fn get_host_function_call(&mut self) -> Result<FunctionCall> {
  467|       |        self.shared_mem.try_pop_buffer_into::<FunctionCall>(
  468|       |            self.layout.output_data_buffer_offset,
  469|       |            self.layout.sandbox_memory_config.get_output_data_size(),
  470|       |        )
  471|      0|    }
  472|       |
  473|       |    /// Writes a function call result to memory
  474|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  475|      0|    pub(crate) fn write_response_from_host_method_call(&mut self, res: &ReturnValue) -> Result<()> {
  476|      0|        let function_call_ret_val_buffer = Vec::<u8>::try_from(res).map_err(|_| {
  477|      0|            new_error!(
  478|      0|                "write_response_from_host_method_call: failed to convert ReturnValue to Vec<u8>"
  479|       |            )
  480|      0|        })?;
  481|       |        self.shared_mem.push_buffer(
  482|       |            self.layout.input_data_buffer_offset,
  483|       |            self.layout.sandbox_memory_config.get_input_data_size(),
  484|       |            function_call_ret_val_buffer.as_slice(),
  485|       |        )
  486|      0|    }
  487|       |
  488|       |    /// Writes a guest function call to memory
  489|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  490|      0|    pub(crate) fn write_guest_function_call(&mut self, buffer: &[u8]) -> Result<()> {
  491|      0|        validate_guest_function_call_buffer(buffer).map_err(|e| {
  492|      0|            new_error!(
  493|      0|                "Guest function call buffer validation failed: {}",
  494|      0|                e.to_string()
  495|      0|            )
  496|      0|        })?;
  497|       |
  498|       |        self.shared_mem.push_buffer(
  499|       |            self.layout.input_data_buffer_offset,
  500|       |            self.layout.sandbox_memory_config.get_input_data_size(),
  501|       |            buffer,
  502|       |        )
  503|      0|    }
  504|       |
  505|       |    /// Reads a function call result from memory
  506|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  507|      0|    pub(crate) fn get_guest_function_call_result(&mut self) -> Result<ReturnValue> {
  508|       |        self.shared_mem.try_pop_buffer_into::<ReturnValue>(
  509|       |            self.layout.output_data_buffer_offset,
  510|       |            self.layout.sandbox_memory_config.get_output_data_size(),
  511|       |        )
  512|      0|    }
  513|       |
  514|       |    /// Read guest log data from the `SharedMemory` contained within `self`
  515|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  516|      0|    pub(crate) fn read_guest_log_data(&mut self) -> Result<GuestLogData> {
  517|       |        self.shared_mem.try_pop_buffer_into::<GuestLogData>(
  518|       |            self.layout.output_data_buffer_offset,
  519|       |            self.layout.sandbox_memory_config.get_output_data_size(),
  520|       |        )
  521|      0|    }
  522|       |
  523|       |    /// Get the guest error data
  524|      0|    pub(crate) fn get_guest_error(&mut self) -> Result<GuestError> {
  525|      0|        self.shared_mem.try_pop_buffer_into::<GuestError>(
  526|      0|            self.layout.output_data_buffer_offset,
  527|      0|            self.layout.sandbox_memory_config.get_output_data_size(),
  528|      0|        )
  529|      0|    }
  530|       |
  531|      0|    pub(crate) fn clear_io_buffers(&mut self) {
  532|       |        // Clear the output data buffer
  533|       |        loop {
  534|      0|            let Ok(_) = self.shared_mem.try_pop_buffer_into::<Vec<u8>>(
  535|      0|                self.layout.output_data_buffer_offset,
  536|      0|                self.layout.sandbox_memory_config.get_output_data_size(),
  537|      0|            ) else {
  538|      0|                break;
  539|       |            };
  540|       |        }
  541|       |        // Clear the input data buffer
  542|       |        loop {
  543|      0|            let Ok(_) = self.shared_mem.try_pop_buffer_into::<Vec<u8>>(
  544|      0|                self.layout.input_data_buffer_offset,
  545|      0|                self.layout.sandbox_memory_config.get_input_data_size(),
  546|      0|            ) else {
  547|      0|                break;
  548|      0|            };
  549|      0|        }
  550|      0|    }
  551|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/ptr.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::ops::Add;
   18|       |
   19|       |use tracing::{Span, instrument};
   20|       |
   21|       |use super::ptr_addr_space::{AddressSpace, GuestAddressSpace};
   22|       |use super::ptr_offset::Offset;
   23|       |use crate::Result;
   24|       |use crate::error::HyperlightError::{self, CheckedAddOverflow, RawPointerLessThanBaseAddress};
   25|       |
   26|       |/// A representation of a raw pointer inside a given address space.
   27|       |///
   28|       |/// Use this type to distinguish between an offset and a raw pointer
   29|       |#[derive(Debug, Clone, Eq, PartialEq)]
   30|       |pub struct RawPtr(u64);
   31|       |
   32|       |impl From<u64> for RawPtr {
   33|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   34|    124|    fn from(val: u64) -> Self {
   35|    124|        Self(val)
   36|    124|    }
   37|       |}
   38|       |
   39|       |impl Add<Offset> for RawPtr {
   40|       |    type Output = RawPtr;
   41|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   42|     59|    fn add(self, rhs: Offset) -> RawPtr {
   43|     59|        let val = self.0 + u64::from(rhs);
   44|     59|        RawPtr(val)
   45|     59|    }
   46|       |}
   47|       |
   48|       |impl TryFrom<usize> for RawPtr {
   49|       |    type Error = HyperlightError;
   50|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   51|     65|    fn try_from(val: usize) -> Result<Self> {
   52|       |        let val_u64 = u64::try_from(val)?;
   53|       |        Ok(Self::from(val_u64))
   54|     65|    }
   55|       |}
   56|       |
   57|       |impl TryFrom<RawPtr> for usize {
   58|       |    type Error = HyperlightError;
   59|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   60|     65|    fn try_from(val: RawPtr) -> Result<usize> {
   61|       |        Ok(usize::try_from(val.0)?)
   62|     65|    }
   63|       |}
   64|       |
   65|       |impl From<RawPtr> for u64 {
   66|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   67|     65|    fn from(val: RawPtr) -> u64 {
   68|     65|        val.0
   69|     65|    }
   70|       |}
   71|       |
   72|       |impl From<&RawPtr> for u64 {
   73|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   74|      0|    fn from(val: &RawPtr) -> u64 {
   75|      0|        val.0
   76|      0|    }
   77|       |}
   78|       |
   79|       |/// Convenience type for representing a pointer into the guest address space
   80|       |pub(crate) type GuestPtr = Ptr<GuestAddressSpace>;
   81|       |
   82|       |impl TryFrom<RawPtr> for GuestPtr {
   83|       |    type Error = HyperlightError;
   84|       |    /// Create a new `GuestPtr` from the given `guest_raw_ptr`, which must
   85|       |    /// be a pointer in the guest's address space.
   86|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   87|    119|    fn try_from(raw: RawPtr) -> Result<Self> {
   88|       |        GuestPtr::from_raw_ptr(GuestAddressSpace::new()?, raw)
   89|    119|    }
   90|       |}
   91|       |
   92|       |impl TryFrom<Offset> for GuestPtr {
   93|       |    type Error = HyperlightError;
   94|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   95|     59|    fn try_from(val: Offset) -> Result<Self> {
   96|       |        let addr_space = GuestAddressSpace::new()?;
   97|       |        Ok(Ptr::from_offset(addr_space, val))
   98|     59|    }
   99|       |}
  100|       |
  101|       |impl TryFrom<i64> for GuestPtr {
  102|       |    type Error = HyperlightError;
  103|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  104|      0|    fn try_from(val: i64) -> Result<Self> {
  105|       |        let offset = Offset::try_from(val)?;
  106|       |        GuestPtr::try_from(offset)
  107|      0|    }
  108|       |}
  109|       |
  110|       |impl TryFrom<GuestPtr> for i64 {
  111|       |    type Error = HyperlightError;
  112|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  113|      0|    fn try_from(val: GuestPtr) -> Result<Self> {
  114|       |        let offset = val.offset();
  115|       |        i64::try_from(offset)
  116|      0|    }
  117|       |}
  118|       |
  119|       |/// A pointer into a specific `AddressSpace` `T`.
  120|       |#[derive(Debug, Copy, Clone)]
  121|       |pub(crate) struct Ptr<T: AddressSpace> {
  122|       |    addr_space: T,
  123|       |    offset: Offset,
  124|       |}
  125|       |
  126|       |impl<T: AddressSpace> std::cmp::PartialEq for Ptr<T> {
  127|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  128|     59|    fn eq(&self, other: &Self) -> bool {
  129|     59|        other.addr_space == self.addr_space && other.offset == self.offset
  130|     59|    }
  131|       |}
  132|       |
  133|       |impl<T: AddressSpace> std::cmp::Eq for Ptr<T> {}
  134|       |#[instrument(skip_all, parent = Span::current(), level= "Trace")]
  135|     59|fn cmp_helper<T: AddressSpace>(left: &Ptr<T>, right: &Ptr<T>) -> std::cmp::Ordering {
  136|       |    // We know both left and right have the same address space, thus
  137|       |    // they have the same base, so we can get away with just comparing
  138|       |    // the offsets and assume we're in the same address space, practically
  139|       |    // speaking.
  140|     59|    left.offset.cmp(&right.offset)
  141|     59|}
  142|       |
  143|       |#[allow(clippy::non_canonical_partial_ord_impl)]
  144|       |impl<T: AddressSpace> std::cmp::PartialOrd for Ptr<T> {
  145|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  146|     59|    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
  147|     59|        Some(cmp_helper(self, other))
  148|     59|    }
  149|       |}
  150|       |
  151|       |impl<T: AddressSpace> std::cmp::Ord for Ptr<T> {
  152|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  153|      0|    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
  154|      0|        cmp_helper(self, other)
  155|      0|    }
  156|       |}
  157|       |
  158|       |impl<T: AddressSpace> Ptr<T> {
  159|       |    /// Create a new pointer in the given `AddressSpace` `addr_space`
  160|       |    /// from the given pointer `raw_ptr`. Returns `Ok` if subtracting
  161|       |    /// the base address from `raw_ptr` succeeds (i.e. does not overflow)
  162|       |    /// and a `Ptr<T>` can be successfully created
  163|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  164|    119|    fn from_raw_ptr(addr_space: T, raw_ptr: RawPtr) -> Result<Ptr<T>> {
  165|       |        let offset = raw_ptr
  166|       |            .0
  167|       |            .checked_sub(addr_space.base())
  168|      0|            .ok_or_else(|| RawPointerLessThanBaseAddress(raw_ptr, addr_space.base()))?;
  169|       |        Ok(Self {
  170|       |            addr_space,
  171|       |            offset: Offset::from(offset),
  172|       |        })
  173|    119|    }
  174|       |
  175|       |    /// Create a new `Ptr` into the given `addr_space` from the given
  176|       |    /// `offset`.
  177|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  178|     59|    fn from_offset(addr_space: T, offset: Offset) -> Ptr<T> {
  179|     59|        Self { addr_space, offset }
  180|     59|    }
  181|       |
  182|       |    /// Get the base address for this pointer
  183|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  184|      1|    fn base(&self) -> u64 {
  185|      1|        self.addr_space.base()
  186|      1|    }
  187|       |
  188|       |    /// Get the offset into the pointer's address space
  189|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  190|      0|    pub(super) fn offset(&self) -> Offset {
  191|      0|        self.offset
  192|      0|    }
  193|       |
  194|       |    /// Get the absolute value for the pointer represented by `self`.
  195|       |    ///
  196|       |    /// This function should rarely be used. Prefer to use offsets
  197|       |    /// instead.
  198|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  199|      1|    pub(crate) fn absolute(&self) -> Result<u64> {
  200|       |        let offset_u64: u64 = self.offset.into();
  201|       |        self.base()
  202|       |            .checked_add(offset_u64)
  203|      0|            .ok_or_else(|| CheckedAddOverflow(self.base(), offset_u64))
  204|      1|    }
  205|       |}
  206|       |
  207|       |impl<T: AddressSpace> Add<Offset> for Ptr<T> {
  208|       |    type Output = Ptr<T>;
  209|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  210|     59|    fn add(self, rhs: Offset) -> Self::Output {
  211|     59|        Self {
  212|     59|            addr_space: self.addr_space,
  213|     59|            offset: self.offset + rhs,
  214|     59|        }
  215|     59|    }
  216|       |}
  217|       |
  218|       |impl<T: AddressSpace> TryFrom<Ptr<T>> for usize {
  219|       |    type Error = HyperlightError;
  220|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  221|      0|    fn try_from(val: Ptr<T>) -> Result<usize> {
  222|       |        let abs = val.absolute()?;
  223|       |        Ok(usize::try_from(abs)?)
  224|      0|    }
  225|       |}
  226|       |
  227|       |#[cfg(test)]
  228|       |mod tests {
  229|       |    use super::{GuestPtr, RawPtr};
  230|       |    use crate::mem::layout::SandboxMemoryLayout;
  231|       |    const OFFSET: u64 = 1;
  232|       |
  233|       |    #[test]
  234|      1|    fn ptr_basic_ops() {
  235|      1|        {
  236|      1|            let raw_guest_ptr = RawPtr(OFFSET + SandboxMemoryLayout::BASE_ADDRESS as u64);
  237|      1|            let guest_ptr = GuestPtr::try_from(raw_guest_ptr).unwrap();
  238|      1|            assert_eq!(
  239|      1|                OFFSET + SandboxMemoryLayout::BASE_ADDRESS as u64,
  240|      1|                guest_ptr.absolute().unwrap()
  241|      1|            );
  242|       |        }
  243|      1|    }
  244|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/ptr_addr_space.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use tracing::{Span, instrument};
   18|       |
   19|       |use super::layout::SandboxMemoryLayout;
   20|       |use crate::Result;
   21|       |
   22|       |/// A representation of a specific address space
   23|       |pub trait AddressSpace: std::cmp::Eq {
   24|       |    /// The base address for this address space
   25|       |    fn base(&self) -> u64;
   26|       |}
   27|       |
   28|       |/// The address space for the guest executable
   29|       |#[derive(Debug, Clone, Copy, Eq, PartialEq)]
   30|       |pub(crate) struct GuestAddressSpace(u64);
   31|       |impl GuestAddressSpace {
   32|       |    /// Create a new instance of a `GuestAddressSpace`
   33|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   34|    179|    pub(super) fn new() -> Result<Self> {
   35|       |        let base_addr = u64::try_from(SandboxMemoryLayout::BASE_ADDRESS)?;
   36|       |        Ok(Self(base_addr))
   37|    179|    }
   38|       |}
   39|       |impl AddressSpace for GuestAddressSpace {
   40|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   41|    121|    fn base(&self) -> u64 {
   42|    121|        self.0
   43|    121|    }
   44|       |}
   45|       |
   46|       |#[cfg(test)]
   47|       |mod tests {
   48|       |    use super::{AddressSpace, GuestAddressSpace};
   49|       |    use crate::mem::layout::SandboxMemoryLayout;
   50|       |
   51|       |    #[test]
   52|      1|    fn guest_addr_space_base() {
   53|      1|        let space = GuestAddressSpace::new().unwrap();
   54|      1|        assert_eq!(SandboxMemoryLayout::BASE_ADDRESS as u64, space.base());
   55|      1|    }
   56|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/ptr_offset.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};
   18|       |use std::convert::From;
   19|       |use std::ops::{Add, Sub};
   20|       |
   21|       |use tracing::{Span, instrument};
   22|       |
   23|       |use crate::Result;
   24|       |use crate::error::HyperlightError;
   25|       |
   26|       |/// An offset into a given address space.
   27|       |///
   28|       |/// Use this type to distinguish between an offset and a raw pointer
   29|       |#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
   30|       |pub(crate) struct Offset(u64);
   31|       |
   32|       |impl Offset {
   33|       |    /// Get the offset representing `0`
   34|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   35|       |    #[allow(dead_code)]
   36|      0|    pub(super) fn zero() -> Self {
   37|      0|        Self::default()
   38|      0|    }
   39|       |
   40|       |    /// round up to the nearest multiple of `alignment`
   41|       |    #[allow(dead_code)]
   42|      5|    pub(super) fn round_up_to(self, alignment: u64) -> Self {
   43|      5|        let remainder = self.0 % alignment;
   44|      5|        let multiples = self.0 / alignment;
   45|      5|        match remainder {
   46|      2|            0 => self,
   47|      3|            _ => Offset::from((multiples + 1) * alignment),
   48|       |        }
   49|      5|    }
   50|       |}
   51|       |
   52|       |impl Default for Offset {
   53|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   54|    256|    fn default() -> Self {
   55|    256|        Offset::from(0_u64)
   56|    256|    }
   57|       |}
   58|       |
   59|       |impl From<u64> for Offset {
   60|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   61|  1.01k|    fn from(val: u64) -> Self {
   62|  1.01k|        Self(val)
   63|  1.01k|    }
   64|       |}
   65|       |
   66|       |impl From<&Offset> for u64 {
   67|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   68|      0|    fn from(val: &Offset) -> u64 {
   69|      0|        val.0
   70|      0|    }
   71|       |}
   72|       |
   73|       |impl From<Offset> for u64 {
   74|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   75|    316|    fn from(val: Offset) -> u64 {
   76|    316|        val.0
   77|    316|    }
   78|       |}
   79|       |
   80|       |impl TryFrom<Offset> for i64 {
   81|       |    type Error = HyperlightError;
   82|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   83|    132|    fn try_from(val: Offset) -> Result<i64> {
   84|       |        Ok(i64::try_from(val.0)?)
   85|    132|    }
   86|       |}
   87|       |
   88|       |impl TryFrom<i64> for Offset {
   89|       |    type Error = HyperlightError;
   90|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   91|    256|    fn try_from(val: i64) -> Result<Offset> {
   92|       |        let val_u64 = u64::try_from(val)?;
   93|       |        Ok(Offset::from(val_u64))
   94|    256|    }
   95|       |}
   96|       |
   97|       |impl TryFrom<usize> for Offset {
   98|       |    type Error = HyperlightError;
   99|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  100|    256|    fn try_from(val: usize) -> Result<Offset> {
  101|       |        Ok(u64::try_from(val).map(Offset::from)?)
  102|    256|    }
  103|       |}
  104|       |
  105|       |/// Convert an `Offset` to a `usize`, returning an `Err` if the
  106|       |/// conversion couldn't be made.
  107|       |impl TryFrom<&Offset> for usize {
  108|       |    type Error = HyperlightError;
  109|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  110|    512|    fn try_from(val: &Offset) -> Result<usize> {
  111|       |        Ok(usize::try_from(val.0)?)
  112|    512|    }
  113|       |}
  114|       |
  115|       |impl TryFrom<Offset> for usize {
  116|       |    type Error = HyperlightError;
  117|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  118|    512|    fn try_from(val: Offset) -> Result<usize> {
  119|       |        usize::try_from(&val)
  120|    512|    }
  121|       |}
  122|       |
  123|       |impl Add<Offset> for Offset {
  124|       |    type Output = Offset;
  125|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  126|     59|    fn add(self, rhs: Offset) -> Offset {
  127|     59|        Offset::from(self.0 + rhs.0)
  128|     59|    }
  129|       |}
  130|       |
  131|       |impl Add<usize> for Offset {
  132|       |    type Output = Offset;
  133|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  134|    256|    fn add(self, rhs: usize) -> Offset {
  135|    256|        Offset(self.0 + rhs as u64)
  136|    256|    }
  137|       |}
  138|       |
  139|       |impl Add<Offset> for usize {
  140|       |    type Output = Offset;
  141|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  142|      0|    fn add(self, rhs: Offset) -> Offset {
  143|      0|        rhs.add(self)
  144|      0|    }
  145|       |}
  146|       |
  147|       |impl Add<u64> for Offset {
  148|       |    type Output = Offset;
  149|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  150|    256|    fn add(self, rhs: u64) -> Offset {
  151|    256|        Offset(self.0 + rhs)
  152|    256|    }
  153|       |}
  154|       |
  155|       |impl Add<Offset> for u64 {
  156|       |    type Output = Offset;
  157|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  158|      0|    fn add(self, rhs: Offset) -> Offset {
  159|      0|        rhs.add(self)
  160|      0|    }
  161|       |}
  162|       |
  163|       |impl Sub<Offset> for Offset {
  164|       |    type Output = Offset;
  165|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  166|      0|    fn sub(self, rhs: Offset) -> Offset {
  167|      0|        Offset::from(self.0 - rhs.0)
  168|      0|    }
  169|       |}
  170|       |
  171|       |impl Sub<usize> for Offset {
  172|       |    type Output = Offset;
  173|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  174|      0|    fn sub(self, rhs: usize) -> Offset {
  175|      0|        Offset(self.0 - rhs as u64)
  176|      0|    }
  177|       |}
  178|       |
  179|       |impl Sub<Offset> for usize {
  180|       |    type Output = Offset;
  181|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  182|      0|    fn sub(self, rhs: Offset) -> Offset {
  183|      0|        rhs.sub(self)
  184|      0|    }
  185|       |}
  186|       |
  187|       |impl Sub<u64> for Offset {
  188|       |    type Output = Offset;
  189|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  190|      0|    fn sub(self, rhs: u64) -> Offset {
  191|      0|        Offset(self.0 - rhs)
  192|      0|    }
  193|       |}
  194|       |
  195|       |impl Sub<Offset> for u64 {
  196|       |    type Output = Offset;
  197|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  198|      0|    fn sub(self, rhs: Offset) -> Offset {
  199|      0|        rhs.sub(self)
  200|      0|    }
  201|       |}
  202|       |
  203|       |impl PartialEq<usize> for Offset {
  204|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  205|      0|    fn eq(&self, other: &usize) -> bool {
  206|      0|        match usize::try_from(self) {
  207|      0|            Ok(offset_usize) => offset_usize == *other,
  208|      0|            _ => false,
  209|       |        }
  210|      0|    }
  211|       |}
  212|       |
  213|       |impl PartialOrd<usize> for Offset {
  214|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  215|      0|    fn partial_cmp(&self, rhs: &usize) -> Option<Ordering> {
  216|      0|        match usize::try_from(self) {
  217|      0|            Ok(offset_usize) if offset_usize > *rhs => Some(Ordering::Greater),
  218|      0|            Ok(offset_usize) if offset_usize == *rhs => Some(Ordering::Equal),
  219|      0|            Ok(_) => Some(Ordering::Less),
  220|      0|            Err(_) => None,
  221|       |        }
  222|      0|    }
  223|       |}
  224|       |
  225|       |impl PartialEq<u64> for Offset {
  226|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  227|      0|    fn eq(&self, rhs: &u64) -> bool {
  228|      0|        u64::from(self) == *rhs
  229|      0|    }
  230|       |}
  231|       |
  232|       |impl PartialOrd<u64> for Offset {
  233|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  234|      0|    fn partial_cmp(&self, rhs: &u64) -> Option<Ordering> {
  235|      0|        let lhs: u64 = self.into();
  236|      0|        match lhs > *rhs {
  237|      0|            true => Some(Ordering::Greater),
  238|      0|            false if lhs == *rhs => Some(Ordering::Equal),
  239|      0|            false => Some(Ordering::Less),
  240|       |        }
  241|      0|    }
  242|       |}
  243|       |
  244|       |#[cfg(test)]
  245|       |mod tests {
  246|       |    use proptest::prelude::*;
  247|       |
  248|       |    use super::Offset;
  249|       |
  250|       |    proptest! {
  251|       |        #[test]
  252|       |        fn i64_roundtrip(i64_val in (i64::MIN..i64::MAX)) {
  253|       |            let offset_res = Offset::try_from(i64_val);
  254|       |
  255|       |            if i64_val < 0 {
  256|       |                assert!(offset_res.is_err());
  257|       |            } else {
  258|       |                assert!(offset_res.is_ok());
  259|       |                let offset = offset_res.unwrap();
  260|       |                let ret_i64_val = {
  261|       |                    let res = i64::try_from(offset);
  262|       |                    assert!(res.is_ok());
  263|       |                    res.unwrap()
  264|       |                };
  265|       |                assert_eq!(i64_val, ret_i64_val);
  266|       |            }
  267|       |        }
  268|       |        #[test]
  269|       |        fn usize_roundtrip(val in (usize::MIN..usize::MAX)) {
  270|       |            let offset = Offset::try_from(val).unwrap();
  271|       |            assert_eq!(val, usize::try_from(offset).unwrap());
  272|       |        }
  273|       |
  274|       |        #[test]
  275|       |        fn add_numeric_types(usize_val in (usize::MIN..usize::MAX), u64_val in (u64::MIN..u64::MAX)) {
  276|       |            let start = Offset::default();
  277|       |            {
  278|       |                // add usize to offset
  279|       |                assert_eq!(usize_val, usize::try_from(start + usize_val).unwrap());
  280|       |            }
  281|       |            {
  282|       |                // add u64 to offset
  283|       |                assert_eq!(u64_val, u64::from(start + u64_val));
  284|       |            }
  285|       |        }
  286|       |    }
  287|       |
  288|       |    #[test]
  289|      1|    fn round_up_to() {
  290|      1|        let offset = Offset::from(0);
  291|      1|        let rounded = offset.round_up_to(4);
  292|      1|        assert_eq!(rounded, offset);
  293|       |
  294|      1|        let offset = Offset::from(1);
  295|      1|        let rounded = offset.round_up_to(4);
  296|      1|        assert_eq!(rounded, Offset::from(4));
  297|       |
  298|      1|        let offset = Offset::from(3);
  299|      1|        let rounded = offset.round_up_to(4);
  300|      1|        assert_eq!(rounded, Offset::from(4));
  301|       |
  302|      1|        let offset = Offset::from(4);
  303|      1|        let rounded = offset.round_up_to(4);
  304|      1|        assert_eq!(rounded, Offset::from(4));
  305|       |
  306|      1|        let offset = Offset::from(5);
  307|      1|        let rounded = offset.round_up_to(4);
  308|      1|        assert_eq!(rounded, Offset::from(8));
  309|      1|    }
  310|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/shared_mem.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::any::type_name;
   18|       |use std::ffi::c_void;
   19|       |use std::io::Error;
   20|       |#[cfg(target_os = "linux")]
   21|       |use std::ptr::null_mut;
   22|       |use std::sync::{Arc, RwLock};
   23|       |
   24|       |use hyperlight_common::mem::PAGE_SIZE_USIZE;
   25|       |use tracing::{Span, instrument};
   26|       |#[cfg(target_os = "windows")]
   27|       |use windows::Win32::Foundation::{CloseHandle, HANDLE, INVALID_HANDLE_VALUE};
   28|       |#[cfg(target_os = "windows")]
   29|       |use windows::Win32::System::Memory::PAGE_READWRITE;
   30|       |#[cfg(target_os = "windows")]
   31|       |use windows::Win32::System::Memory::{
   32|       |    CreateFileMappingA, FILE_MAP_ALL_ACCESS, MEMORY_MAPPED_VIEW_ADDRESS, MapViewOfFile,
   33|       |    PAGE_EXECUTE_READWRITE, PAGE_NOACCESS, PAGE_PROTECTION_FLAGS, UnmapViewOfFile, VirtualProtect,
   34|       |};
   35|       |#[cfg(target_os = "windows")]
   36|       |use windows::core::PCSTR;
   37|       |
   38|       |#[cfg(target_os = "windows")]
   39|       |use crate::HyperlightError::MemoryAllocationFailed;
   40|       |#[cfg(target_os = "windows")]
   41|       |use crate::HyperlightError::{MemoryRequestTooBig, WindowsAPIError};
   42|       |use crate::{Result, log_then_return, new_error};
   43|       |
   44|       |/// Makes sure that the given `offset` and `size` are within the bounds of the memory with size `mem_size`.
   45|       |macro_rules! bounds_check {
   46|       |    ($offset:expr, $size:expr, $mem_size:expr) => {
   47|       |        if $offset + $size > $mem_size {
   48|       |            return Err(new_error!(
   49|       |                "Cannot read value from offset {} with size {} in memory of size {}",
   50|       |                $offset,
   51|       |                $size,
   52|       |                $mem_size
   53|       |            ));
   54|       |        }
   55|       |    };
   56|       |}
   57|       |
   58|       |/// generates a reader function for the given type
   59|       |macro_rules! generate_reader {
   60|       |    ($fname:ident, $ty:ty) => {
   61|       |        /// Read a value of type `$ty` from the memory at the given offset.
   62|       |        #[allow(dead_code)]
   63|       |        #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   64|  1.09k|        pub(crate) fn $fname(&self, offset: usize) -> Result<$ty> {
   65|       |            let data = self.as_slice();
   66|       |            bounds_check!(offset, std::mem::size_of::<$ty>(), data.len());
   67|       |            Ok(<$ty>::from_le_bytes(
   68|       |                data[offset..offset + std::mem::size_of::<$ty>()].try_into()?,
   69|       |            ))
   70|  1.09k|        }
   71|       |    };
   72|       |}
   73|       |
   74|       |/// generates a writer function for the given type
   75|       |macro_rules! generate_writer {
   76|       |    ($fname:ident, $ty:ty) => {
   77|       |        /// Write a value of type `$ty` to the memory at the given offset.
   78|       |        #[allow(dead_code)]
   79|  32.8k|        pub(crate) fn $fname(&mut self, offset: usize, value: $ty) -> Result<()> {
   80|  32.8k|            let data = self.as_mut_slice();
   81|  32.8k|            bounds_check!(offset, std::mem::size_of::<$ty>(), data.len());
                                                                            ^768
   82|  32.0k|            data[offset..offset + std::mem::size_of::<$ty>()].copy_from_slice(&value.to_le_bytes());
   83|  32.0k|            Ok(())
   84|  32.8k|        }
   85|       |    };
   86|       |}
   87|       |
   88|       |/// A representation of a host mapping of a shared memory region,
   89|       |/// which will be released when this structure is Drop'd. This is not
   90|       |/// individually Clone (since it holds ownership of the mapping), or
   91|       |/// Send or Sync, since it doesn't ensure any particular synchronization.
   92|       |#[derive(Debug)]
   93|       |pub struct HostMapping {
   94|       |    ptr: *mut u8,
   95|       |    size: usize,
   96|       |    #[cfg(target_os = "windows")]
   97|       |    handle: HANDLE,
   98|       |}
   99|       |
  100|       |impl Drop for HostMapping {
  101|       |    #[cfg(target_os = "linux")]
  102|  3.65k|    fn drop(&mut self) {
  103|       |        use libc::munmap;
  104|       |
  105|  3.65k|        unsafe {
  106|  3.65k|            munmap(self.ptr as *mut c_void, self.size);
  107|  3.65k|        }
  108|  3.65k|    }
  109|       |    #[cfg(target_os = "windows")]
  110|       |    fn drop(&mut self) {
  111|       |        let mem_mapped_address = MEMORY_MAPPED_VIEW_ADDRESS {
  112|       |            Value: self.ptr as *mut c_void,
  113|       |        };
  114|       |        if let Err(e) = unsafe { UnmapViewOfFile(mem_mapped_address) } {
  115|       |            tracing::error!(
  116|       |                "Failed to drop HostMapping (UnmapViewOfFile failed): {:?}",
  117|       |                e
  118|       |            );
  119|       |        }
  120|       |
  121|       |        let file_handle: HANDLE = self.handle;
  122|       |        if let Err(e) = unsafe { CloseHandle(file_handle) } {
  123|       |            tracing::error!("Failed to  drop HostMapping (CloseHandle failed): {:?}", e);
  124|       |        }
  125|       |    }
  126|       |}
  127|       |
  128|       |/// These three structures represent various phases of the lifecycle of
  129|       |/// a memory buffer that is shared with the guest. An
  130|       |/// ExclusiveSharedMemory is used for certain operations that
  131|       |/// unrestrictedly write to the shared memory, including setting it up
  132|       |/// and taking snapshots.
  133|       |#[derive(Debug)]
  134|       |pub struct ExclusiveSharedMemory {
  135|       |    region: Arc<HostMapping>,
  136|       |}
  137|       |unsafe impl Send for ExclusiveSharedMemory {}
  138|       |
  139|       |/// A GuestSharedMemory is used to represent
  140|       |/// the reference to all-of-memory that is taken by the virtual cpu.
  141|       |/// Because of the memory model limitations that affect
  142|       |/// HostSharedMemory, it is likely fairly important (to ensure that
  143|       |/// our UB remains limited to interaction with an external compilation
  144|       |/// unit that likely can't be discovered by the compiler) that _rust_
  145|       |/// users do not perform racy accesses to the guest communication
  146|       |/// buffers that are also accessed by HostSharedMemory.
  147|       |#[derive(Debug)]
  148|       |pub struct GuestSharedMemory {
  149|       |    region: Arc<HostMapping>,
  150|       |    /// The lock that indicates this shared memory is being used by non-Rust code
  151|       |    ///
  152|       |    /// This lock _must_ be held whenever the guest is executing,
  153|       |    /// because it prevents the host from converting its
  154|       |    /// HostSharedMemory to an ExclusiveSharedMemory. Since the guest
  155|       |    /// may arbitrarily mutate the shared memory, only synchronized
  156|       |    /// accesses from Rust should be allowed!
  157|       |    ///
  158|       |    /// We cannot enforce this in the type system, because the memory
  159|       |    /// is mapped in to the VM at VM creation time.
  160|       |    pub lock: Arc<RwLock<()>>,
  161|       |}
  162|       |unsafe impl Send for GuestSharedMemory {}
  163|       |
  164|       |/// A HostSharedMemory allows synchronized accesses to guest
  165|       |/// communication buffers, allowing it to be used concurrently with a
  166|       |/// GuestSharedMemory.
  167|       |///
  168|       |/// Given future requirements for asynchronous I/O with a minimum
  169|       |/// amount of copying (e.g. WASIp3 streams), we would like it to be
  170|       |/// possible to safely access these buffers concurrently with the
  171|       |/// guest, ensuring that (1) data is read appropriately if the guest
  172|       |/// is well-behaved; and (2) the host's behaviour is defined
  173|       |/// regardless of whether or not the guest is well-behaved.
  174|       |///
  175|       |/// The ideal (future) flow for a guest->host message is something like
  176|       |///   - Guest writes (unordered) bytes describing a work item into a buffer
  177|       |///   - Guest reveals buffer via a release-store of a pointer into an
  178|       |///     MMIO ring-buffer
  179|       |///   - Host acquire-loads the buffer pointer from the "MMIO" ring
  180|       |///     buffer
  181|       |///   - Host (unordered) reads the bytes from the buffer
  182|       |///   - Host performs validation of those bytes and uses them
  183|       |///
  184|       |/// Unfortunately, there appears to be no way to do this with defined
  185|       |/// behaviour in present Rust (see
  186|       |/// e.g. <https://github.com/rust-lang/unsafe-code-guidelines/issues/152>).
  187|       |/// Rust does not yet have its own defined memory model, but in the
  188|       |/// interim, it is widely treated as inheriting the current C/C++
  189|       |/// memory models.  The most immediate problem is that regardless of
  190|       |/// anything else, under those memory models \[1, p. 17-18; 2, p. 88\],
  191|       |///
  192|       |///   > The execution of a program contains a _data race_ if it
  193|       |///   > contains two [C++23: "potentially concurrent"] conflicting
  194|       |///   > actions [C23: "in different threads"], at least one of which
  195|       |///   > is not atomic, and neither happens before the other [C++23: ",
  196|       |///   > except for the special case for signal handlers described
  197|       |///   > below"].  Any such data race results in undefined behavior.
  198|       |///
  199|       |/// Consequently, if a misbehaving guest fails to correctly
  200|       |/// synchronize its stores with the host, the host's innocent loads
  201|       |/// will trigger undefined behaviour for the entire program, including
  202|       |/// the host.  Note that this also applies if the guest makes an
  203|       |/// unsynchronized read of a location that the host is writing!
  204|       |///
  205|       |/// Despite Rust's de jure inheritance of the C memory model at the
  206|       |/// present time, the compiler in many cases de facto adheres to LLVM
  207|       |/// semantics, so it is worthwhile to consider what LLVM does in this
  208|       |/// case as well.  According to the the LangRef \[3\] memory model,
  209|       |/// loads which are involved in a race that includes at least one
  210|       |/// non-atomic access (whether the load or a store) return `undef`,
  211|       |/// making them roughly equivalent to reading uninitialized
  212|       |/// memory. While this is much better, it is still bad.
  213|       |///
  214|       |/// Considering a different direction, recent C++ papers have seemed
  215|       |/// to lean towards using `volatile` for similar use cases. For
  216|       |/// example, in P1152R0 \[4\], JF Bastien notes that
  217|       |///
  218|       |///   > Weve shown that volatile is purposely defined to denote
  219|       |///   > external modifications. This happens for:
  220|       |///   >   - Shared memory with untrusted code, where volatile is the
  221|       |///   >     right way to avoid time-of-check time-of-use (ToCToU)
  222|       |///   >     races which lead to security bugs such as \[PWN2OWN\] and
  223|       |///   >     \[XENXSA155\].
  224|       |///
  225|       |/// Unfortunately, although this paper was adopted for C++20 (and,
  226|       |/// sadly, mostly un-adopted for C++23, although that does not concern
  227|       |/// us), the paper did not actually redefine volatile accesses or data
  228|       |/// races to prevent volatile accesses from racing with other accesses
  229|       |/// and causing undefined behaviour.  P1382R1 \[5\] would have amended
  230|       |/// the wording of the data race definition to specifically exclude
  231|       |/// volatile, but, unfortunately, despite receiving a
  232|       |/// generally-positive reception at its first WG21 meeting more than
  233|       |/// five years ago, it has not progressed.
  234|       |///
  235|       |/// Separately from the data race issue, there is also a concern that
  236|       |/// according to the various memory models in use, there may be ways
  237|       |/// in which the guest can semantically obtain uninitialized memory
  238|       |/// and write it into the shared buffer, which may also result in
  239|       |/// undefined behaviour on reads.  The degree to which this is a
  240|       |/// concern is unclear, however, since it is unclear to what degree
  241|       |/// the Rust abstract machine's conception of uninitialized memory
  242|       |/// applies to the sandbox.  Returning briefly to the LLVM level,
  243|       |/// rather than the Rust level, this, combined with the fact that
  244|       |/// racing loads in LLVM return `undef`, as discussed above, we would
  245|       |/// ideally `llvm.freeze` the result of any load out of the sandbox.
  246|       |///
  247|       |/// It would furthermore be ideal if we could run the flatbuffers
  248|       |/// parsing code directly on the guest memory, in order to avoid
  249|       |/// unnecessary copies.  That is unfortunately probably not viable at
  250|       |/// the present time: because the generated flatbuffers parsing code
  251|       |/// doesn't use atomic or volatile accesses, it is likely to introduce
  252|       |/// double-read vulnerabilities.
  253|       |///
  254|       |/// In short, none of the Rust-level operations available to us do the
  255|       |/// right thing, at the Rust spec level or the LLVM spec level. Our
  256|       |/// major remaining options are therefore:
  257|       |///   - Choose one of the options that is available to us, and accept
  258|       |///     that we are doing something unsound according to the spec, but
  259|       |///     hope that no reasonable compiler could possibly notice.
  260|       |///   - Use inline assembly per architecture, for which we would only
  261|       |///     need to worry about the _architecture_'s memory model (which
  262|       |///     is far less demanding).
  263|       |///
  264|       |/// The leading candidate for the first option would seem to be to
  265|       |/// simply use volatile accesses; there seems to be wide agreement
  266|       |/// that this _should_ be a valid use case for them (even if it isn't
  267|       |/// now), and projects like Linux and rust-vmm already use C11
  268|       |/// `volatile` for this purpose.  It is also worth noting that because
  269|       |/// we still do need to synchronize with the guest when it _is_ being
  270|       |/// well-behaved, we would ideally use volatile acquire loads and
  271|       |/// volatile release stores for interacting with the stack pointer in
  272|       |/// the guest in this case.  Unfortunately, while those operations are
  273|       |/// defined in LLVM, they are not presently exposed to Rust. While
  274|       |/// atomic fences that are not associated with memory accesses
  275|       |/// ([`std::sync::atomic::fence`]) might at first glance seem to help with
  276|       |/// this problem, they unfortunately do not \[6\]:
  277|       |///
  278|       |///    > A fence A which has (at least) Release ordering semantics,
  279|       |///    > synchronizes with a fence B with (at least) Acquire
  280|       |///    > semantics, if and only if there exist operations X and Y,
  281|       |///    > both operating on some atomic object M such that A is
  282|       |///    > sequenced before X, Y is sequenced before B and Y observes
  283|       |///    > the change to M. This provides a happens-before dependence
  284|       |///    > between A and B.
  285|       |///
  286|       |/// Note that the X and Y must be to an _atomic_ object.
  287|       |///
  288|       |/// We consequently assume that there has been a strong architectural
  289|       |/// fence on a vmenter/vmexit between data being read and written.
  290|       |/// This is unsafe (not guaranteed in the type system)!
  291|       |///
  292|       |/// \[1\] N3047 C23 Working Draft. <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3047.pdf>
  293|       |/// \[2\] N4950 C++23 Working Draft. <https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4950.pdf>
  294|       |/// \[3\] LLVM Language Reference Manual, Memory Model for Concurrent Operations. <https://llvm.org/docs/LangRef.html#memmodel>
  295|       |/// \[4\] P1152R0: Deprecating `volatile`. JF Bastien. <https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1152r0.html>
  296|       |/// \[5\] P1382R1: `volatile_load<T>` and `volatile_store<T>`. JF Bastien, Paul McKenney, Jeffrey Yasskin, and the indefatigable TBD. <https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1382r1.pdf>
  297|       |/// \[6\] Documentation for std::sync::atomic::fence. <https://doc.rust-lang.org/std/sync/atomic/fn.fence.html>
  298|       |#[derive(Clone, Debug)]
  299|       |pub struct HostSharedMemory {
  300|       |    region: Arc<HostMapping>,
  301|       |    lock: Arc<RwLock<()>>,
  302|       |}
  303|       |unsafe impl Send for HostSharedMemory {}
  304|       |
  305|       |impl ExclusiveSharedMemory {
  306|       |    /// Create a new region of shared memory with the given minimum
  307|       |    /// size in bytes. The region will be surrounded by guard pages.
  308|       |    ///
  309|       |    /// Return `Err` if shared memory could not be allocated.
  310|       |    #[cfg(target_os = "linux")]
  311|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  312|  3.65k|    pub fn new(min_size_bytes: usize) -> Result<Self> {
  313|       |        use libc::{
  314|       |            MAP_ANONYMOUS, MAP_FAILED, MAP_NORESERVE, MAP_SHARED, PROT_NONE, PROT_READ, PROT_WRITE,
  315|       |            c_int, mmap, mprotect, off_t, size_t,
  316|       |        };
  317|       |
  318|       |        use crate::error::HyperlightError::{MemoryRequestTooBig, MmapFailed, MprotectFailed};
  319|       |
  320|  3.65k|        if min_size_bytes == 0 {
  321|      1|            return Err(new_error!("Cannot create shared memory with size 0"));
                                                ^0
  322|  3.65k|        }
  323|       |
  324|  3.65k|        let total_size = min_size_bytes
                          ^3.65k
  325|  3.65k|            .checked_add(2 * PAGE_SIZE_USIZE) // guard page around the memory
  326|  3.65k|            .ok_or_else(|| new_error!("Memory required for sandbox exceeded usize::MAX"))?;
                                                    ^0                                                 ^1
  327|       |
  328|  3.65k|        if total_size % PAGE_SIZE_USIZE != 0 {
  329|      0|            return Err(new_error!(
  330|      0|                "shared memory must be a multiple of {}",
  331|      0|                PAGE_SIZE_USIZE
  332|      0|            ));
  333|  3.65k|        }
  334|  3.65k|
  335|  3.65k|        // usize and isize are guaranteed to be the same size, and
  336|  3.65k|        // isize::MAX should be positive, so this cast should be safe.
  337|  3.65k|        if total_size > isize::MAX as usize {
  338|      0|            return Err(MemoryRequestTooBig(total_size, isize::MAX as usize));
  339|  3.65k|        }
  340|  3.65k|
  341|  3.65k|        // allocate the memory
  342|  3.65k|        let addr = unsafe {
  343|  3.65k|            mmap(
  344|  3.65k|                null_mut(),
  345|  3.65k|                total_size as size_t,
  346|  3.65k|                PROT_READ | PROT_WRITE,
  347|  3.65k|                MAP_ANONYMOUS | MAP_SHARED | MAP_NORESERVE,
  348|  3.65k|                -1 as c_int,
  349|  3.65k|                0 as off_t,
  350|  3.65k|            )
  351|  3.65k|        };
  352|  3.65k|        if addr == MAP_FAILED {
  353|      0|            log_then_return!(MmapFailed(Error::last_os_error().raw_os_error()));
  354|  3.65k|        }
  355|  3.65k|
  356|  3.65k|        // protect the guard pages
  357|  3.65k|
  358|  3.65k|        let res = unsafe { mprotect(addr, PAGE_SIZE_USIZE, PROT_NONE) };
  359|  3.65k|        if res != 0 {
  360|      0|            return Err(MprotectFailed(Error::last_os_error().raw_os_error()));
  361|  3.65k|        }
  362|  3.65k|        let res = unsafe {
  363|  3.65k|            mprotect(
  364|  3.65k|                (addr as *const u8).add(total_size - PAGE_SIZE_USIZE) as *mut c_void,
  365|  3.65k|                PAGE_SIZE_USIZE,
  366|  3.65k|                PROT_NONE,
  367|  3.65k|            )
  368|  3.65k|        };
  369|  3.65k|        if res != 0 {
  370|      0|            return Err(MprotectFailed(Error::last_os_error().raw_os_error()));
  371|  3.65k|        }
  372|  3.65k|
  373|  3.65k|        Ok(Self {
  374|  3.65k|            // HostMapping is only non-Send/Sync because raw pointers
  375|  3.65k|            // are not ("as a lint", as the Rust docs say). We don't
  376|  3.65k|            // want to mark HostMapping Send/Sync immediately, because
  377|  3.65k|            // that could socially imply that it's "safe" to use
  378|  3.65k|            // unsafe accesses from multiple threads at once. Instead, we
  379|  3.65k|            // directly impl Send and Sync on this type. Since this
  380|  3.65k|            // type does have Send and Sync manually impl'd, the Arc
  381|  3.65k|            // is not pointless as the lint suggests.
  382|  3.65k|            #[allow(clippy::arc_with_non_send_sync)]
  383|  3.65k|            region: Arc::new(HostMapping {
  384|  3.65k|                ptr: addr as *mut u8,
  385|  3.65k|                size: total_size,
  386|  3.65k|            }),
  387|  3.65k|        })
  388|  3.65k|    }
  389|       |
  390|       |    /// Create a new region of shared memory with the given minimum
  391|       |    /// size in bytes. The region will be surrounded by guard pages.
  392|       |    ///
  393|       |    /// Return `Err` if shared memory could not be allocated.
  394|       |    #[cfg(target_os = "windows")]
  395|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  396|       |    pub fn new(min_size_bytes: usize) -> Result<Self> {
  397|       |        if min_size_bytes == 0 {
  398|       |            return Err(new_error!("Cannot create shared memory with size 0"));
  399|       |        }
  400|       |
  401|       |        let total_size = min_size_bytes
  402|       |            .checked_add(2 * PAGE_SIZE_USIZE)
  403|       |            .ok_or_else(|| new_error!("Memory required for sandbox exceeded {}", usize::MAX))?;
  404|       |
  405|       |        if total_size % PAGE_SIZE_USIZE != 0 {
  406|       |            return Err(new_error!(
  407|       |                "shared memory must be a multiple of {}",
  408|       |                PAGE_SIZE_USIZE
  409|       |            ));
  410|       |        }
  411|       |
  412|       |        // usize and isize are guaranteed to be the same size, and
  413|       |        // isize::MAX should be positive, so this cast should be safe.
  414|       |        if total_size > isize::MAX as usize {
  415|       |            return Err(MemoryRequestTooBig(total_size, isize::MAX as usize));
  416|       |        }
  417|       |
  418|       |        let mut dwmaximumsizehigh = 0;
  419|       |        let mut dwmaximumsizelow = 0;
  420|       |
  421|       |        if std::mem::size_of::<usize>() == 8 {
  422|       |            dwmaximumsizehigh = (total_size >> 32) as u32;
  423|       |            dwmaximumsizelow = (total_size & 0xFFFFFFFF) as u32;
  424|       |        }
  425|       |
  426|       |        // Allocate the memory use CreateFileMapping instead of VirtualAlloc
  427|       |        // This allows us to map the memory into the surrogate process using MapViewOfFile2
  428|       |
  429|       |        let flags = PAGE_READWRITE;
  430|       |
  431|       |        let handle = unsafe {
  432|       |            CreateFileMappingA(
  433|       |                INVALID_HANDLE_VALUE,
  434|       |                None,
  435|       |                flags,
  436|       |                dwmaximumsizehigh,
  437|       |                dwmaximumsizelow,
  438|       |                PCSTR::null(),
  439|       |            )?
  440|       |        };
  441|       |
  442|       |        if handle.is_invalid() {
  443|       |            log_then_return!(MemoryAllocationFailed(
  444|       |                Error::last_os_error().raw_os_error()
  445|       |            ));
  446|       |        }
  447|       |
  448|       |        let file_map = FILE_MAP_ALL_ACCESS;
  449|       |        let addr = unsafe { MapViewOfFile(handle, file_map, 0, 0, 0) };
  450|       |
  451|       |        if addr.Value.is_null() {
  452|       |            log_then_return!(MemoryAllocationFailed(
  453|       |                Error::last_os_error().raw_os_error()
  454|       |            ));
  455|       |        }
  456|       |
  457|       |        // Set the first and last pages to be guard pages
  458|       |
  459|       |        let mut unused_out_old_prot_flags = PAGE_PROTECTION_FLAGS(0);
  460|       |
  461|       |        // If the following calls to VirtualProtect are changed make sure to update the calls to VirtualProtectEx in surrogate_process_manager.rs
  462|       |
  463|       |        let first_guard_page_start = addr.Value;
  464|       |        if let Err(e) = unsafe {
  465|       |            VirtualProtect(
  466|       |                first_guard_page_start,
  467|       |                PAGE_SIZE_USIZE,
  468|       |                PAGE_NOACCESS,
  469|       |                &mut unused_out_old_prot_flags,
  470|       |            )
  471|       |        } {
  472|       |            log_then_return!(WindowsAPIError(e.clone()));
  473|       |        }
  474|       |
  475|       |        let last_guard_page_start = unsafe { addr.Value.add(total_size - PAGE_SIZE_USIZE) };
  476|       |        if let Err(e) = unsafe {
  477|       |            VirtualProtect(
  478|       |                last_guard_page_start,
  479|       |                PAGE_SIZE_USIZE,
  480|       |                PAGE_NOACCESS,
  481|       |                &mut unused_out_old_prot_flags,
  482|       |            )
  483|       |        } {
  484|       |            log_then_return!(WindowsAPIError(e.clone()));
  485|       |        }
  486|       |
  487|       |        Ok(Self {
  488|       |            // HostMapping is only non-Send/Sync because raw pointers
  489|       |            // are not ("as a lint", as the Rust docs say). We don't
  490|       |            // want to mark HostMapping Send/Sync immediately, because
  491|       |            // that could socially imply that it's "safe" to use
  492|       |            // unsafe accesses from multiple threads at once. Instead, we
  493|       |            // directly impl Send and Sync on this type. Since this
  494|       |            // type does have Send and Sync manually impl'd, the Arc
  495|       |            // is not pointless as the lint suggests.
  496|       |            #[allow(clippy::arc_with_non_send_sync)]
  497|       |            region: Arc::new(HostMapping {
  498|       |                ptr: addr.Value as *mut u8,
  499|       |                size: total_size,
  500|       |                handle,
  501|       |            }),
  502|       |        })
  503|       |    }
  504|       |
  505|       |    #[allow(dead_code)]
  506|      0|    pub(super) fn make_memory_executable(&self) -> Result<()> {
  507|       |        #[cfg(target_os = "windows")]
  508|       |        {
  509|       |            let mut _old_flags = PAGE_PROTECTION_FLAGS::default();
  510|       |            if let Err(e) = unsafe {
  511|       |                VirtualProtect(
  512|       |                    self.region.ptr as *const c_void,
  513|       |                    self.region.size,
  514|       |                    PAGE_EXECUTE_READWRITE,
  515|       |                    &mut _old_flags as *mut PAGE_PROTECTION_FLAGS,
  516|       |                )
  517|       |            } {
  518|       |                log_then_return!(WindowsAPIError(e.clone()));
  519|       |            }
  520|       |        }
  521|       |
  522|       |        // make the memory executable on Linux
  523|       |        #[cfg(target_os = "linux")]
  524|       |        {
  525|       |            use libc::{PROT_EXEC, PROT_READ, PROT_WRITE, mprotect};
  526|       |
  527|      0|            let res = unsafe {
  528|      0|                mprotect(
  529|      0|                    self.region.ptr as *mut c_void,
  530|      0|                    self.region.size,
  531|      0|                    PROT_READ | PROT_WRITE | PROT_EXEC,
  532|      0|                )
  533|      0|            };
  534|      0|
  535|      0|            if res != 0 {
  536|      0|                return Err(new_error!(
  537|      0|                    "Failed to make memory executable: {:#?}",
  538|      0|                    Error::last_os_error().raw_os_error()
  539|      0|                ));
  540|      0|            }
  541|      0|        }
  542|      0|        Ok(())
  543|      0|    }
  544|       |
  545|       |    /// Internal helper method to get the backing memory as a mutable slice.
  546|       |    ///
  547|       |    /// # Safety
  548|       |    /// As per std::slice::from_raw_parts_mut:
  549|       |    /// - self.base_addr() must be valid for both reads and writes for
  550|       |    ///   self.mem_size() * mem::size_of::<u8>() many bytes, and it
  551|       |    ///   must be properly aligned.
  552|       |    ///
  553|       |    ///   The rules on validity are still somewhat unspecified, but we
  554|       |    ///   assume that the result of our calls to mmap/CreateFileMappings may
  555|       |    ///   be considered a single "allocated object". The use of
  556|       |    ///   non-atomic accesses is alright from a Safe Rust standpoint,
  557|       |    ///   because SharedMemoryBuilder is  not Sync.
  558|       |    /// - self.base_addr() must point to self.mem_size() consecutive
  559|       |    ///   properly initialized values of type u8
  560|       |    ///
  561|       |    ///   Again, the exact provenance restrictions on what is
  562|       |    ///   considered to be initialized values are unclear, but we make
  563|       |    ///   sure to use mmap(MAP_ANONYMOUS) and
  564|       |    ///   CreateFileMapping(SEC_COMMIT), so the pages in question are
  565|       |    ///   zero-initialized, which we hope counts for u8.
  566|       |    /// - The memory referenced by the returned slice must not be
  567|       |    ///   accessed through any other pointer (not derived from the
  568|       |    ///   return value) for the duration of the lifetime 'a. Both read
  569|       |    ///   and write accesses are forbidden.
  570|       |    ///
  571|       |    ///   Accesses from Safe Rust necessarily follow this rule,
  572|       |    ///   because the returned slice's lifetime is the same as that of
  573|       |    ///   a mutable borrow of self.
  574|       |    /// - The total size self.mem_size() * mem::size_of::<u8>() of the
  575|       |    ///   slice must be no larger than isize::MAX, and adding that
  576|       |    ///   size to data must not "wrap around" the address space. See
  577|       |    ///   the safety documentation of pointer::offset.
  578|       |    ///
  579|       |    ///   This is ensured by a check in ::new()
  580|  33.1k|    pub(super) fn as_mut_slice(&mut self) -> &mut [u8] {
  581|  33.1k|        unsafe { std::slice::from_raw_parts_mut(self.base_ptr(), self.mem_size()) }
  582|  33.1k|    }
  583|       |
  584|       |    /// Internal helper method to get the backing memory as a slice.
  585|       |    ///
  586|       |    /// # Safety
  587|       |    /// See the discussion on as_mut_slice, with the third point
  588|       |    /// replaced by:
  589|       |    /// - The memory referenced by the returned slice must not be
  590|       |    ///   mutated for the duration of lifetime 'a, except inside an
  591|       |    ///   UnsafeCell.
  592|       |    ///
  593|       |    ///   Host accesses from Safe Rust necessarily follow this rule,
  594|       |    ///   because the returned slice's lifetime is the same as that of
  595|       |    ///   a borrow of self, preventing mutations via other methods.
  596|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  597|  1.10k|    pub fn as_slice<'a>(&'a self) -> &'a [u8] {
  598|  1.10k|        unsafe { std::slice::from_raw_parts(self.base_ptr(), self.mem_size()) }
  599|  1.10k|    }
  600|       |
  601|       |    /// Copy the entire contents of `self` into a `Vec<u8>`, then return it
  602|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  603|     11|    pub(crate) fn copy_all_to_vec(&self) -> Result<Vec<u8>> {
  604|       |        let data = self.as_slice();
  605|       |        Ok(data.to_vec())
  606|     11|    }
  607|       |
  608|       |    /// Copies all bytes from `src` to `self` starting at offset
  609|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  610|    265|    pub fn copy_from_slice(&mut self, src: &[u8], offset: usize) -> Result<()> {
  611|       |        let data = self.as_mut_slice();
  612|       |        bounds_check!(offset, src.len(), data.len());
  613|       |        data[offset..offset + src.len()].copy_from_slice(src);
  614|       |        Ok(())
  615|    265|    }
  616|       |
  617|       |    /// Return the address of memory at an offset to this `SharedMemory` checking
  618|       |    /// that the memory is within the bounds of the `SharedMemory`.
  619|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  620|       |    #[allow(dead_code)]
  621|      0|    pub(crate) fn calculate_address(&self, offset: usize) -> Result<usize> {
  622|       |        bounds_check!(offset, 0, self.mem_size());
  623|       |        Ok(self.base_addr() + offset)
  624|      0|    }
  625|       |
  626|       |    generate_reader!(read_u8, u8);
  627|       |    generate_reader!(read_i8, i8);
  628|       |    generate_reader!(read_u16, u16);
  629|       |    generate_reader!(read_i16, i16);
  630|       |    generate_reader!(read_u32, u32);
  631|       |    generate_reader!(read_i32, i32);
  632|       |    generate_reader!(read_u64, u64);
  633|       |    generate_reader!(read_i64, i64);
  634|       |    generate_reader!(read_usize, usize);
  635|       |    generate_reader!(read_isize, isize);
  636|       |
  637|       |    generate_writer!(write_u8, u8);
  638|       |    generate_writer!(write_i8, i8);
  639|       |    generate_writer!(write_u16, u16);
  640|       |    generate_writer!(write_i16, i16);
  641|       |    generate_writer!(write_u32, u32);
  642|       |    generate_writer!(write_i32, i32);
  643|       |    generate_writer!(write_u64, u64);
  644|       |    generate_writer!(write_i64, i64);
  645|       |    generate_writer!(write_usize, usize);
  646|       |    generate_writer!(write_isize, isize);
  647|       |
  648|       |    /// Convert the ExclusiveSharedMemory, which may be freely
  649|       |    /// modified, into a GuestSharedMemory, which may be somewhat
  650|       |    /// freely modified (mostly by the guest), and a HostSharedMemory,
  651|       |    /// which may only make certain kinds of accesses that do not race
  652|       |    /// in the presence of malicious code inside the guest mutating
  653|       |    /// the GuestSharedMemory.
  654|  1.85k|    pub fn build(self) -> (HostSharedMemory, GuestSharedMemory) {
  655|  1.85k|        let lock = Arc::new(RwLock::new(()));
  656|  1.85k|        (
  657|  1.85k|            HostSharedMemory {
  658|  1.85k|                region: self.region.clone(),
  659|  1.85k|                lock: lock.clone(),
  660|  1.85k|            },
  661|  1.85k|            GuestSharedMemory {
  662|  1.85k|                region: self.region.clone(),
  663|  1.85k|                lock: lock.clone(),
  664|  1.85k|            },
  665|  1.85k|        )
  666|  1.85k|    }
  667|       |
  668|       |    /// Gets the file handle of the shared memory region for this Sandbox
  669|       |    #[cfg(target_os = "windows")]
  670|       |    pub fn get_mmap_file_handle(&self) -> HANDLE {
  671|       |        self.region.handle
  672|       |    }
  673|       |}
  674|       |
  675|       |/// A trait that abstracts over the particular kind of SharedMemory,
  676|       |/// used when invoking operations from Rust that absolutely must have
  677|       |/// exclusive control over the shared memory for correctness +
  678|       |/// performance, like snapshotting.
  679|       |pub trait SharedMemory {
  680|       |    /// Return a readonly reference to the host mapping backing this SharedMemory
  681|       |    fn region(&self) -> &HostMapping;
  682|       |
  683|       |    /// Return the base address of the host mapping of this
  684|       |    /// region. Following the general Rust philosophy, this does not
  685|       |    /// need to be marked as `unsafe` because doing anything with this
  686|       |    /// pointer itself requires `unsafe`.
  687|  35.9k|    fn base_addr(&self) -> usize {
  688|  35.9k|        self.region().ptr as usize + PAGE_SIZE_USIZE
  689|  35.9k|    }
  690|       |
  691|       |    /// Return the base address of the host mapping of this region as
  692|       |    /// a pointer. Following the general Rust philosophy, this does
  693|       |    /// not need to be marked as `unsafe` because doing anything with
  694|       |    /// this pointer itself requires `unsafe`.
  695|  35.8k|    fn base_ptr(&self) -> *mut u8 {
  696|  35.8k|        self.base_addr() as *mut u8
  697|  35.8k|    }
  698|       |
  699|       |    /// Return the length of usable memory contained in `self`.
  700|       |    /// The returned size does not include the size of the surrounding
  701|       |    /// guard pages.
  702|  39.5k|    fn mem_size(&self) -> usize {
  703|  39.5k|        self.region().size - 2 * PAGE_SIZE_USIZE
  704|  39.5k|    }
  705|       |
  706|       |    /// Return the raw base address of the host mapping, including the
  707|       |    /// guard pages.
  708|      3|    fn raw_ptr(&self) -> *mut u8 {
  709|      3|        self.region().ptr
  710|      3|    }
  711|       |
  712|       |    /// Return the raw size of the host mapping, including the guard
  713|       |    /// pages.
  714|      0|    fn raw_mem_size(&self) -> usize {
  715|      0|        self.region().size
  716|      0|    }
  717|       |
  718|       |    /// Run some code with exclusive access to the SharedMemory
  719|       |    /// underlying this.  If the SharedMemory is not an
  720|       |    /// ExclusiveSharedMemory, any concurrent accesses to the relevant
  721|       |    /// HostSharedMemory/GuestSharedMemory may make this fail, or be
  722|       |    /// made to fail by this, and should be avoided.
  723|       |    fn with_exclusivity<T, F: FnOnce(&mut ExclusiveSharedMemory) -> T>(
  724|       |        &mut self,
  725|       |        f: F,
  726|       |    ) -> Result<T>;
  727|       |}
  728|       |
  729|       |impl SharedMemory for ExclusiveSharedMemory {
  730|  68.5k|    fn region(&self) -> &HostMapping {
  731|  68.5k|        &self.region
  732|  68.5k|    }
  733|      4|    fn with_exclusivity<T, F: FnOnce(&mut ExclusiveSharedMemory) -> T>(
  734|      4|        &mut self,
  735|      4|        f: F,
  736|      4|    ) -> Result<T> {
  737|      4|        Ok(f(self))
  738|      4|    }
  739|       |}
  740|       |
  741|       |impl SharedMemory for GuestSharedMemory {
  742|    177|    fn region(&self) -> &HostMapping {
  743|    177|        &self.region
  744|    177|    }
  745|     59|    fn with_exclusivity<T, F: FnOnce(&mut ExclusiveSharedMemory) -> T>(
  746|     59|        &mut self,
  747|     59|        f: F,
  748|     59|    ) -> Result<T> {
  749|     59|        let guard = self
  750|     59|            .lock
  751|     59|            .try_write()
  752|     59|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
                                       ^0                                                            ^0
  753|     59|        let mut excl = ExclusiveSharedMemory {
  754|     59|            region: self.region.clone(),
  755|     59|        };
  756|     59|        let ret = f(&mut excl);
  757|     59|        drop(excl);
  758|     59|        drop(guard);
  759|     59|        Ok(ret)
  760|     59|    }
  761|       |}
  762|       |
  763|       |/// An unsafe marker trait for types for which all bit patterns are valid.
  764|       |/// This is required in order for it to be safe to read a value of a particular
  765|       |/// type out of the sandbox from the HostSharedMemory.
  766|       |///
  767|       |/// # Safety
  768|       |/// This must only be implemented for types for which all bit patterns
  769|       |/// are valid. It requires that any (non-undef/poison) value of the
  770|       |/// correct size can be transmuted to the type.
  771|       |pub unsafe trait AllValid {}
  772|       |unsafe impl AllValid for u8 {}
  773|       |unsafe impl AllValid for u16 {}
  774|       |unsafe impl AllValid for u32 {}
  775|       |unsafe impl AllValid for u64 {}
  776|       |unsafe impl AllValid for i8 {}
  777|       |unsafe impl AllValid for i16 {}
  778|       |unsafe impl AllValid for i32 {}
  779|       |unsafe impl AllValid for i64 {}
  780|       |unsafe impl AllValid for [u8; 16] {}
  781|       |
  782|       |impl HostSharedMemory {
  783|       |    /// Read a value of type T, whose representation is the same
  784|       |    /// between the sandbox and the host, and which has no invalid bit
  785|       |    /// patterns
  786|  1.03k|    pub fn read<T: AllValid>(&self, offset: usize) -> Result<T> {
  787|  1.03k|        bounds_check!(offset, std::mem::size_of::<T>(), self.mem_size());
                                                                      ^256
  788|       |        unsafe {
  789|    775|            let mut ret: core::mem::MaybeUninit<T> = core::mem::MaybeUninit::uninit();
  790|    775|            {
  791|    775|                let slice: &mut [u8] = core::slice::from_raw_parts_mut(
  792|    775|                    ret.as_mut_ptr() as *mut u8,
  793|    775|                    std::mem::size_of::<T>(),
  794|    775|                );
  795|    775|                self.copy_to_slice(slice, offset)?;
                                                               ^0
  796|       |            }
  797|    775|            Ok(ret.assume_init())
  798|       |        }
  799|  1.03k|    }
  800|       |
  801|       |    /// Write a value of type T, whose representation is the same
  802|       |    /// between the sandbox and the host, and which has no invalid bit
  803|       |    /// patterns
  804|  1.53k|    pub fn write<T: AllValid>(&self, offset: usize, data: T) -> Result<()> {
  805|  1.53k|        bounds_check!(offset, std::mem::size_of::<T>(), self.mem_size());
                                                                      ^768
  806|       |        unsafe {
  807|    768|            let slice: &[u8] = core::slice::from_raw_parts(
  808|    768|                core::ptr::addr_of!(data) as *const u8,
  809|    768|                std::mem::size_of::<T>(),
  810|    768|            );
  811|    768|            self.copy_from_slice(slice, offset)?;
                                                             ^0
  812|       |        }
  813|    768|        Ok(())
  814|  1.53k|    }
  815|       |
  816|       |    /// Copy the contents of the slice into the sandbox at the
  817|       |    /// specified offset
  818|    781|    pub fn copy_to_slice(&self, slice: &mut [u8], offset: usize) -> Result<()> {
  819|    781|        bounds_check!(offset, slice.len(), self.mem_size());
                                            ^3
  820|    778|        let base = self.base_ptr().wrapping_add(offset);
  821|    778|        let guard = self
  822|    778|            .lock
  823|    778|            .try_read()
  824|    778|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
                                       ^0                                                            ^0
  825|       |        // todo: replace with something a bit more optimized + correct
  826|  3.10k|        for (i, b) in slice.iter_mut().enumerate() {
                                    ^778
  827|  3.10k|            unsafe {
  828|  3.10k|                *b = base.wrapping_add(i).read_volatile();
  829|  3.10k|            }
  830|       |        }
  831|    778|        drop(guard);
  832|    778|        Ok(())
  833|    781|    }
  834|       |
  835|       |    /// Copy the contents of the sandbox at the specified offset into
  836|       |    /// the slice
  837|    777|    pub fn copy_from_slice(&self, slice: &[u8], offset: usize) -> Result<()> {
  838|    777|        bounds_check!(offset, slice.len(), self.mem_size());
                                            ^3
  839|    774|        let base = self.base_ptr().wrapping_add(offset);
  840|    774|        let guard = self
  841|    774|            .lock
  842|    774|            .try_read()
  843|    774|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
                                       ^0                                                            ^0
  844|       |        // todo: replace with something a bit more optimized + correct
  845|  3.10k|        for (i, b) in slice.iter().enumerate() {
                                    ^774
  846|  3.10k|            unsafe {
  847|  3.10k|                base.wrapping_add(i).write_volatile(*b);
  848|  3.10k|            }
  849|       |        }
  850|    774|        drop(guard);
  851|    774|        Ok(())
  852|    777|    }
  853|       |
  854|       |    /// Fill the memory in the range `[offset, offset + len)` with `value`
  855|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  856|      7|    pub fn fill(&mut self, value: u8, offset: usize, len: usize) -> Result<()> {
  857|       |        bounds_check!(offset, len, self.mem_size());
  858|       |        let base = self.base_ptr().wrapping_add(offset);
  859|       |        let guard = self
  860|       |            .lock
  861|       |            .try_read()
  862|      0|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
  863|       |        // todo: replace with something a bit more optimized + correct
  864|       |        for i in 0..len {
  865|       |            unsafe { base.wrapping_add(i).write_volatile(value) };
  866|       |        }
  867|       |        drop(guard);
  868|       |        Ok(())
  869|      7|    }
  870|       |
  871|       |    /// Pushes the given data onto shared memory to the buffer at the given offset.
  872|       |    /// NOTE! buffer_start_offset must point to the beginning of the buffer
  873|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  874|      0|    pub fn push_buffer(
  875|      0|        &mut self,
  876|      0|        buffer_start_offset: usize,
  877|      0|        buffer_size: usize,
  878|      0|        data: &[u8],
  879|      0|    ) -> Result<()> {
  880|       |        let stack_pointer_rel = self.read::<u64>(buffer_start_offset)? as usize;
  881|       |        let buffer_size_u64: u64 = buffer_size.try_into()?;
  882|       |
  883|       |        if stack_pointer_rel > buffer_size || stack_pointer_rel < 8 {
  884|       |            return Err(new_error!(
  885|       |                "Unable to push data to buffer: Stack pointer is out of bounds. Stack pointer: {}, Buffer size: {}",
  886|       |                stack_pointer_rel,
  887|       |                buffer_size_u64
  888|       |            ));
  889|       |        }
  890|       |
  891|       |        let size_required = data.len() + 8;
  892|       |        let size_available = buffer_size - stack_pointer_rel;
  893|       |
  894|       |        if size_required > size_available {
  895|       |            return Err(new_error!(
  896|       |                "Not enough space in buffer to push data. Required: {}, Available: {}",
  897|       |                size_required,
  898|       |                size_available
  899|       |            ));
  900|       |        }
  901|       |
  902|       |        // get absolute
  903|       |        let stack_pointer_abs = stack_pointer_rel + buffer_start_offset;
  904|       |
  905|       |        // write the actual data to the top of stack
  906|       |        self.copy_from_slice(data, stack_pointer_abs)?;
  907|       |
  908|       |        // write the offset to the newly written data, to the top of stack.
  909|       |        // this is used when popping the stack, to know how far back to jump
  910|       |        self.write::<u64>(stack_pointer_abs + data.len(), stack_pointer_rel as u64)?;
  911|       |
  912|       |        // update stack pointer to point to the next free address
  913|       |        self.write::<u64>(
  914|       |            buffer_start_offset,
  915|       |            (stack_pointer_rel + data.len() + 8) as u64,
  916|       |        )?;
  917|       |        Ok(())
  918|      0|    }
  919|       |
  920|       |    /// Pops the given given buffer into a `T` and returns it.
  921|       |    /// NOTE! the data must be a size-prefixed flatbuffer, and
  922|       |    /// buffer_start_offset must point to the beginning of the buffer
  923|      0|    pub fn try_pop_buffer_into<T>(
  924|      0|        &mut self,
  925|      0|        buffer_start_offset: usize,
  926|      0|        buffer_size: usize,
  927|      0|    ) -> Result<T>
  928|      0|    where
  929|      0|        T: for<'b> TryFrom<&'b [u8]>,
  930|      0|    {
  931|       |        // get the stackpointer
  932|      0|        let stack_pointer_rel = self.read::<u64>(buffer_start_offset)? as usize;
  933|       |
  934|      0|        if stack_pointer_rel > buffer_size || stack_pointer_rel < 16 {
  935|      0|            return Err(new_error!(
  936|      0|                "Unable to pop data from buffer: Stack pointer is out of bounds. Stack pointer: {}, Buffer size: {}",
  937|      0|                stack_pointer_rel,
  938|      0|                buffer_size
  939|      0|            ));
  940|      0|        }
  941|      0|
  942|      0|        // make it absolute
  943|      0|        let last_element_offset_abs = stack_pointer_rel + buffer_start_offset;
  944|       |
  945|       |        // go back 8 bytes to get offset to element on top of stack
  946|      0|        let last_element_offset_rel: usize =
  947|      0|            self.read::<u64>(last_element_offset_abs - 8)? as usize;
  948|       |
  949|       |        // make it absolute
  950|      0|        let last_element_offset_abs = last_element_offset_rel + buffer_start_offset;
  951|       |
  952|       |        // Get the size of the flatbuffer buffer from memory
  953|      0|        let fb_buffer_size = {
  954|      0|            let size_i32 = self.read::<u32>(last_element_offset_abs)? + 4;
  955|       |            // ^^^ flatbuffer byte arrays are prefixed by 4 bytes
  956|       |            // indicating its size, so, to get the actual size, we need
  957|       |            // to add 4.
  958|      0|            usize::try_from(size_i32)
  959|      0|        }?;
  960|       |
  961|      0|        let mut result_buffer = vec![0; fb_buffer_size];
  962|      0|
  963|      0|        self.copy_to_slice(&mut result_buffer, last_element_offset_abs)?;
  964|      0|        let to_return = T::try_from(result_buffer.as_slice()).map_err(|_e| {
  965|      0|            new_error!(
  966|      0|                "pop_buffer_into: failed to convert buffer to {}",
  967|      0|                type_name::<T>()
  968|      0|            )
  969|      0|        })?;
  970|       |
  971|       |        // update the stack pointer to point to the element we just popped off since that is now free
  972|      0|        self.write::<u64>(buffer_start_offset, last_element_offset_rel as u64)?;
  973|       |
  974|       |        // zero out the memory we just popped off
  975|      0|        let num_bytes_to_zero = stack_pointer_rel - last_element_offset_rel;
  976|      0|        self.fill(0, last_element_offset_abs, num_bytes_to_zero)?;
  977|       |
  978|      0|        Ok(to_return)
  979|      0|    }
  980|       |}
  981|       |
  982|       |impl SharedMemory for HostSharedMemory {
  983|  6.72k|    fn region(&self) -> &HostMapping {
  984|  6.72k|        &self.region
  985|  6.72k|    }
  986|      2|    fn with_exclusivity<T, F: FnOnce(&mut ExclusiveSharedMemory) -> T>(
  987|      2|        &mut self,
  988|      2|        f: F,
  989|      2|    ) -> Result<T> {
  990|      2|        let guard = self
  991|      2|            .lock
  992|      2|            .try_write()
  993|      2|            .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?;
                                       ^0                                                            ^0
  994|      2|        let mut excl = ExclusiveSharedMemory {
  995|      2|            region: self.region.clone(),
  996|      2|        };
  997|      2|        let ret = f(&mut excl);
  998|      2|        drop(excl);
  999|      2|        drop(guard);
 1000|      2|        Ok(ret)
 1001|      2|    }
 1002|       |}
 1003|       |
 1004|       |#[cfg(test)]
 1005|       |mod tests {
 1006|       |    use hyperlight_common::mem::PAGE_SIZE_USIZE;
 1007|       |    use proptest::prelude::*;
 1008|       |
 1009|       |    use super::{ExclusiveSharedMemory, HostSharedMemory, SharedMemory};
 1010|       |    use crate::Result;
 1011|       |    use crate::mem::shared_mem_tests::read_write_test_suite;
 1012|       |
 1013|       |    #[test]
 1014|      1|    fn fill() {
 1015|      1|        let mem_size: usize = 4096;
 1016|      1|        let eshm = ExclusiveSharedMemory::new(mem_size).unwrap();
 1017|      1|        let (mut hshm, _) = eshm.build();
 1018|      1|
 1019|      1|        hshm.fill(1, 0, 1024).unwrap();
 1020|      1|        hshm.fill(2, 1024, 1024).unwrap();
 1021|      1|        hshm.fill(3, 2048, 1024).unwrap();
 1022|      1|        hshm.fill(4, 3072, 1024).unwrap();
 1023|      1|
 1024|      1|        let vec = hshm
 1025|      1|            .with_exclusivity(|e| e.copy_all_to_vec().unwrap())
 1026|      1|            .unwrap();
 1027|      1|
 1028|  1.02k|        assert!(vec[0..1024].iter().all(|&x| x == 1));
                                                                 ^1
 1029|  1.02k|        assert!(vec[1024..2048].iter().all(|&x| x == 2));
                      ^1                                            ^1
 1030|  1.02k|        assert!(vec[2048..3072].iter().all(|&x| x == 3));
                      ^1                                            ^1
 1031|  1.02k|        assert!(vec[3072..4096].iter().all(|&x| x == 4));
                      ^1                                            ^1
 1032|       |
 1033|      1|        hshm.fill(5, 0, 4096).unwrap();
 1034|      1|
 1035|      1|        let vec2 = hshm
 1036|      1|            .with_exclusivity(|e| e.copy_all_to_vec().unwrap())
 1037|      1|            .unwrap();
 1038|  4.09k|        assert!(vec2.iter().all(|&x| x == 5));
                                                         ^1
 1039|       |
 1040|      1|        assert!(hshm.fill(0, 0, mem_size + 1).is_err());
 1041|      1|        assert!(hshm.fill(0, mem_size, 1).is_err());
 1042|      1|    }
 1043|       |
 1044|       |    #[test]
 1045|      1|    fn copy_into_from() -> Result<()> {
 1046|      1|        let mem_size: usize = 4096;
 1047|      1|        let vec_len = 10;
 1048|      1|        let eshm = ExclusiveSharedMemory::new(mem_size)?;
                                                                     ^0
 1049|      1|        let (hshm, _) = eshm.build();
 1050|      1|        let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 1051|      1|        // write the value to the memory at the beginning.
 1052|      1|        hshm.copy_from_slice(&vec, 0)?;
                                                   ^0
 1053|       |
 1054|      1|        let mut vec2 = vec![0; vec_len];
 1055|      1|        // read the value back from the memory at the beginning.
 1056|      1|        hshm.copy_to_slice(vec2.as_mut_slice(), 0)?;
                                                                ^0
 1057|      1|        assert_eq!(vec, vec2);
 1058|       |
 1059|      1|        let offset = mem_size - vec.len();
 1060|      1|        // write the value to the memory at the end.
 1061|      1|        hshm.copy_from_slice(&vec, offset)?;
                                                        ^0
 1062|       |
 1063|      1|        let mut vec3 = vec![0; vec_len];
 1064|      1|        // read the value back from the memory at the end.
 1065|      1|        hshm.copy_to_slice(&mut vec3, offset)?;
                                                           ^0
 1066|      1|        assert_eq!(vec, vec3);
 1067|       |
 1068|      1|        let offset = mem_size / 2;
 1069|      1|        // write the value to the memory at the middle.
 1070|      1|        hshm.copy_from_slice(&vec, offset)?;
                                                        ^0
 1071|       |
 1072|      1|        let mut vec4 = vec![0; vec_len];
 1073|      1|        // read the value back from the memory at the middle.
 1074|      1|        hshm.copy_to_slice(&mut vec4, offset)?;
                                                           ^0
 1075|      1|        assert_eq!(vec, vec4);
 1076|       |
 1077|       |        // try and read a value from an offset that is beyond the end of the memory.
 1078|      1|        let mut vec5 = vec![0; vec_len];
 1079|      1|        assert!(hshm.copy_to_slice(&mut vec5, mem_size).is_err());
 1080|       |
 1081|       |        // try and write a value to an offset that is beyond the end of the memory.
 1082|      1|        assert!(hshm.copy_from_slice(&vec5, mem_size).is_err());
 1083|       |
 1084|       |        // try and read a value from an offset that is too large.
 1085|      1|        let mut vec6 = vec![0; vec_len];
 1086|      1|        assert!(hshm.copy_to_slice(&mut vec6, mem_size * 2).is_err());
 1087|       |
 1088|       |        // try and write a value to an offset that is too large.
 1089|      1|        assert!(hshm.copy_from_slice(&vec6, mem_size * 2).is_err());
 1090|       |
 1091|       |        // try and read a value that is too large.
 1092|      1|        let mut vec7 = vec![0; mem_size * 2];
 1093|      1|        assert!(hshm.copy_to_slice(&mut vec7, 0).is_err());
 1094|       |
 1095|       |        // try and write a value that is too large.
 1096|      1|        assert!(hshm.copy_from_slice(&vec7, 0).is_err());
 1097|       |
 1098|      1|        Ok(())
 1099|      1|    }
 1100|       |
 1101|       |    proptest! {
 1102|       |        #[test]
 1103|       |        fn read_write_i32(val in -0x1000_i32..0x1000_i32) {
 1104|       |            read_write_test_suite(
 1105|       |                val,
 1106|       |                ExclusiveSharedMemory::new,
 1107|       |                Box::new(ExclusiveSharedMemory::read_i32),
 1108|       |                Box::new(ExclusiveSharedMemory::write_i32),
 1109|       |            )
 1110|       |            .unwrap();
 1111|       |            read_write_test_suite(
 1112|       |                val,
 1113|  1.79k|                |s| {
 1114|  1.79k|                    let e = ExclusiveSharedMemory::new(s)?;
                                                                       ^0
 1115|  1.79k|                    let (h, _) = e.build();
 1116|  1.79k|                    Ok(h)
 1117|  1.79k|                },
 1118|       |                Box::new(HostSharedMemory::read::<i32>),
 1119|  1.53k|                Box::new(|h, o, v| h.write::<i32>(o, v)),
 1120|       |            )
 1121|       |            .unwrap();
 1122|       |        }
 1123|       |    }
 1124|       |
 1125|       |    #[test]
 1126|      1|    fn alloc_fail() {
 1127|      1|        let gm = ExclusiveSharedMemory::new(0);
 1128|      1|        assert!(gm.is_err());
 1129|      1|        let gm = ExclusiveSharedMemory::new(usize::MAX);
 1130|      1|        assert!(gm.is_err());
 1131|      1|    }
 1132|       |
 1133|       |    #[test]
 1134|      1|    fn clone() {
 1135|      1|        let eshm = ExclusiveSharedMemory::new(PAGE_SIZE_USIZE).unwrap();
 1136|      1|        let (hshm1, _) = eshm.build();
 1137|      1|        let hshm2 = hshm1.clone();
 1138|      1|
 1139|      1|        // after hshm1 is cloned, hshm1 and hshm2 should have identical
 1140|      1|        // memory sizes and pointers.
 1141|      1|        assert_eq!(hshm1.mem_size(), hshm2.mem_size());
 1142|      1|        assert_eq!(hshm1.base_addr(), hshm2.base_addr());
 1143|       |
 1144|       |        // we should be able to copy a byte array into both hshm1 and hshm2,
 1145|       |        // and have both changes be reflected in all clones
 1146|      1|        hshm1.copy_from_slice(b"a", 0).unwrap();
 1147|      1|        hshm2.copy_from_slice(b"b", 1).unwrap();
 1148|       |
 1149|       |        // at this point, both hshm1 and hshm2 should have
 1150|       |        // offset 0 = 'a', offset 1 = 'b'
 1151|      3|        for (raw_offset, expected) in &[(0, b'a'), (1, b'b')] {
                           ^2
 1152|      2|            assert_eq!(hshm1.read::<u8>(*raw_offset).unwrap(), *expected);
 1153|      2|            assert_eq!(hshm2.read::<u8>(*raw_offset).unwrap(), *expected);
 1154|       |        }
 1155|       |
 1156|       |        // after we drop hshm1, hshm2 should still exist, be valid,
 1157|       |        // and have all contents from before hshm1 was dropped
 1158|      1|        drop(hshm1);
 1159|       |
 1160|       |        // at this point, hshm2 should still have offset 0 = 'a', offset 1 = 'b'
 1161|      3|        for (raw_offset, expected) in &[(0, b'a'), (1, b'b')] {
                           ^2
 1162|      2|            assert_eq!(hshm2.read::<u8>(*raw_offset).unwrap(), *expected);
 1163|       |        }
 1164|      1|        hshm2.copy_from_slice(b"c", 2).unwrap();
 1165|      1|        assert_eq!(hshm2.read::<u8>(2).unwrap(), b'c');
 1166|      1|        drop(hshm2);
 1167|      1|    }
 1168|       |
 1169|       |    #[test]
 1170|      1|    fn copy_all_to_vec() {
 1171|      1|        let mut data = vec![b'a', b'b', b'c'];
 1172|      1|        data.resize(4096, 0);
 1173|      1|        let mut eshm = ExclusiveSharedMemory::new(data.len()).unwrap();
 1174|      1|        eshm.copy_from_slice(data.as_slice(), 0).unwrap();
 1175|      1|        let ret_vec = eshm.copy_all_to_vec().unwrap();
 1176|      1|        assert_eq!(data, ret_vec);
 1177|      1|    }
 1178|       |
 1179|       |    /// A test to ensure that, if a `SharedMem` instance is cloned
 1180|       |    /// and _all_ clones are dropped, the memory region will no longer
 1181|       |    /// be valid.
 1182|       |    ///
 1183|       |    /// This test is ignored because it is incompatible with other tests as
 1184|       |    /// they may be allocating memory at the same time.
 1185|       |    ///
 1186|       |    /// Marking this test as ignored means that running `cargo test` will not
 1187|       |    /// run it. This feature will allow a developer who runs that command
 1188|       |    /// from their workstation to be successful without needing to know about
 1189|       |    /// test interdependencies. This test will, however, be run explicitly as a
 1190|       |    /// part of the CI pipeline.
 1191|       |    #[test]
 1192|       |    #[ignore]
 1193|       |    #[cfg(target_os = "linux")]
 1194|      0|    fn test_drop() {
 1195|       |        use proc_maps::maps_contain_addr;
 1196|       |
 1197|      0|        let pid = std::process::id();
 1198|      0|
 1199|      0|        let eshm = ExclusiveSharedMemory::new(PAGE_SIZE_USIZE).unwrap();
 1200|      0|        let (hshm1, gshm) = eshm.build();
 1201|      0|        let hshm2 = hshm1.clone();
 1202|      0|        let addr = hshm1.raw_ptr() as usize;
 1203|      0|
 1204|      0|        // ensure the address is in the process's virtual memory
 1205|      0|        let maps_before_drop = proc_maps::get_process_maps(pid.try_into().unwrap()).unwrap();
 1206|      0|        assert!(
 1207|      0|            maps_contain_addr(addr, &maps_before_drop),
 1208|      0|            "shared memory address {:#x} was not found in process map, but should be",
 1209|       |            addr,
 1210|       |        );
 1211|       |        // drop both shared memory instances, which should result
 1212|       |        // in freeing the memory region
 1213|      0|        drop(hshm1);
 1214|      0|        drop(hshm2);
 1215|      0|        drop(gshm);
 1216|      0|
 1217|      0|        let maps_after_drop = proc_maps::get_process_maps(pid.try_into().unwrap()).unwrap();
 1218|      0|        // now, ensure the address is not in the process's virtual memory
 1219|      0|        assert!(
 1220|      0|            !maps_contain_addr(addr, &maps_after_drop),
 1221|      0|            "shared memory address {:#x} was found in the process map, but shouldn't be",
 1222|       |            addr
 1223|       |        );
 1224|      0|    }
 1225|       |
 1226|       |    #[cfg(target_os = "linux")]
 1227|       |    mod guard_page_crash_test {
 1228|       |        use crate::mem::shared_mem::{ExclusiveSharedMemory, SharedMemory};
 1229|       |
 1230|       |        const TEST_EXIT_CODE: u8 = 211; // an uncommon exit code, used for testing purposes
 1231|       |
 1232|       |        /// hook sigsegv to exit with status code, to make it testable, rather than have it exit from a signal
 1233|       |        /// NOTE: We CANNOT panic!() in the handler, and make the tests #[should_panic], because
 1234|       |        ///     the test harness process will crash anyway after the test passes
 1235|      3|        fn setup_signal_handler() {
 1236|      3|            unsafe {
 1237|      3|                signal_hook_registry::register_signal_unchecked(libc::SIGSEGV, || {
 1238|      3|                    std::process::exit(TEST_EXIT_CODE.into());
 1239|      3|                })
 1240|      3|                .unwrap();
 1241|      3|            }
 1242|      3|        }
 1243|       |
 1244|       |        #[test]
 1245|       |        #[ignore] // this test is ignored because it will crash the running process
 1246|      1|        fn read() {
 1247|      1|            setup_signal_handler();
 1248|      1|
 1249|      1|            let eshm = ExclusiveSharedMemory::new(4096).unwrap();
 1250|      1|            let (hshm, _) = eshm.build();
 1251|      1|            let guard_page_ptr = hshm.raw_ptr();
 1252|      1|            unsafe { std::ptr::read_volatile(guard_page_ptr) };
 1253|      1|        }
 1254|       |
 1255|       |        #[test]
 1256|       |        #[ignore] // this test is ignored because it will crash the running process
 1257|      1|        fn write() {
 1258|      1|            setup_signal_handler();
 1259|      1|
 1260|      1|            let eshm = ExclusiveSharedMemory::new(4096).unwrap();
 1261|      1|            let (hshm, _) = eshm.build();
 1262|      1|            let guard_page_ptr = hshm.raw_ptr();
 1263|      1|            unsafe { std::ptr::write_volatile(guard_page_ptr, 0u8) };
 1264|      1|        }
 1265|       |
 1266|       |        #[test]
 1267|       |        #[ignore] // this test is ignored because it will crash the running process
 1268|      1|        fn exec() {
 1269|      1|            setup_signal_handler();
 1270|      1|
 1271|      1|            let eshm = ExclusiveSharedMemory::new(4096).unwrap();
 1272|      1|            let (hshm, _) = eshm.build();
 1273|      1|            let guard_page_ptr = hshm.raw_ptr();
 1274|      1|            let func: fn() = unsafe { std::mem::transmute(guard_page_ptr) };
 1275|      1|            func();
 1276|      1|        }
 1277|       |
 1278|       |        // provides a way for running the above tests in a separate process since they expect to crash
 1279|       |        #[test]
 1280|      1|        fn guard_page_testing_shim() {
 1281|      1|            let tests = vec!["read", "write", "exec"];
 1282|       |
 1283|      4|            for test in tests {
                              ^3
 1284|      3|                let status = std::process::Command::new("cargo")
 1285|      3|                    .args(["test", "-p", "hyperlight-host", "--", "--ignored", test])
 1286|      3|                    .stdin(std::process::Stdio::null())
 1287|      3|                    .stdout(std::process::Stdio::null())
 1288|      3|                    .stderr(std::process::Stdio::null())
 1289|      3|                    .status()
 1290|      3|                    .expect("Unable to launch tests");
 1291|      3|                assert_eq!(
 1292|      3|                    status.code(),
 1293|      3|                    Some(TEST_EXIT_CODE.into()),
 1294|      0|                    "Guard Page test failed: {}",
 1295|       |                    test
 1296|       |                );
 1297|       |            }
 1298|      1|        }
 1299|       |    }
 1300|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/shared_mem_snapshot.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use tracing::{Span, instrument};
   18|       |
   19|       |use super::memory_region::MemoryRegion;
   20|       |use super::shared_mem::SharedMemory;
   21|       |use crate::Result;
   22|       |
   23|       |/// A wrapper around a `SharedMemory` reference and a snapshot
   24|       |/// of the memory therein
   25|       |#[derive(Clone)]
   26|       |pub(crate) struct SharedMemorySnapshot {
   27|       |    // Unique ID of the sandbox this snapshot was taken from
   28|       |    sandbox_id: u64,
   29|       |    // Memory of the sandbox at the time this snapshot was taken
   30|       |    snapshot: Vec<u8>,
   31|       |    /// The memory regions that were mapped when this snapshot was taken (excluding initial sandbox regions)
   32|       |    regions: Vec<MemoryRegion>,
   33|       |}
   34|       |
   35|       |impl SharedMemorySnapshot {
   36|       |    /// Take a snapshot of the memory in `shared_mem`, then create a new
   37|       |    /// instance of `Self` with the snapshot stored therein.
   38|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   39|      1|    pub(super) fn new<S: SharedMemory>(
   40|      1|        shared_mem: &mut S,
   41|      1|        sandbox_id: u64,
   42|      1|        regions: Vec<MemoryRegion>,
   43|      1|    ) -> Result<Self> {
   44|       |        // TODO: Track dirty pages instead of copying entire memory
   45|      1|        let snapshot = shared_mem.with_exclusivity(|e| e.copy_all_to_vec())??;
   46|       |        Ok(Self {
   47|       |            sandbox_id,
   48|       |            snapshot,
   49|       |            regions,
   50|       |        })
   51|      1|    }
   52|       |
   53|       |    /// Take another snapshot of the internally-stored `SharedMemory`,
   54|       |    /// then store it internally.
   55|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   56|       |    #[allow(dead_code)]
   57|      1|    pub(super) fn replace_snapshot<S: SharedMemory>(&mut self, shared_mem: &mut S) -> Result<()> {
   58|      1|        self.snapshot = shared_mem.with_exclusivity(|e| e.copy_all_to_vec())??;
   59|       |        Ok(())
   60|      1|    }
   61|       |
   62|       |    /// Copy the memory from the internally-stored memory snapshot
   63|       |    /// into the internally-stored `SharedMemory`.
   64|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   65|      2|    pub(super) fn restore_from_snapshot<S: SharedMemory>(&self, shared_mem: &mut S) -> Result<()> {
   66|      2|        shared_mem.with_exclusivity(|e| e.copy_from_slice(self.snapshot.as_slice(), 0))??;
   67|       |        Ok(())
   68|      2|    }
   69|       |
   70|       |    /// The id of the sandbox this snapshot was taken from.
   71|      0|    pub(crate) fn sandbox_id(&self) -> u64 {
   72|      0|        self.sandbox_id
   73|      0|    }
   74|       |
   75|       |    /// Get the mapped regions from this snapshot
   76|      0|    pub(crate) fn regions(&self) -> &[MemoryRegion] {
   77|      0|        &self.regions
   78|      0|    }
   79|       |
   80|       |    /// Return the size of the snapshot in bytes.
   81|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   82|      0|    pub(super) fn mem_size(&self) -> usize {
   83|      0|        self.snapshot.len()
   84|      0|    }
   85|       |}
   86|       |
   87|       |#[cfg(test)]
   88|       |mod tests {
   89|       |    use hyperlight_common::mem::PAGE_SIZE_USIZE;
   90|       |
   91|       |    use crate::mem::shared_mem::ExclusiveSharedMemory;
   92|       |
   93|       |    #[test]
   94|      1|    fn restore_replace() {
   95|      1|        let mut data1 = vec![b'a', b'b', b'c'];
   96|  4.09k|        data1.resize_with(PAGE_SIZE_USIZE, || 0);
   97|  4.09k|        let data2 = data1.iter().map(|b| b + 1).collect::<Vec<u8>>();
   98|      1|        let mut gm = ExclusiveSharedMemory::new(PAGE_SIZE_USIZE).unwrap();
   99|      1|        gm.copy_from_slice(data1.as_slice(), 0).unwrap();
  100|      1|        let mut snap = super::SharedMemorySnapshot::new(&mut gm, 0, Vec::new()).unwrap();
  101|      1|        {
  102|      1|            // after the first snapshot is taken, make sure gm has the equivalent
  103|      1|            // of data1
  104|      1|            assert_eq!(data1, gm.copy_all_to_vec().unwrap());
  105|       |        }
  106|       |
  107|       |        {
  108|       |            // modify gm with data2 rather than data1 and restore from
  109|       |            // snapshot. we should have the equivalent of data1 again
  110|      1|            gm.copy_from_slice(data2.as_slice(), 0).unwrap();
  111|      1|            assert_eq!(data2, gm.copy_all_to_vec().unwrap());
  112|      1|            snap.restore_from_snapshot(&mut gm).unwrap();
  113|      1|            assert_eq!(data1, gm.copy_all_to_vec().unwrap());
  114|       |        }
  115|       |        {
  116|       |            // modify gm with data2, then retake the snapshot and restore
  117|       |            // from the new snapshot. we should have the equivalent of data2
  118|      1|            gm.copy_from_slice(data2.as_slice(), 0).unwrap();
  119|      1|            assert_eq!(data2, gm.copy_all_to_vec().unwrap());
  120|      1|            snap.replace_snapshot(&mut gm).unwrap();
  121|      1|            assert_eq!(data2, gm.copy_all_to_vec().unwrap());
  122|      1|            snap.restore_from_snapshot(&mut gm).unwrap();
  123|      1|            assert_eq!(data2, gm.copy_all_to_vec().unwrap());
  124|       |        }
  125|      1|    }
  126|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/mem/shared_mem_tests.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::clone::Clone;
   18|       |use std::cmp::PartialEq;
   19|       |use std::convert::TryFrom;
   20|       |use std::fmt::Debug;
   21|       |use std::mem::size_of;
   22|       |
   23|       |use hyperlight_common::mem::PAGE_SIZE_USIZE;
   24|       |
   25|       |use crate::{Result, log_then_return, new_error};
   26|       |
   27|       |/// A function that knows how to read data of type `T` from a
   28|       |/// `SharedMemory` at a specified offset
   29|       |type ReaderFn<S, T> = dyn Fn(&S, usize) -> Result<T>;
   30|       |/// A function that knows how to write data of type `T` from a
   31|       |/// `SharedMemory` at a specified offset.
   32|       |type WriterFn<S, T> = dyn Fn(&mut S, usize, T) -> Result<()>;
   33|       |
   34|       |/// Run the standard suite of tests for a specified type `U` to write to
   35|       |/// a `SharedMemory` and a specified type `T` to read back out of
   36|       |/// the same `SharedMemory`.
   37|       |///
   38|       |/// It's possible to write one type and read a different type so you
   39|       |/// can write tests involving different type combinations. For example,
   40|       |/// this function is designed such that you can write a `u64` and read the
   41|       |/// 8 `u8`s that make up that `u64` back out.
   42|       |///
   43|       |/// Regardless of which types you choose, they must be `Clone`able,
   44|       |/// `Debug`able, and you must be able to check if `T`, the one returned
   45|       |/// by the `reader`, is equal to `U`, the one accepted by the writer.
   46|    512|pub(super) fn read_write_test_suite<S, T, U, ShmNew: Fn(usize) -> Result<S>>(
   47|    512|    initial_val: U,
   48|    512|    shared_memory_new: ShmNew,
   49|    512|    reader: Box<ReaderFn<S, T>>,
   50|    512|    writer: Box<WriterFn<S, U>>,
   51|    512|) -> Result<()>
   52|    512|where
   53|    512|    T: PartialEq + Debug + Clone + TryFrom<U>,
   54|    512|    U: Debug + Clone,
   55|    512|{
   56|    512|    let mem_size = PAGE_SIZE_USIZE;
   57|    512|    let test_read = |mem_size, offset| {
   58|    512|        let sm = shared_memory_new(mem_size)?;
                                                          ^0
   59|    512|        (reader)(&sm, offset)
   60|    512|    };
   61|       |
   62|  1.02k|    let test_write = |mem_size, offset, val| {
                      ^512
   63|  1.02k|        let mut sm = shared_memory_new(mem_size)?;
                                                              ^0
   64|  1.02k|        (writer)(&mut sm, offset, val)
   65|  1.02k|    };
   66|       |
   67|  2.04k|    let test_write_read = |mem_size, offset: usize, initial_val: U| {
                      ^512
   68|  2.04k|        let mut sm = shared_memory_new(mem_size)?;
                                                              ^0
   69|  2.04k|        writer(&mut sm, offset, initial_val.clone())?;
                                                                  ^512
   70|  1.53k|        let ret_val = reader(&sm, offset)?;
                                                       ^0
   71|       |
   72|  1.53k|        let initial_val_as_t =
   73|  1.53k|            T::try_from(initial_val.clone()).map_err(|_| new_error!("cannot convert types"))?;
                                                                                  ^0                      ^0
   74|  1.53k|        if initial_val_as_t == ret_val {
   75|  1.53k|            Ok(())
   76|       |        } else {
   77|      0|            log_then_return!(
   78|      0|                "(mem_size: {}, offset: {}, val: {:?}), actual returned val = {:?}",
   79|      0|                mem_size,
   80|      0|                offset,
   81|      0|                initial_val,
   82|      0|                ret_val,
   83|      0|            );
   84|       |        }
   85|  2.04k|    };
   86|       |
   87|       |    // write the value to the start of memory, then read it back
   88|    512|    test_write_read(mem_size, 0, initial_val.clone())?;
                                                                   ^0
   89|       |    // write the value to the end of memory then read it back
   90|    512|    test_write_read(mem_size, mem_size - size_of::<T>(), initial_val.clone())?;
                                                                                           ^0
   91|       |    // write the value to the middle of memory, then read it back
   92|    512|    test_write_read(mem_size, mem_size / 2, initial_val.clone())?;
                                                                              ^0
   93|       |    // read a value from the memory at an invalid offset.
   94|    512|    swap_res(test_write_read(mem_size, mem_size * 2, initial_val.clone()))?;
                                                                                        ^0
   95|       |    // write the value to the memory at an invalid offset.
   96|    512|    swap_res(test_write(mem_size, mem_size * 2, initial_val.clone()))?;
                                                                                   ^0
   97|       |    // read a value from the memory beyond the end of the memory.
   98|    512|    swap_res(test_read(mem_size, mem_size))?;
                                                         ^0
   99|       |    // write the value to the memory beyond the end of the memory.
  100|    512|    swap_res(test_write(mem_size, mem_size, initial_val))?;
                                                                       ^0
  101|    512|    Ok(())
  102|    512|}
  103|       |
  104|       |/// Swaps a result's status. If it was passed as an `Ok`, it will be returned
  105|       |/// as an `Err` with a hard-coded error message. If it was passed as an `Err`,
  106|       |/// it will be returned as an `Ok(_)`.
  107|  2.04k|fn swap_res<T>(r: Result<T>) -> Result<()> {
  108|  2.04k|    match r {
  109|       |        Ok(_) => {
  110|      0|            log_then_return!("result was expected to be an error, but wasn't");
  111|       |        }
  112|  2.04k|        Err(_) => Ok(()),
  113|       |    }
  114|  2.04k|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/metrics/mod.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |// Counter metric that counter number of times a guest error occurred
   18|       |pub(crate) static METRIC_GUEST_ERROR: &str = "guest_errors_total";
   19|       |pub(crate) static METRIC_GUEST_ERROR_LABEL_CODE: &str = "code";
   20|       |
   21|       |// Counter metric that counts the number of times a guest function was called due to timing out
   22|       |pub(crate) static METRIC_GUEST_CANCELLATION: &str = "guest_cancellations_total";
   23|       |
   24|       |// Histogram metric that measures the duration of guest function calls
   25|       |#[cfg(feature = "function_call_metrics")]
   26|       |pub(crate) static METRIC_GUEST_FUNC_DURATION: &str = "guest_call_duration_seconds";
   27|       |
   28|       |// Histogram metric that measures the duration of host function calls
   29|       |#[cfg(feature = "function_call_metrics")]
   30|       |pub(crate) static METRIC_HOST_FUNC_DURATION: &str = "host_call_duration_seconds";
   31|       |
   32|       |/// If the the `function_call_metrics` feature is enabled, this function measures
   33|       |/// the time it takes to execute the given closure, and will then emit a guest call metric
   34|       |/// with the given function name.
   35|       |///
   36|       |/// If the feature is not enabled, the given closure is executed without any additional metrics being emitted,
   37|       |/// and the result of the closure is returned directly.
   38|      0|pub(crate) fn maybe_time_and_emit_guest_call<T, F: FnOnce() -> T>(
   39|      0|    #[allow(unused_variables)] name: &str,
   40|      0|    f: F,
   41|      0|) -> T {
   42|      0|    cfg_if::cfg_if! {
   43|      0|        if #[cfg(feature = "function_call_metrics")] {
   44|      0|            use std::time::Instant;
   45|      0|
   46|      0|            let start = Instant::now();
   47|      0|            let result = f();
   48|      0|            let duration = start.elapsed();
   49|      0|
   50|      0|            static LABEL_GUEST_FUNC_NAME: &str = "function_name";
   51|      0|            metrics::histogram!(METRIC_GUEST_FUNC_DURATION, LABEL_GUEST_FUNC_NAME => name.to_string()).record(duration);
   52|      0|            result
   53|      0|        } else {
   54|      0|            f()
   55|      0|        }
   56|      0|    }
   57|      0|}
   58|       |
   59|       |/// If the the `function_call_metrics` feature is enabled, this function measures
   60|       |/// the time it takes to execute the given closure, and will then emit a host call metric
   61|       |/// with the given function name.
   62|       |///
   63|       |/// If the feature is not enabled, the given closure is executed without any additional metrics being emitted,
   64|       |/// and the result of the closure is returned directly.
   65|     23|pub(crate) fn maybe_time_and_emit_host_call<T, F: FnOnce() -> T>(
   66|     23|    #[allow(unused_variables)] name: &str,
   67|     23|    f: F,
   68|     23|) -> T {
   69|     23|    cfg_if::cfg_if! {
   70|     23|        if #[cfg(feature = "function_call_metrics")] {
   71|     23|            use std::time::Instant;
   72|     23|
   73|     23|            let start = Instant::now();
   74|     23|            let result = f();
   75|     23|            let duration = start.elapsed();
   76|     23|
   77|     23|            static LABEL_HOST_FUNC_NAME: &str = "function_name";
   78|     23|            metrics::histogram!(METRIC_HOST_FUNC_DURATION, LABEL_HOST_FUNC_NAME => name.to_string()).record(duration);
   79|     23|            result
   80|     23|        } else {
   81|     23|            f()
   82|     23|        }
   83|     23|    }
   84|     23|}
   85|       |
   86|       |#[cfg(test)]
   87|       |mod tests {
   88|       |    use std::thread;
   89|       |    use std::time::Duration;
   90|       |
   91|       |    use hyperlight_testing::simple_guest_as_string;
   92|       |    use metrics::{Key, with_local_recorder};
   93|       |    use metrics_util::CompositeKey;
   94|       |
   95|       |    use super::*;
   96|       |    use crate::{GuestBinary, UninitializedSandbox};
   97|       |
   98|       |    #[test]
   99|      1|    fn test_metrics_are_emitted() {
  100|      1|        let recorder = metrics_util::debugging::DebuggingRecorder::new();
  101|      1|        let snapshotter = recorder.snapshotter();
  102|      1|        let snapshot = with_local_recorder(&recorder, || {
  103|      1|            let uninit = UninitializedSandbox::new(
  104|      1|                GuestBinary::FilePath(simple_guest_as_string().unwrap()),
  105|      1|                None,
  106|      1|            )
  107|      1|            .unwrap();
  108|      1|
  109|      1|            let mut multi = uninit.evolve().unwrap();
  110|      1|            let interrupt_handle = multi.interrupt_handle();
  111|      1|
  112|      1|            // interrupt the guest function call to "Spin" after 1 second
  113|      1|            let thread = thread::spawn(move || {
  114|      0|                thread::sleep(Duration::from_secs(1));
  115|      0|                assert!(interrupt_handle.kill());
  116|      1|            });
                          ^0
  117|      1|
  118|      1|            multi
  119|      1|                .call::<i32>("PrintOutput", "Hello".to_string())
  120|      1|                .unwrap();
  121|      1|
  122|      1|            multi.call::<i32>("Spin", ()).unwrap_err();
  123|      1|            thread.join().unwrap();
  124|      1|
  125|      1|            snapshotter.snapshot()
  126|      1|        });
  127|      1|
  128|      1|        // Convert snapshot into a hashmap for easier lookup
  129|      1|        #[expect(clippy::mutable_key_type)]
  130|      1|        let snapshot = snapshot.into_hashmap();
  131|      1|
  132|      1|        cfg_if::cfg_if! {
  133|      1|            if #[cfg(feature = "function_call_metrics")] {
  134|      1|                use metrics::Label;
  135|      1|
  136|      1|                let expected_num_metrics = if cfg!(all(feature = "seccomp", target_os = "linux")) {
  137|      1|                    3 // if seccomp enabled, the host call duration metric is emitted on a separate thread which this local recorder doesn't capture
  138|      1|                } else {
  139|      1|                    4
  140|      1|                };
  141|      1|
  142|      1|                // Verify that the histogram metrics are recorded correctly
  143|      1|                assert_eq!(snapshot.len(), expected_num_metrics);
  144|      1|
  145|      1|                // 1. Guest call duration
  146|      1|                let histogram_key = CompositeKey::new(
  147|      1|                    metrics_util::MetricKind::Histogram,
  148|      1|                    Key::from_parts(
  149|      1|                        METRIC_GUEST_FUNC_DURATION,
  150|      1|                        vec![Label::new("function_name", "PrintOutput")],
  151|      1|                    ),
  152|      1|                );
  153|      1|                let histogram_value = &snapshot.get(&histogram_key).unwrap().2;
  154|      1|                assert!(
  155|      1|                    matches!(
  156|      1|                        histogram_value,
  157|      1|                        metrics_util::debugging::DebugValue::Histogram(histogram) if histogram.len() == 1
  158|      1|                    ),
  159|      1|                    "Histogram metric does not match expected value"
  160|      1|                );
  161|      1|
  162|      1|                // 2. Guest cancellation
  163|      1|                let counter_key = CompositeKey::new(
  164|      1|                    metrics_util::MetricKind::Counter,
  165|      1|                    Key::from_name(METRIC_GUEST_CANCELLATION),
  166|      1|                );
  167|      1|                assert_eq!(
  168|      1|                    snapshot.get(&counter_key).unwrap().2,
  169|      1|                    metrics_util::debugging::DebugValue::Counter(1)
  170|      1|                );
  171|      1|
  172|      1|                // 3. Guest call duration
  173|      1|                let histogram_key = CompositeKey::new(
  174|      1|                    metrics_util::MetricKind::Histogram,
  175|      1|                    Key::from_parts(
  176|      1|                        METRIC_GUEST_FUNC_DURATION,
  177|      1|                        vec![Label::new("function_name", "Spin")],
  178|      1|                    ),
  179|      1|                );
  180|      1|                let histogram_value = &snapshot.get(&histogram_key).unwrap().2;
  181|      1|                assert!(
  182|      1|                    matches!(
  183|      1|                        histogram_value,
  184|      1|                        metrics_util::debugging::DebugValue::Histogram(histogram) if histogram.len() == 1
  185|      1|                    ),
  186|      1|                    "Histogram metric does not match expected value"
  187|      1|                );
  188|      1|
  189|      1|                if !cfg!(all(feature = "seccomp", target_os = "linux")) {
  190|      1|                    // 4. Host call duration
  191|      1|                    let histogram_key = CompositeKey::new(
  192|      1|                        metrics_util::MetricKind::Histogram,
  193|      1|                        Key::from_parts(
  194|      1|                            METRIC_HOST_FUNC_DURATION,
  195|      1|                            vec![Label::new("function_name", "HostPrint")],
  196|      1|                        ),
  197|      1|                    );
  198|      1|                    let histogram_value = &snapshot.get(&histogram_key).unwrap().2;
  199|      1|                    assert!(
  200|      1|                        matches!(
  201|      1|                            histogram_value,
  202|      1|                            metrics_util::debugging::DebugValue::Histogram(histogram) if histogram.len() == 1
  203|      1|                        ),
  204|      1|                        "Histogram metric does not match expected value"
  205|      1|                    );
  206|      1|                }
  207|      1|            } else {
  208|      1|                // Verify that the counter metrics are recorded correctly
  209|      1|                assert_eq!(snapshot.len(), 1);
  210|       |
  211|      0|                let counter_key = CompositeKey::new(
  212|      0|                    metrics_util::MetricKind::Counter,
  213|      0|                    Key::from_name(METRIC_GUEST_CANCELLATION),
  214|      0|                );
  215|      0|                assert_eq!(
  216|      0|                    snapshot.get(&counter_key).unwrap().2,
  217|      0|                    metrics_util::debugging::DebugValue::Counter(1)
  218|      0|                );
  219|       |            }
  220|       |        }
  221|      0|    }
  222|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/config.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::cmp::max;
   18|       |use std::time::Duration;
   19|       |
   20|       |#[cfg(target_os = "linux")]
   21|       |use libc::c_int;
   22|       |use tracing::{Span, instrument};
   23|       |
   24|       |use crate::mem::exe::ExeInfo;
   25|       |
   26|       |/// Used for passing debug configuration to a sandbox
   27|       |#[cfg(gdb)]
   28|       |#[derive(Copy, Clone, Debug, Eq, PartialEq)]
   29|       |pub struct DebugInfo {
   30|       |    /// Guest debug port
   31|       |    pub port: u16,
   32|       |}
   33|       |
   34|       |/// The complete set of configuration needed to create a Sandbox
   35|       |#[derive(Copy, Clone, Debug, Eq, PartialEq)]
   36|       |#[repr(C)]
   37|       |pub struct SandboxConfiguration {
   38|       |    /// Guest core dump output directory
   39|       |    /// This field is by default set to true which means the value core dumps will be placed in:
   40|       |    /// - HYPERLIGHT_CORE_DUMP_DIR environment variable if it is set
   41|       |    /// - default value of the temporary directory
   42|       |    ///
   43|       |    /// The core dump files generation can be disabled by setting this field to false.
   44|       |    #[cfg(crashdump)]
   45|       |    guest_core_dump: bool,
   46|       |    /// Guest gdb debug port
   47|       |    #[cfg(gdb)]
   48|       |    guest_debug_info: Option<DebugInfo>,
   49|       |    /// The size of the memory buffer that is made available for Guest Function
   50|       |    /// Definitions
   51|       |    host_function_definition_size: usize,
   52|       |    /// The size of the memory buffer that is made available for input to the
   53|       |    /// Guest Binary
   54|       |    input_data_size: usize,
   55|       |    /// The size of the memory buffer that is made available for input to the
   56|       |    /// Guest Binary
   57|       |    output_data_size: usize,
   58|       |    /// The stack size to use in the guest sandbox. If set to 0, the stack
   59|       |    /// size will be determined from the PE file header.
   60|       |    ///
   61|       |    /// Note: this is a C-compatible struct, so even though this optional
   62|       |    /// field should be represented as an `Option`, that type is not
   63|       |    /// FFI-safe, so it cannot be.
   64|       |    stack_size_override: u64,
   65|       |    /// The heap size to use in the guest sandbox. If set to 0, the heap
   66|       |    /// size will be determined from the PE file header
   67|       |    ///
   68|       |    /// Note: this is a C-compatible struct, so even though this optional
   69|       |    /// field should be represented as an `Option`, that type is not
   70|       |    /// FFI-safe, so it cannot be.
   71|       |    heap_size_override: u64,
   72|       |    /// Delay between interrupt retries. This duration specifies how long to wait
   73|       |    /// between attempts to send signals to the thread running the sandbox's VCPU.
   74|       |    /// Multiple retries may be necessary because signals only interrupt the VCPU
   75|       |    /// thread when the vcpu thread is in kernel space. There's a narrow window during which a
   76|       |    /// signal can be delivered to the thread, but the thread may not yet
   77|       |    /// have entered kernel space.
   78|       |    interrupt_retry_delay: Duration,
   79|       |    /// Offset from `SIGRTMIN` used to determine the signal number for interrupting
   80|       |    /// the VCPU thread. The actual signal sent is `SIGRTMIN + interrupt_vcpu_sigrtmin_offset`.
   81|       |    ///
   82|       |    /// This signal must fall within the valid real-time signal range supported by the host.
   83|       |    ///
   84|       |    /// Note: Since real-time signals can vary across platforms, ensure that the offset
   85|       |    /// results in a signal number that is not already in use by other components of the system.
   86|       |    interrupt_vcpu_sigrtmin_offset: u8,
   87|       |}
   88|       |
   89|       |impl SandboxConfiguration {
   90|       |    /// The default size of input data
   91|       |    pub const DEFAULT_INPUT_SIZE: usize = 0x4000;
   92|       |    /// The minimum size of input data
   93|       |    pub const MIN_INPUT_SIZE: usize = 0x2000;
   94|       |    /// The default size of output data
   95|       |    pub const DEFAULT_OUTPUT_SIZE: usize = 0x4000;
   96|       |    /// The minimum size of output data
   97|       |    pub const MIN_OUTPUT_SIZE: usize = 0x2000;
   98|       |    /// The default size of host function definitionsSET
   99|       |    /// Host function definitions has its own page in memory, in order to be READ-ONLY
  100|       |    /// from a guest's perspective.
  101|       |    pub const DEFAULT_HOST_FUNCTION_DEFINITION_SIZE: usize = 0x1000;
  102|       |    /// The minimum size of host function definitions
  103|       |    pub const MIN_HOST_FUNCTION_DEFINITION_SIZE: usize = 0x1000;
  104|       |    /// The default interrupt retry delay
  105|       |    pub const DEFAULT_INTERRUPT_RETRY_DELAY: Duration = Duration::from_micros(500);
  106|       |    /// The default signal offset from `SIGRTMIN` used to determine the signal number for interrupting
  107|       |    pub const INTERRUPT_VCPU_SIGRTMIN_OFFSET: u8 = 0;
  108|       |
  109|       |    #[allow(clippy::too_many_arguments)]
  110|       |    /// Create a new configuration for a sandbox with the given sizes.
  111|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  112|  1.34k|    fn new(
  113|  1.34k|        input_data_size: usize,
  114|  1.34k|        output_data_size: usize,
  115|  1.34k|        function_definition_size: usize,
  116|  1.34k|        stack_size_override: Option<u64>,
  117|  1.34k|        heap_size_override: Option<u64>,
  118|  1.34k|        interrupt_retry_delay: Duration,
  119|  1.34k|        interrupt_vcpu_sigrtmin_offset: u8,
  120|  1.34k|        #[cfg(gdb)] guest_debug_info: Option<DebugInfo>,
  121|  1.34k|        #[cfg(crashdump)] guest_core_dump: bool,
  122|  1.34k|    ) -> Self {
  123|  1.34k|        Self {
  124|  1.34k|            input_data_size: max(input_data_size, Self::MIN_INPUT_SIZE),
  125|  1.34k|            output_data_size: max(output_data_size, Self::MIN_OUTPUT_SIZE),
  126|  1.34k|            host_function_definition_size: max(
  127|  1.34k|                function_definition_size,
  128|  1.34k|                Self::MIN_HOST_FUNCTION_DEFINITION_SIZE,
  129|  1.34k|            ),
  130|  1.34k|            stack_size_override: stack_size_override.unwrap_or(0),
  131|  1.34k|            heap_size_override: heap_size_override.unwrap_or(0),
  132|  1.34k|            interrupt_retry_delay,
  133|  1.34k|            interrupt_vcpu_sigrtmin_offset,
  134|  1.34k|            #[cfg(gdb)]
  135|  1.34k|            guest_debug_info,
  136|  1.34k|            #[cfg(crashdump)]
  137|  1.34k|            guest_core_dump,
  138|  1.34k|        }
  139|  1.34k|    }
  140|       |
  141|       |    /// Set the size of the memory buffer that is made available for serialising host function definitions
  142|       |    /// the minimum value is MIN_HOST_FUNCTION_DEFINITION_SIZE
  143|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  144|    257|    pub fn set_host_function_definition_size(&mut self, host_function_definition_size: usize) {
  145|    257|        self.host_function_definition_size = max(
  146|    257|            host_function_definition_size,
  147|    257|            Self::MIN_HOST_FUNCTION_DEFINITION_SIZE,
  148|    257|        );
  149|    257|    }
  150|       |
  151|       |    /// Set the size of the memory buffer that is made available for input to the guest
  152|       |    /// the minimum value is MIN_INPUT_SIZE
  153|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  154|    258|    pub fn set_input_data_size(&mut self, input_data_size: usize) {
  155|    258|        self.input_data_size = max(input_data_size, Self::MIN_INPUT_SIZE);
  156|    258|    }
  157|       |
  158|       |    /// Set the size of the memory buffer that is made available for output from the guest
  159|       |    /// the minimum value is MIN_OUTPUT_SIZE
  160|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  161|    258|    pub fn set_output_data_size(&mut self, output_data_size: usize) {
  162|    258|        self.output_data_size = max(output_data_size, Self::MIN_OUTPUT_SIZE);
  163|    258|    }
  164|       |
  165|       |    /// Set the stack size to use in the guest sandbox. If set to 0, the stack size will be determined from the PE file header
  166|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  167|    258|    pub fn set_stack_size(&mut self, stack_size: u64) {
  168|    258|        self.stack_size_override = stack_size;
  169|    258|    }
  170|       |
  171|       |    /// Set the heap size to use in the guest sandbox. If set to 0, the heap size will be determined from the PE file header
  172|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  173|    258|    pub fn set_heap_size(&mut self, heap_size: u64) {
  174|    258|        self.heap_size_override = heap_size;
  175|    258|    }
  176|       |
  177|       |    /// Sets the interrupt retry delay
  178|       |    #[cfg(target_os = "linux")]
  179|      1|    pub fn set_interrupt_retry_delay(&mut self, delay: Duration) {
  180|      1|        self.interrupt_retry_delay = delay;
  181|      1|    }
  182|       |
  183|       |    /// Get the delay between retries for interrupts
  184|       |    #[cfg(target_os = "linux")]
  185|      0|    pub fn get_interrupt_retry_delay(&self) -> Duration {
  186|      0|        self.interrupt_retry_delay
  187|      0|    }
  188|       |
  189|       |    /// Get the signal offset from `SIGRTMIN` used to determine the signal number for interrupting the VCPU thread
  190|       |    #[cfg(target_os = "linux")]
  191|      0|    pub fn get_interrupt_vcpu_sigrtmin_offset(&self) -> u8 {
  192|      0|        self.interrupt_vcpu_sigrtmin_offset
  193|      0|    }
  194|       |
  195|       |    /// Sets the offset from `SIGRTMIN` to determine the real-time signal used for
  196|       |    /// interrupting the VCPU thread.
  197|       |    ///
  198|       |    /// The final signal number is computed as `SIGRTMIN + offset`, and it must fall within
  199|       |    /// the valid range of real-time signals supported by the host system.
  200|       |    ///
  201|       |    /// Returns Ok(()) if the offset is valid, or an error if it exceeds the maximum real-time signal number.
  202|       |    #[cfg(target_os = "linux")]
  203|      1|    pub fn set_interrupt_vcpu_sigrtmin_offset(&mut self, offset: u8) -> crate::Result<()> {
  204|      1|        if libc::SIGRTMIN() + offset as c_int > libc::SIGRTMAX() {
  205|      0|            return Err(crate::new_error!(
  206|      0|                "Invalid SIGRTMIN offset: {}. It exceeds the maximum real-time signal number.",
  207|      0|                offset
  208|      0|            ));
  209|      1|        }
  210|      1|        self.interrupt_vcpu_sigrtmin_offset = offset;
  211|      1|        Ok(())
  212|      1|    }
  213|       |
  214|       |    /// Toggles the guest core dump generation for a sandbox
  215|       |    /// Setting this to false disables the core dump generation
  216|       |    /// This is only used when the `crashdump` feature is enabled
  217|       |    #[cfg(crashdump)]
  218|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  219|       |    pub fn set_guest_core_dump(&mut self, enable: bool) {
  220|       |        self.guest_core_dump = enable;
  221|       |    }
  222|       |
  223|       |    /// Sets the configuration for the guest debug
  224|       |    #[cfg(gdb)]
  225|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  226|       |    pub fn set_guest_debug_info(&mut self, debug_info: DebugInfo) {
  227|       |        self.guest_debug_info = Some(debug_info);
  228|       |    }
  229|       |
  230|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  231|    571|    pub(crate) fn get_host_function_definition_size(&self) -> usize {
  232|    571|        self.host_function_definition_size
  233|    571|    }
  234|       |
  235|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  236|    571|    pub(crate) fn get_input_data_size(&self) -> usize {
  237|    571|        self.input_data_size
  238|    571|    }
  239|       |
  240|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  241|    571|    pub(crate) fn get_output_data_size(&self) -> usize {
  242|    571|        self.output_data_size
  243|    571|    }
  244|       |
  245|       |    #[cfg(crashdump)]
  246|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  247|       |    pub(crate) fn get_guest_core_dump(&self) -> bool {
  248|       |        self.guest_core_dump
  249|       |    }
  250|       |
  251|       |    #[cfg(gdb)]
  252|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  253|       |    pub(crate) fn get_guest_debug_info(&self) -> Option<DebugInfo> {
  254|       |        self.guest_debug_info
  255|       |    }
  256|       |
  257|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  258|     66|    fn stack_size_override_opt(&self) -> Option<u64> {
  259|     66|        (self.stack_size_override > 0).then_some(self.stack_size_override)
  260|     66|    }
  261|       |
  262|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  263|     66|    fn heap_size_override_opt(&self) -> Option<u64> {
  264|     66|        (self.heap_size_override > 0).then_some(self.heap_size_override)
  265|     66|    }
  266|       |
  267|       |    /// If self.stack_size is non-zero, return it. Otherwise,
  268|       |    /// return exe_info.stack_reserve()
  269|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  270|     66|    pub(crate) fn get_stack_size(&self, exe_info: &ExeInfo) -> u64 {
  271|     66|        self.stack_size_override_opt()
  272|     66|            .unwrap_or_else(|| exe_info.stack_reserve())
                                             ^63
  273|     66|    }
  274|       |
  275|       |    /// If self.heap_size_override is non-zero, return it. Otherwise,
  276|       |    /// return exe_info.heap_reserve()
  277|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  278|     66|    pub(crate) fn get_heap_size(&self, exe_info: &ExeInfo) -> u64 {
  279|     66|        self.heap_size_override_opt()
  280|     66|            .unwrap_or_else(|| exe_info.heap_reserve())
                                             ^63
  281|     66|    }
  282|       |}
  283|       |
  284|       |impl Default for SandboxConfiguration {
  285|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
  286|  1.34k|    fn default() -> Self {
  287|  1.34k|        Self::new(
  288|  1.34k|            Self::DEFAULT_INPUT_SIZE,
  289|  1.34k|            Self::DEFAULT_OUTPUT_SIZE,
  290|  1.34k|            Self::DEFAULT_HOST_FUNCTION_DEFINITION_SIZE,
  291|  1.34k|            None,
  292|  1.34k|            None,
  293|  1.34k|            Self::DEFAULT_INTERRUPT_RETRY_DELAY,
  294|  1.34k|            Self::INTERRUPT_VCPU_SIGRTMIN_OFFSET,
  295|  1.34k|            #[cfg(gdb)]
  296|  1.34k|            None,
  297|  1.34k|            #[cfg(crashdump)]
  298|  1.34k|            true,
  299|  1.34k|        )
  300|  1.34k|    }
  301|       |}
  302|       |
  303|       |#[cfg(test)]
  304|       |mod tests {
  305|       |    use super::SandboxConfiguration;
  306|       |    use crate::testing::simple_guest_exe_info;
  307|       |
  308|       |    #[test]
  309|      1|    fn overrides() {
  310|       |        const STACK_SIZE_OVERRIDE: u64 = 0x10000;
  311|       |        const HEAP_SIZE_OVERRIDE: u64 = 0x50000;
  312|       |        const INPUT_DATA_SIZE_OVERRIDE: usize = 0x4000;
  313|       |        const OUTPUT_DATA_SIZE_OVERRIDE: usize = 0x4001;
  314|       |        const HOST_FUNCTION_DEFINITION_SIZE_OVERRIDE: usize = 0x4002;
  315|      1|        let mut cfg = SandboxConfiguration::new(
  316|      1|            INPUT_DATA_SIZE_OVERRIDE,
  317|      1|            OUTPUT_DATA_SIZE_OVERRIDE,
  318|      1|            HOST_FUNCTION_DEFINITION_SIZE_OVERRIDE,
  319|      1|            Some(STACK_SIZE_OVERRIDE),
  320|      1|            Some(HEAP_SIZE_OVERRIDE),
  321|      1|            SandboxConfiguration::DEFAULT_INTERRUPT_RETRY_DELAY,
  322|      1|            SandboxConfiguration::INTERRUPT_VCPU_SIGRTMIN_OFFSET,
  323|      1|            #[cfg(gdb)]
  324|      1|            None,
  325|      1|            #[cfg(crashdump)]
  326|      1|            true,
  327|      1|        );
  328|      1|        let exe_info = simple_guest_exe_info().unwrap();
  329|      1|
  330|      1|        let stack_size = cfg.get_stack_size(&exe_info);
  331|      1|        let heap_size = cfg.get_heap_size(&exe_info);
  332|      1|        assert_eq!(STACK_SIZE_OVERRIDE, stack_size);
  333|      1|        assert_eq!(HEAP_SIZE_OVERRIDE, heap_size);
  334|       |
  335|      1|        cfg.stack_size_override = 1024;
  336|      1|        cfg.heap_size_override = 2048;
  337|      1|        assert_eq!(1024, cfg.stack_size_override);
  338|      1|        assert_eq!(2048, cfg.heap_size_override);
  339|      1|        assert_eq!(INPUT_DATA_SIZE_OVERRIDE, cfg.input_data_size);
  340|      1|        assert_eq!(OUTPUT_DATA_SIZE_OVERRIDE, cfg.output_data_size);
  341|      1|        assert_eq!(
  342|      1|            HOST_FUNCTION_DEFINITION_SIZE_OVERRIDE,
  343|      1|            cfg.host_function_definition_size
  344|      1|        );
  345|      1|    }
  346|       |
  347|       |    #[test]
  348|      1|    fn min_sizes() {
  349|      1|        let mut cfg = SandboxConfiguration::new(
  350|      1|            SandboxConfiguration::MIN_INPUT_SIZE - 1,
  351|      1|            SandboxConfiguration::MIN_OUTPUT_SIZE - 1,
  352|      1|            SandboxConfiguration::MIN_HOST_FUNCTION_DEFINITION_SIZE - 1,
  353|      1|            None,
  354|      1|            None,
  355|      1|            SandboxConfiguration::DEFAULT_INTERRUPT_RETRY_DELAY,
  356|      1|            SandboxConfiguration::INTERRUPT_VCPU_SIGRTMIN_OFFSET,
  357|      1|            #[cfg(gdb)]
  358|      1|            None,
  359|      1|            #[cfg(crashdump)]
  360|      1|            true,
  361|      1|        );
  362|      1|        assert_eq!(SandboxConfiguration::MIN_INPUT_SIZE, cfg.input_data_size);
  363|      1|        assert_eq!(SandboxConfiguration::MIN_OUTPUT_SIZE, cfg.output_data_size);
  364|      1|        assert_eq!(
  365|      1|            SandboxConfiguration::MIN_HOST_FUNCTION_DEFINITION_SIZE,
  366|      1|            cfg.host_function_definition_size
  367|      1|        );
  368|      1|        assert_eq!(0, cfg.stack_size_override);
  369|      1|        assert_eq!(0, cfg.heap_size_override);
  370|       |
  371|      1|        cfg.set_input_data_size(SandboxConfiguration::MIN_INPUT_SIZE - 1);
  372|      1|        cfg.set_output_data_size(SandboxConfiguration::MIN_OUTPUT_SIZE - 1);
  373|      1|        cfg.set_host_function_definition_size(
  374|      1|            SandboxConfiguration::MIN_HOST_FUNCTION_DEFINITION_SIZE - 1,
  375|      1|        );
  376|      1|
  377|      1|        assert_eq!(SandboxConfiguration::MIN_INPUT_SIZE, cfg.input_data_size);
  378|      1|        assert_eq!(SandboxConfiguration::MIN_OUTPUT_SIZE, cfg.output_data_size);
  379|      1|        assert_eq!(
  380|      1|            SandboxConfiguration::MIN_HOST_FUNCTION_DEFINITION_SIZE,
  381|      1|            cfg.host_function_definition_size
  382|      1|        );
  383|      1|    }
  384|       |
  385|       |    mod proptests {
  386|       |        use proptest::prelude::*;
  387|       |
  388|       |        use super::SandboxConfiguration;
  389|       |        #[cfg(gdb)]
  390|       |        use crate::sandbox::config::DebugInfo;
  391|       |
  392|       |        proptest! {
  393|       |            #[test]
  394|       |            fn input_data_size(size in SandboxConfiguration::MIN_INPUT_SIZE..=SandboxConfiguration::MIN_INPUT_SIZE * 10) {
  395|       |                let mut cfg = SandboxConfiguration::default();
  396|       |                cfg.set_input_data_size(size);
  397|       |                prop_assert_eq!(size, cfg.get_input_data_size());
  398|       |            }
  399|       |
  400|       |            #[test]
  401|       |            fn output_data_size(size in SandboxConfiguration::MIN_OUTPUT_SIZE..=SandboxConfiguration::MIN_OUTPUT_SIZE * 10) {
  402|       |                let mut cfg = SandboxConfiguration::default();
  403|       |                cfg.set_output_data_size(size);
  404|       |                prop_assert_eq!(size, cfg.get_output_data_size());
  405|       |            }
  406|       |
  407|       |            #[test]
  408|       |            fn host_function_definition_size(size in SandboxConfiguration::MIN_HOST_FUNCTION_DEFINITION_SIZE..=SandboxConfiguration::MIN_HOST_FUNCTION_DEFINITION_SIZE * 10) {
  409|       |                let mut cfg = SandboxConfiguration::default();
  410|       |                cfg.set_host_function_definition_size(size);
  411|       |                prop_assert_eq!(size, cfg.get_host_function_definition_size());
  412|       |            }
  413|       |
  414|       |            #[test]
  415|       |            fn stack_size_override(size in 0x1000..=0x10000u64) {
  416|       |                let mut cfg = SandboxConfiguration::default();
  417|       |                cfg.set_stack_size(size);
  418|       |                prop_assert_eq!(size, cfg.stack_size_override);
  419|       |            }
  420|       |
  421|       |            #[test]
  422|       |            fn heap_size_override(size in 0x1000..=0x10000u64) {
  423|       |                let mut cfg = SandboxConfiguration::default();
  424|       |                cfg.set_heap_size(size);
  425|       |                prop_assert_eq!(size, cfg.heap_size_override);
  426|       |            }
  427|       |
  428|       |            #[test]
  429|       |            #[cfg(gdb)]
  430|       |            fn guest_debug_info(port in 9000..=u16::MAX) {
  431|       |                let mut cfg = SandboxConfiguration::default();
  432|       |                let debug_info = DebugInfo { port };
  433|       |                cfg.set_guest_debug_info(debug_info);
  434|       |                prop_assert_eq!(debug_info, *cfg.get_guest_debug_info().as_ref().unwrap());
  435|       |            }
  436|       |        }
  437|       |    }
  438|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/host_funcs.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::collections::HashMap;
   18|       |use std::io::{IsTerminal, Write};
   19|       |
   20|       |use hyperlight_common::flatbuffer_wrappers::function_types::{
   21|       |    ParameterType, ParameterValue, ReturnType, ReturnValue,
   22|       |};
   23|       |use hyperlight_common::flatbuffer_wrappers::host_function_definition::HostFunctionDefinition;
   24|       |use hyperlight_common::flatbuffer_wrappers::host_function_details::HostFunctionDetails;
   25|       |use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};
   26|       |use tracing::{Span, instrument};
   27|       |
   28|       |use super::ExtraAllowedSyscall;
   29|       |use crate::HyperlightError::HostFunctionNotFound;
   30|       |use crate::func::host_functions::TypeErasedHostFunction;
   31|       |use crate::mem::mgr::SandboxMemoryManager;
   32|       |use crate::mem::shared_mem::ExclusiveSharedMemory;
   33|       |use crate::{Result, new_error};
   34|       |
   35|       |#[derive(Default)]
   36|       |/// A Wrapper around details of functions exposed by the Host
   37|       |pub struct FunctionRegistry {
   38|       |    functions_map: HashMap<String, FunctionEntry>,
   39|       |}
   40|       |
   41|       |impl From<&mut FunctionRegistry> for HostFunctionDetails {
   42|     71|    fn from(registry: &mut FunctionRegistry) -> Self {
   43|     71|        let host_functions = registry
   44|     71|            .functions_map
   45|     71|            .iter()
   46|     75|            .map(|(name, entry)| HostFunctionDefinition {
   47|     75|                function_name: name.clone(),
   48|     75|                parameter_types: Some(entry.parameter_types.to_vec()),
   49|     75|                return_type: entry.return_type,
   50|     75|            })
   51|     71|            .collect();
   52|     71|
   53|     71|        HostFunctionDetails {
   54|     71|            host_functions: Some(host_functions),
   55|     71|        }
   56|     71|    }
   57|       |}
   58|       |
   59|       |pub struct FunctionEntry {
   60|       |    pub function: TypeErasedHostFunction,
   61|       |    pub extra_allowed_syscalls: Option<Vec<ExtraAllowedSyscall>>,
   62|       |    pub parameter_types: &'static [ParameterType],
   63|       |    pub return_type: ReturnType,
   64|       |}
   65|       |
   66|       |impl FunctionRegistry {
   67|       |    /// Register a host function with the sandbox.
   68|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
   69|     71|    pub(crate) fn register_host_function(
   70|     71|        &mut self,
   71|     71|        name: String,
   72|     71|        func: FunctionEntry,
   73|     71|        mgr: &mut SandboxMemoryManager<ExclusiveSharedMemory>,
   74|     71|    ) -> Result<()> {
   75|       |        self.functions_map.insert(name, func);
   76|       |
   77|       |        let hfd = HostFunctionDetails::from(self);
   78|       |
   79|      0|        let buffer: Vec<u8> = (&hfd).try_into().map_err(|e| {
   80|      0|            new_error!(
   81|      0|                "Error serializing host function details to flatbuffer: {}",
   82|      0|                e
   83|      0|            )
   84|      0|        })?;
   85|       |
   86|       |        mgr.write_buffer_host_function_details(&buffer)?;
   87|       |        Ok(())
   88|     71|    }
   89|       |
   90|       |    /// Assuming a host function called `"HostPrint"` exists, and takes a
   91|       |    /// single string parameter, call it with the given `msg` parameter.
   92|       |    ///
   93|       |    /// Return `Ok` if the function was found and was of the right signature,
   94|       |    /// and `Err` otherwise.
   95|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
   96|       |    #[allow(dead_code)]
   97|     23|    pub(super) fn host_print(&mut self, msg: String) -> Result<i32> {
   98|       |        let res = self.call_host_func_impl("HostPrint", vec![ParameterValue::String(msg)])?;
   99|       |        res.try_into()
  100|      0|            .map_err(|_| HostFunctionNotFound("HostPrint".to_string()))
  101|     23|    }
  102|       |    /// From the set of registered host functions, attempt to get the one
  103|       |    /// named `name`. If it exists, call it with the given arguments list
  104|       |    /// `args` and return its result.
  105|       |    ///
  106|       |    /// Return `Err` if no such function exists,
  107|       |    /// its parameter list doesn't match `args`, or there was another error
  108|       |    /// getting, configuring or calling the function.
  109|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  110|      0|    pub(super) fn call_host_function(
  111|      0|        &self,
  112|      0|        name: &str,
  113|      0|        args: Vec<ParameterValue>,
  114|      0|    ) -> Result<ReturnValue> {
  115|       |        self.call_host_func_impl(name, args)
  116|      0|    }
  117|       |
  118|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  119|     23|    fn call_host_func_impl(&self, name: &str, args: Vec<ParameterValue>) -> Result<ReturnValue> {
  120|       |        let FunctionEntry {
  121|       |            function,
  122|       |            extra_allowed_syscalls,
  123|       |            parameter_types: _,
  124|       |            return_type: _,
  125|       |        } = self
  126|       |            .functions_map
  127|       |            .get(name)
  128|      0|            .ok_or_else(|| HostFunctionNotFound(name.to_string()))?;
  129|       |
  130|       |        // Create a new thread when seccomp is enabled on Linux
  131|     23|        maybe_with_seccomp(name, extra_allowed_syscalls.as_deref(), || {
  132|     23|            crate::metrics::maybe_time_and_emit_host_call(name, || function.call(args))
  133|     23|        })
  134|     23|    }
  135|       |}
  136|       |
  137|       |/// The default writer function is to write to stdout with green text.
  138|       |#[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  139|     20|pub(super) fn default_writer_func(s: String) -> Result<i32> {
  140|       |    match std::io::stdout().is_terminal() {
  141|       |        false => {
  142|       |            print!("{}", s);
  143|       |            Ok(s.len() as i32)
  144|       |        }
  145|       |        true => {
  146|       |            let mut stdout = StandardStream::stdout(ColorChoice::Auto);
  147|       |            let mut color_spec = ColorSpec::new();
  148|       |            color_spec.set_fg(Some(Color::Green));
  149|       |            stdout.set_color(&color_spec)?;
  150|       |            stdout.write_all(s.as_bytes())?;
  151|       |            stdout.reset()?;
  152|       |            Ok(s.len() as i32)
  153|       |        }
  154|       |    }
  155|     20|}
  156|       |
  157|       |#[cfg(all(feature = "seccomp", target_os = "linux"))]
  158|     23|fn maybe_with_seccomp<T: Send>(
  159|     23|    name: &str,
  160|     23|    syscalls: Option<&[ExtraAllowedSyscall]>,
  161|     23|    f: impl FnOnce() -> Result<T> + Send,
  162|     23|) -> Result<T> {
  163|       |    use std::thread;
  164|       |
  165|       |    use crate::seccomp::guest::get_seccomp_filter_for_host_function_worker_thread;
  166|       |
  167|       |    // Use a scoped thread so that we can pass around references without having to clone them.
  168|     23|    thread::scope(|s| {
  169|     23|        thread::Builder::new()
  170|     23|            .name(format!("Host Function Worker Thread for: {name:?}"))
  171|     23|            .spawn_scoped(s, move || {
  172|     23|                let seccomp_filter = get_seccomp_filter_for_host_function_worker_thread(syscalls)?;
                                                                                                               ^0
  173|     23|                seccomp_filter
  174|     23|                    .iter()
  175|     46|                    .try_for_each(|filter| seccompiler::apply_filter(filter))?;
                                                                                          ^23^0
  176|       |
  177|       |                // We have a `catch_unwind` here because, if a disallowed syscall is issued,
  178|       |                // we handle it by panicking. This is to avoid returning execution to the
  179|       |                // offending host functionfor two reasons: (1) if a host function is issuing
  180|       |                // disallowed syscalls, it could be unsafe to return to, and (2) returning
  181|       |                // execution after trapping the disallowed syscall can lead to UB (e.g., try
  182|       |                // running a host function that attempts to sleep without `SYS_clock_nanosleep`,
  183|       |                // you'll block the syscall but panic in the aftermath).
  184|     23|                match std::panic::catch_unwind(std::panic::AssertUnwindSafe(f)) {
  185|     23|                    Ok(val) => val,
  186|      0|                    Err(err) => {
  187|      0|                        if let Some(crate::HyperlightError::DisallowedSyscall) =
  188|      0|                            err.downcast_ref::<crate::HyperlightError>()
  189|       |                        {
  190|      0|                            return Err(crate::HyperlightError::DisallowedSyscall);
  191|      0|                        }
  192|      0|
  193|      0|                        crate::log_then_return!("Host function {} panicked", name);
  194|       |                    }
  195|       |                }
  196|     23|            })?
                            ^0
  197|     23|            .join()
  198|     23|            .map_err(|_| new_error!("Error joining thread executing host function"))?
                                                  ^0                                              ^0
  199|     23|    })
  200|     23|}
  201|       |
  202|       |#[cfg(not(all(feature = "seccomp", target_os = "linux")))]
  203|       |fn maybe_with_seccomp<T: Send>(
  204|       |    _name: &str,
  205|       |    _syscalls: Option<&[ExtraAllowedSyscall]>,
  206|       |    f: impl FnOnce() -> Result<T> + Send,
  207|       |) -> Result<T> {
  208|       |    // No seccomp, just call the function
  209|       |    f()
  210|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/hypervisor.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::fmt::Debug;
   18|       |use std::sync::OnceLock;
   19|       |
   20|       |#[cfg(mshv)]
   21|       |use crate::hypervisor::hyperv_linux;
   22|       |#[cfg(kvm)]
   23|       |use crate::hypervisor::kvm;
   24|       |
   25|       |static AVAILABLE_HYPERVISOR: OnceLock<Option<HypervisorType>> = OnceLock::new();
   26|       |
   27|     61|pub fn get_available_hypervisor() -> &'static Option<HypervisorType> {
   28|     61|    AVAILABLE_HYPERVISOR.get_or_init(|| {
   29|      2|        cfg_if::cfg_if! {
   30|      2|            if #[cfg(all(kvm, mshv))] {
   31|      2|                // If both features are enabled, we need to determine hypervisor at runtime.
   32|      2|                // Currently /dev/kvm and /dev/mshv cannot exist on the same machine, so the first one
   33|      2|                // that works is guaranteed to be correct.
   34|      2|                if hyperv_linux::is_hypervisor_present() {
   35|      0|                    Some(HypervisorType::Mshv)
   36|      2|                } else if kvm::is_hypervisor_present() {
   37|      0|                    Some(HypervisorType::Kvm)
   38|       |                } else {
   39|      2|                    None
   40|       |                }
   41|       |            } else if #[cfg(kvm)] {
   42|       |                if kvm::is_hypervisor_present() {
   43|       |                    Some(HypervisorType::Kvm)
   44|       |                } else {
   45|       |                    None
   46|       |                }
   47|       |            } else if #[cfg(mshv)] {
   48|       |                if hyperv_linux::is_hypervisor_present() {
   49|       |                    Some(HypervisorType::Mshv)
   50|       |                } else {
   51|       |                    None
   52|       |                }
   53|       |            } else if #[cfg(target_os = "windows")] {
   54|       |                use crate::sandbox::windows_hypervisor_platform;
   55|       |
   56|       |                if windows_hypervisor_platform::is_hypervisor_present() {
   57|       |                    Some(HypervisorType::Whp)
   58|       |                } else {
   59|       |                    None
   60|       |                }
   61|       |            } else {
   62|       |                None
   63|       |            }
   64|       |        }
   65|     61|    })
                  ^2
   66|     61|}
   67|       |
   68|       |/// The hypervisor types available for the current platform
   69|       |#[derive(PartialEq, Eq, Debug)]
   70|       |pub(crate) enum HypervisorType {
   71|       |    #[cfg(kvm)]
   72|       |    Kvm,
   73|       |
   74|       |    #[cfg(mshv)]
   75|       |    Mshv,
   76|       |
   77|       |    #[cfg(target_os = "windows")]
   78|       |    Whp,
   79|       |}
   80|       |
   81|       |// Compiler error if no hypervisor type is available
   82|       |#[cfg(not(any(kvm, mshv, target_os = "windows")))]
   83|       |compile_error!(
   84|       |    "No hypervisor type is available for the current platform. Please enable either the `kvm` or `mshv` cargo feature."
   85|       |);

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/initialized_multi_use.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::collections::HashSet;
   18|       |#[cfg(unix)]
   19|       |use std::os::fd::AsRawFd;
   20|       |#[cfg(unix)]
   21|       |use std::os::linux::fs::MetadataExt;
   22|       |use std::path::Path;
   23|       |use std::sync::atomic::{AtomicU64, Ordering};
   24|       |use std::sync::{Arc, Mutex};
   25|       |
   26|       |use flatbuffers::FlatBufferBuilder;
   27|       |use hyperlight_common::flatbuffer_wrappers::function_call::{FunctionCall, FunctionCallType};
   28|       |use hyperlight_common::flatbuffer_wrappers::function_types::{
   29|       |    ParameterValue, ReturnType, ReturnValue,
   30|       |};
   31|       |use hyperlight_common::flatbuffer_wrappers::util::estimate_flatbuffer_capacity;
   32|       |use tracing::{Span, instrument};
   33|       |
   34|       |use super::host_funcs::FunctionRegistry;
   35|       |use super::snapshot::Snapshot;
   36|       |use super::{Callable, MemMgrWrapper, WrapperGetter};
   37|       |use crate::HyperlightError::SnapshotSandboxMismatch;
   38|       |use crate::func::guest_err::check_for_guest_error;
   39|       |use crate::func::{ParameterTuple, SupportedReturnType};
   40|       |#[cfg(gdb)]
   41|       |use crate::hypervisor::handlers::DbgMemAccessHandlerWrapper;
   42|       |use crate::hypervisor::{Hypervisor, InterruptHandle};
   43|       |#[cfg(unix)]
   44|       |use crate::mem::memory_region::MemoryRegionType;
   45|       |use crate::mem::memory_region::{MemoryRegion, MemoryRegionFlags};
   46|       |use crate::mem::ptr::RawPtr;
   47|       |use crate::mem::shared_mem::HostSharedMemory;
   48|       |use crate::metrics::maybe_time_and_emit_guest_call;
   49|       |use crate::{Result, log_then_return};
   50|       |
   51|       |/// Global counter for assigning unique IDs to sandboxes
   52|       |static SANDBOX_ID_COUNTER: AtomicU64 = AtomicU64::new(0);
   53|       |
   54|       |/// A fully initialized sandbox that can execute guest functions multiple times.
   55|       |///
   56|       |/// Guest functions can be called repeatedly while maintaining state between calls.
   57|       |/// The sandbox supports creating snapshots and restoring to previous states.
   58|       |pub struct MultiUseSandbox {
   59|       |    /// Unique identifier for this sandbox instance
   60|       |    id: u64,
   61|       |    // We need to keep a reference to the host functions, even if the compiler marks it as unused. The compiler cannot detect our dynamic usages of the host function in `HyperlightFunction::call`.
   62|       |    pub(super) _host_funcs: Arc<Mutex<FunctionRegistry>>,
   63|       |    pub(crate) mem_mgr: MemMgrWrapper<HostSharedMemory>,
   64|       |    vm: Box<dyn Hypervisor>,
   65|       |    dispatch_ptr: RawPtr,
   66|       |    #[cfg(gdb)]
   67|       |    dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
   68|       |    /// If the current state of the sandbox has been captured in a snapshot,
   69|       |    /// that snapshot is stored here.
   70|       |    snapshot: Option<Snapshot>,
   71|       |}
   72|       |
   73|       |impl MultiUseSandbox {
   74|       |    /// Move an `UninitializedSandbox` into a new `MultiUseSandbox` instance.
   75|       |    ///
   76|       |    /// This function is not equivalent to doing an `evolve` from uninitialized
   77|       |    /// to initialized, and is purposely not exposed publicly outside the crate
   78|       |    /// (as a `From` implementation would be)
   79|       |    #[instrument(skip_all, parent = Span::current(), level = "Trace")]
   80|      0|    pub(super) fn from_uninit(
   81|      0|        host_funcs: Arc<Mutex<FunctionRegistry>>,
   82|      0|        mgr: MemMgrWrapper<HostSharedMemory>,
   83|      0|        vm: Box<dyn Hypervisor>,
   84|      0|        dispatch_ptr: RawPtr,
   85|      0|        #[cfg(gdb)] dbg_mem_access_fn: DbgMemAccessHandlerWrapper,
   86|      0|    ) -> MultiUseSandbox {
   87|      0|        Self {
   88|      0|            id: SANDBOX_ID_COUNTER.fetch_add(1, Ordering::Relaxed),
   89|      0|            _host_funcs: host_funcs,
   90|      0|            mem_mgr: mgr,
   91|      0|            vm,
   92|      0|            dispatch_ptr,
   93|      0|            #[cfg(gdb)]
   94|      0|            dbg_mem_access_fn,
   95|      0|            snapshot: None,
   96|      0|        }
   97|      0|    }
   98|       |
   99|       |    /// Creates a snapshot of the sandbox's current memory state.
  100|       |    ///
  101|       |    /// The snapshot is tied to this specific sandbox instance and can only be
  102|       |    /// restored to the same sandbox it was created from.
  103|       |    ///
  104|       |    /// # Examples
  105|       |    ///
  106|       |    /// ```no_run
  107|       |    /// # use hyperlight_host::{MultiUseSandbox, UninitializedSandbox, GuestBinary};
  108|       |    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
  109|       |    /// let mut sandbox: MultiUseSandbox = UninitializedSandbox::new(
  110|       |    ///     GuestBinary::FilePath("guest.bin".into()),
  111|       |    ///     None
  112|       |    /// )?.evolve()?;
  113|       |    ///
  114|       |    /// // Modify sandbox state
  115|       |    /// sandbox.call_guest_function_by_name::<i32>("SetValue", 42)?;
  116|       |    ///
  117|       |    /// // Create snapshot belonging to this sandbox
  118|       |    /// let snapshot = sandbox.snapshot()?;
  119|       |    /// # Ok(())
  120|       |    /// # }
  121|       |    /// ```
  122|       |    #[instrument(err(Debug), skip_all, parent = Span::current())]
  123|      0|    pub fn snapshot(&mut self) -> Result<Snapshot> {
  124|       |        if let Some(snapshot) = &self.snapshot {
  125|       |            return Ok(snapshot.clone());
  126|       |        }
  127|       |        let mapped_regions_iter = self.vm.get_mapped_regions();
  128|       |        let mapped_regions_vec: Vec<MemoryRegion> = mapped_regions_iter.cloned().collect();
  129|       |        let memory_snapshot = self
  130|       |            .mem_mgr
  131|       |            .unwrap_mgr_mut()
  132|       |            .snapshot(self.id, mapped_regions_vec)?;
  133|       |        let inner = Arc::new(memory_snapshot);
  134|       |        let snapshot = Snapshot { inner };
  135|       |        self.snapshot = Some(snapshot.clone());
  136|       |        Ok(snapshot)
  137|      0|    }
  138|       |
  139|       |    /// Restores the sandbox's memory to a previously captured snapshot state.
  140|       |    ///
  141|       |    /// The snapshot must have been created from this same sandbox instance.
  142|       |    /// Attempting to restore a snapshot from a different sandbox will return
  143|       |    /// a [`SnapshotSandboxMismatch`](crate::HyperlightError::SnapshotSandboxMismatch) error.
  144|       |    ///
  145|       |    /// # Examples
  146|       |    ///
  147|       |    /// ```no_run
  148|       |    /// # use hyperlight_host::{MultiUseSandbox, UninitializedSandbox, GuestBinary};
  149|       |    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
  150|       |    /// let mut sandbox: MultiUseSandbox = UninitializedSandbox::new(
  151|       |    ///     GuestBinary::FilePath("guest.bin".into()),
  152|       |    ///     None
  153|       |    /// )?.evolve()?;
  154|       |    ///
  155|       |    /// // Take initial snapshot from this sandbox
  156|       |    /// let snapshot = sandbox.snapshot()?;
  157|       |    ///
  158|       |    /// // Modify sandbox state
  159|       |    /// sandbox.call_guest_function_by_name::<i32>("SetValue", 100)?;
  160|       |    /// let value: i32 = sandbox.call_guest_function_by_name("GetValue", ())?;
  161|       |    /// assert_eq!(value, 100);
  162|       |    ///
  163|       |    /// // Restore to previous state (same sandbox)
  164|       |    /// sandbox.restore(&snapshot)?;
  165|       |    /// let restored_value: i32 = sandbox.call_guest_function_by_name("GetValue", ())?;
  166|       |    /// assert_eq!(restored_value, 0); // Back to initial state
  167|       |    /// # Ok(())
  168|       |    /// # }
  169|       |    /// ```
  170|       |    #[instrument(err(Debug), skip_all, parent = Span::current())]
  171|      0|    pub fn restore(&mut self, snapshot: &Snapshot) -> Result<()> {
  172|       |        if let Some(snap) = &self.snapshot {
  173|       |            if Arc::ptr_eq(&snap.inner, &snapshot.inner) {
  174|       |                // If the snapshot is already the current one, no need to restore
  175|       |                return Ok(());
  176|       |            }
  177|       |        }
  178|       |
  179|       |        if self.id != snapshot.inner.sandbox_id() {
  180|       |            return Err(SnapshotSandboxMismatch);
  181|       |        }
  182|       |
  183|       |        self.mem_mgr
  184|       |            .unwrap_mgr_mut()
  185|       |            .restore_snapshot(&snapshot.inner)?;
  186|       |
  187|       |        let current_regions: HashSet<_> = self.vm.get_mapped_regions().cloned().collect();
  188|       |        let snapshot_regions: HashSet<_> = snapshot.inner.regions().iter().cloned().collect();
  189|       |
  190|       |        let regions_to_unmap = current_regions.difference(&snapshot_regions);
  191|       |        let regions_to_map = snapshot_regions.difference(&current_regions);
  192|       |
  193|       |        for region in regions_to_unmap {
  194|       |            unsafe { self.vm.unmap_region(region)? };
  195|       |        }
  196|       |
  197|       |        for region in regions_to_map {
  198|       |            unsafe { self.vm.map_region(region)? };
  199|       |        }
  200|       |
  201|       |        // The restored snapshot is now our most current snapshot
  202|       |        self.snapshot = Some(snapshot.clone());
  203|       |
  204|       |        Ok(())
  205|      0|    }
  206|       |
  207|       |    /// Calls a guest function by name with the specified arguments.
  208|       |    ///
  209|       |    /// Changes made to the sandbox during execution are *not* persisted.
  210|       |    ///
  211|       |    /// # Examples
  212|       |    ///
  213|       |    /// ```no_run
  214|       |    /// # use hyperlight_host::{MultiUseSandbox, UninitializedSandbox, GuestBinary};
  215|       |    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
  216|       |    /// let mut sandbox: MultiUseSandbox = UninitializedSandbox::new(
  217|       |    ///     GuestBinary::FilePath("guest.bin".into()),
  218|       |    ///     None
  219|       |    /// )?.evolve()?;
  220|       |    ///
  221|       |    /// // Call function with no arguments
  222|       |    /// let result: i32 = sandbox.call_guest_function_by_name("GetCounter", ())?;
  223|       |    ///
  224|       |    /// // Call function with single argument
  225|       |    /// let doubled: i32 = sandbox.call_guest_function_by_name("Double", 21)?;
  226|       |    /// assert_eq!(doubled, 42);
  227|       |    ///
  228|       |    /// // Call function with multiple arguments
  229|       |    /// let sum: i32 = sandbox.call_guest_function_by_name("Add", (10, 32))?;
  230|       |    /// assert_eq!(sum, 42);
  231|       |    ///
  232|       |    /// // Call function returning string
  233|       |    /// let message: String = sandbox.call_guest_function_by_name("Echo", "Hello, World!".to_string())?;
  234|       |    /// assert_eq!(message, "Hello, World!");
  235|       |    /// # Ok(())
  236|       |    /// # }
  237|       |    /// ```
  238|       |    #[doc(hidden)]
  239|       |    #[deprecated(
  240|       |        since = "0.8.0",
  241|       |        note = "Deprecated in favour of call and snapshot/restore."
  242|       |    )]
  243|       |    #[instrument(err(Debug), skip(self, args), parent = Span::current())]
  244|      0|    pub fn call_guest_function_by_name<Output: SupportedReturnType>(
  245|      0|        &mut self,
  246|      0|        func_name: &str,
  247|      0|        args: impl ParameterTuple,
  248|      0|    ) -> Result<Output> {
  249|       |        let snapshot = self.snapshot()?;
  250|       |        let res = self.call(func_name, args);
  251|       |        self.restore(&snapshot)?;
  252|       |        res
  253|      0|    }
  254|       |
  255|       |    /// Calls a guest function by name with the specified arguments.
  256|       |    ///
  257|       |    /// Changes made to the sandbox during execution are persisted.
  258|       |    ///
  259|       |    /// # Examples
  260|       |    ///
  261|       |    /// ```no_run
  262|       |    /// # use hyperlight_host::{MultiUseSandbox, UninitializedSandbox, GuestBinary};
  263|       |    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
  264|       |    /// let mut sandbox: MultiUseSandbox = UninitializedSandbox::new(
  265|       |    ///     GuestBinary::FilePath("guest.bin".into()),
  266|       |    ///     None
  267|       |    /// )?.evolve()?;
  268|       |    ///
  269|       |    /// // Call function with no arguments
  270|       |    /// let result: i32 = sandbox.call("GetCounter", ())?;
  271|       |    ///
  272|       |    /// // Call function with single argument
  273|       |    /// let doubled: i32 = sandbox.call("Double", 21)?;
  274|       |    /// assert_eq!(doubled, 42);
  275|       |    ///
  276|       |    /// // Call function with multiple arguments
  277|       |    /// let sum: i32 = sandbox.call("Add", (10, 32))?;
  278|       |    /// assert_eq!(sum, 42);
  279|       |    ///
  280|       |    /// // Call function returning string
  281|       |    /// let message: String = sandbox.call("Echo", "Hello, World!".to_string())?;
  282|       |    /// assert_eq!(message, "Hello, World!");
  283|       |    /// # Ok(())
  284|       |    /// # }
  285|       |    /// ```
  286|       |    #[instrument(err(Debug), skip(self, args), parent = Span::current())]
  287|      0|    pub fn call<Output: SupportedReturnType>(
  288|      0|        &mut self,
  289|      0|        func_name: &str,
  290|      0|        args: impl ParameterTuple,
  291|      0|    ) -> Result<Output> {
  292|       |        // Reset snapshot since we are mutating the sandbox state
  293|       |        self.snapshot = None;
  294|      0|        maybe_time_and_emit_guest_call(func_name, || {
  295|      0|            let ret = self.call_guest_function_by_name_no_reset(
  296|      0|                func_name,
  297|      0|                Output::TYPE,
  298|      0|                args.into_value(),
  299|      0|            );
  300|      0|            Output::from_value(ret?)
  301|      0|        })
  302|      0|    }
  303|       |
  304|       |    /// Maps a region of host memory into the sandbox address space.
  305|       |    ///
  306|       |    /// The base address and length must meet platform alignment requirements
  307|       |    /// (typically page-aligned). The `region_type` field is ignored as guest
  308|       |    /// page table entries are not created.
  309|       |    ///
  310|       |    /// # Safety
  311|       |    ///
  312|       |    /// The caller must ensure the host memory region remains valid and unmodified
  313|       |    /// for the lifetime of `self`.
  314|       |    #[instrument(err(Debug), skip(self, rgn), parent = Span::current())]
  315|      0|    pub unsafe fn map_region(&mut self, rgn: &MemoryRegion) -> Result<()> {
  316|       |        if rgn.flags.contains(MemoryRegionFlags::STACK_GUARD) {
  317|       |            // Stack guard pages are an internal implementation detail
  318|       |            // (which really should be moved into the guest)
  319|       |            log_then_return!("Cannot map host memory as a stack guard page");
  320|       |        }
  321|       |        if rgn.flags.contains(MemoryRegionFlags::WRITE) {
  322|       |            // TODO: Implement support for writable mappings, which
  323|       |            // need to be registered with the memory manager so that
  324|       |            // writes can be rolled back when necessary.
  325|       |            log_then_return!("TODO: Writable mappings not yet supported");
  326|       |        }
  327|       |        // Reset snapshot since we are mutating the sandbox state
  328|       |        self.snapshot = None;
  329|       |        unsafe { self.vm.map_region(rgn) }?;
  330|       |        self.mem_mgr.unwrap_mgr_mut().mapped_rgns += 1;
  331|       |        Ok(())
  332|      0|    }
  333|       |
  334|       |    /// Map the contents of a file into the guest at a particular address
  335|       |    ///
  336|       |    /// Returns the length of the mapping in bytes.
  337|       |    #[allow(dead_code)]
  338|       |    #[instrument(err(Debug), skip(self, _fp, _guest_base), parent = Span::current())]
  339|      0|    pub fn map_file_cow(&mut self, _fp: &Path, _guest_base: u64) -> Result<u64> {
  340|       |        #[cfg(windows)]
  341|       |        log_then_return!("mmap'ing a file into the guest is not yet supported on Windows");
  342|       |        #[cfg(unix)]
  343|       |        unsafe {
  344|       |            let file = std::fs::File::options().read(true).write(true).open(_fp)?;
  345|       |            let file_size = file.metadata()?.st_size();
  346|       |            let page_size = page_size::get();
  347|       |            let size = (file_size as usize).div_ceil(page_size) * page_size;
  348|       |            let base = libc::mmap(
  349|       |                std::ptr::null_mut(),
  350|       |                size,
  351|       |                libc::PROT_READ | libc::PROT_WRITE | libc::PROT_EXEC,
  352|       |                libc::MAP_PRIVATE,
  353|       |                file.as_raw_fd(),
  354|       |                0,
  355|       |            );
  356|       |            if base == libc::MAP_FAILED {
  357|       |                log_then_return!("mmap error: {:?}", std::io::Error::last_os_error());
  358|       |            }
  359|       |
  360|       |            if let Err(err) = self.map_region(&MemoryRegion {
  361|       |                host_region: base as usize..base.wrapping_add(size) as usize,
  362|       |                guest_region: _guest_base as usize.._guest_base as usize + size,
  363|       |                flags: MemoryRegionFlags::READ | MemoryRegionFlags::EXECUTE,
  364|       |                region_type: MemoryRegionType::Heap,
  365|       |            }) {
  366|       |                libc::munmap(base, size);
  367|       |                return Err(err);
  368|       |            };
  369|       |
  370|       |            Ok(size as u64)
  371|       |        }
  372|      0|    }
  373|       |
  374|       |    /// Calls a guest function with type-erased parameters and return values.
  375|       |    ///
  376|       |    /// This function is used for fuzz testing parameter and return type handling.
  377|       |    #[cfg(feature = "fuzzing")]
  378|       |    #[instrument(err(Debug), skip(self, args), parent = Span::current())]
  379|       |    pub fn call_type_erased_guest_function_by_name(
  380|       |        &mut self,
  381|       |        func_name: &str,
  382|       |        ret_type: ReturnType,
  383|       |        args: Vec<ParameterValue>,
  384|       |    ) -> Result<ReturnValue> {
  385|       |        maybe_time_and_emit_guest_call(func_name, || {
  386|       |            self.call_guest_function_by_name_no_reset(func_name, ret_type, args)
  387|       |        })
  388|       |    }
  389|       |
  390|      0|    fn call_guest_function_by_name_no_reset(
  391|      0|        &mut self,
  392|      0|        function_name: &str,
  393|      0|        return_type: ReturnType,
  394|      0|        args: Vec<ParameterValue>,
  395|      0|    ) -> Result<ReturnValue> {
  396|      0|        let res = (|| {
  397|      0|            let estimated_capacity = estimate_flatbuffer_capacity(function_name, &args);
  398|      0|
  399|      0|            let fc = FunctionCall::new(
  400|      0|                function_name.to_string(),
  401|      0|                Some(args),
  402|      0|                FunctionCallType::Guest,
  403|      0|                return_type,
  404|      0|            );
  405|      0|
  406|      0|            let mut builder = FlatBufferBuilder::with_capacity(estimated_capacity);
  407|      0|            let buffer = fc.encode(&mut builder);
  408|      0|
  409|      0|            self.get_mgr_wrapper_mut()
  410|      0|                .as_mut()
  411|      0|                .write_guest_function_call(buffer)?;
  412|       |
  413|      0|            self.vm.dispatch_call_from_host(
  414|      0|                self.dispatch_ptr.clone(),
  415|      0|                #[cfg(gdb)]
  416|      0|                self.dbg_mem_access_fn.clone(),
  417|      0|            )?;
  418|       |
  419|      0|            self.mem_mgr.check_stack_guard()?;
  420|      0|            check_for_guest_error(self.get_mgr_wrapper_mut())?;
  421|       |
  422|      0|            self.get_mgr_wrapper_mut()
  423|      0|                .as_mut()
  424|      0|                .get_guest_function_call_result()
  425|      0|        })();
  426|      0|
  427|      0|        // TODO: Do we want to allow re-entrant guest function calls?
  428|      0|        self.get_mgr_wrapper_mut().as_mut().clear_io_buffers();
  429|      0|
  430|      0|        res
  431|      0|    }
  432|       |
  433|       |    /// Returns a handle for interrupting guest execution.
  434|       |    ///
  435|       |    /// # Examples
  436|       |    ///
  437|       |    /// ```no_run
  438|       |    /// # use hyperlight_host::{MultiUseSandbox, UninitializedSandbox, GuestBinary};
  439|       |    /// # use std::thread;
  440|       |    /// # use std::time::Duration;
  441|       |    /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
  442|       |    /// let mut sandbox: MultiUseSandbox = UninitializedSandbox::new(
  443|       |    ///     GuestBinary::FilePath("guest.bin".into()),
  444|       |    ///     None
  445|       |    /// )?.evolve()?;
  446|       |    ///
  447|       |    /// // Get interrupt handle before starting long-running operation
  448|       |    /// let interrupt_handle = sandbox.interrupt_handle();
  449|       |    ///
  450|       |    /// // Spawn thread to interrupt after timeout
  451|       |    /// let handle_clone = interrupt_handle.clone();
  452|       |    /// thread::spawn(move || {
  453|       |    ///     thread::sleep(Duration::from_secs(5));
  454|       |    ///     handle_clone.kill();
  455|       |    /// });
  456|       |    ///
  457|       |    /// // This call may be interrupted by the spawned thread
  458|       |    /// let result = sandbox.call_guest_function_by_name::<i32>("LongRunningFunction", ());
  459|       |    /// # Ok(())
  460|       |    /// # }
  461|       |    /// ```
  462|      0|    pub fn interrupt_handle(&self) -> Arc<dyn InterruptHandle> {
  463|      0|        self.vm.interrupt_handle()
  464|      0|    }
  465|       |}
  466|       |
  467|       |impl Callable for MultiUseSandbox {
  468|      0|    fn call<Output: SupportedReturnType>(
  469|      0|        &mut self,
  470|      0|        func_name: &str,
  471|      0|        args: impl ParameterTuple,
  472|      0|    ) -> Result<Output> {
  473|      0|        self.call(func_name, args)
  474|      0|    }
  475|       |}
  476|       |
  477|       |impl WrapperGetter for MultiUseSandbox {
  478|      0|    fn get_mgr_wrapper(&self) -> &MemMgrWrapper<HostSharedMemory> {
  479|      0|        &self.mem_mgr
  480|      0|    }
  481|      0|    fn get_mgr_wrapper_mut(&mut self) -> &mut MemMgrWrapper<HostSharedMemory> {
  482|      0|        &mut self.mem_mgr
  483|      0|    }
  484|       |}
  485|       |
  486|       |impl std::fmt::Debug for MultiUseSandbox {
  487|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  488|      0|        f.debug_struct("MultiUseSandbox")
  489|      0|            .field("stack_guard", &self.mem_mgr.get_stack_cookie())
  490|      0|            .finish()
  491|      0|    }
  492|       |}
  493|       |
  494|       |#[cfg(test)]
  495|       |mod tests {
  496|       |    use std::sync::{Arc, Barrier};
  497|       |    use std::thread;
  498|       |
  499|       |    use hyperlight_testing::simple_guest_as_string;
  500|       |
  501|       |    #[cfg(target_os = "linux")]
  502|       |    use crate::mem::memory_region::{MemoryRegion, MemoryRegionFlags, MemoryRegionType};
  503|       |    #[cfg(target_os = "linux")]
  504|       |    use crate::mem::shared_mem::{ExclusiveSharedMemory, GuestSharedMemory, SharedMemory as _};
  505|       |    use crate::sandbox::SandboxConfiguration;
  506|       |    use crate::{GuestBinary, HyperlightError, MultiUseSandbox, Result, UninitializedSandbox};
  507|       |
  508|       |    /// Tests that call_guest_function_by_name restores the state correctly
  509|       |    #[test]
  510|      1|    fn test_call_guest_function_by_name() {
  511|      1|        let mut sbox: MultiUseSandbox = {
  512|      1|            let path = simple_guest_as_string().unwrap();
  513|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), None).unwrap();
  514|      1|            u_sbox.evolve()
  515|      1|        }
  516|      1|        .unwrap();
  517|      1|
  518|      1|        let snapshot = sbox.snapshot().unwrap();
  519|      1|
  520|      1|        let _ = sbox.call::<i32>("AddToStatic", 5i32).unwrap();
  521|      1|        let res: i32 = sbox.call("GetStatic", ()).unwrap();
  522|      1|        assert_eq!(res, 5);
  523|       |
  524|      0|        sbox.restore(&snapshot).unwrap();
  525|      0|        #[allow(deprecated)]
  526|      0|        let _ = sbox
  527|      0|            .call_guest_function_by_name::<i32>("AddToStatic", 5i32)
  528|      0|            .unwrap();
  529|      0|        #[allow(deprecated)]
  530|      0|        let res: i32 = sbox.call_guest_function_by_name("GetStatic", ()).unwrap();
  531|      0|        assert_eq!(res, 0);
  532|      0|    }
  533|       |
  534|       |    // Tests to ensure that many (1000) function calls can be made in a call context with a small stack (1K) and heap(14K).
  535|       |    // This test effectively ensures that the stack is being properly reset after each call and we are not leaking memory in the Guest.
  536|       |    #[test]
  537|      1|    fn test_with_small_stack_and_heap() {
  538|      1|        let mut cfg = SandboxConfiguration::default();
  539|      1|        cfg.set_heap_size(20 * 1024);
  540|      1|        cfg.set_stack_size(16 * 1024);
  541|      1|
  542|      1|        let mut sbox1: MultiUseSandbox = {
  543|      1|            let path = simple_guest_as_string().unwrap();
  544|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), Some(cfg)).unwrap();
  545|      1|            u_sbox.evolve()
  546|      1|        }
  547|      1|        .unwrap();
  548|       |
  549|  18.4E|        for _ in 0..1000 {
                               ^0
  550|  18.4E|            sbox1.call::<String>("Echo", "hello".to_string()).unwrap();
  551|  18.4E|        }
  552|       |
  553|      1|        let mut sbox2: MultiUseSandbox = {
  554|      1|            let path = simple_guest_as_string().unwrap();
  555|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), Some(cfg)).unwrap();
  556|      1|            u_sbox.evolve()
  557|      1|        }
  558|      1|        .unwrap();
  559|       |
  560|  18.4E|        for i in 0..1000 {
                               ^0
  561|  18.4E|            sbox2
  562|  18.4E|                .call::<i32>(
  563|  18.4E|                    "PrintUsingPrintf",
  564|  18.4E|                    format!("Hello World {}\n", i).to_string(),
  565|  18.4E|                )
  566|  18.4E|                .unwrap();
  567|  18.4E|        }
  568|      1|    }
  569|       |
  570|       |    /// Tests that evolving from MultiUseSandbox to MultiUseSandbox creates a new state
  571|       |    /// and restoring a snapshot from before evolving restores the previous state
  572|       |    #[test]
  573|      1|    fn snapshot_evolve_restore_handles_state_correctly() {
  574|      1|        let mut sbox: MultiUseSandbox = {
  575|      1|            let path = simple_guest_as_string().unwrap();
  576|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), None).unwrap();
  577|      1|            u_sbox.evolve()
  578|      1|        }
  579|      1|        .unwrap();
  580|      1|
  581|      1|        let snapshot = sbox.snapshot().unwrap();
  582|      1|
  583|      1|        let _ = sbox.call::<i32>("AddToStatic", 5i32).unwrap();
  584|      1|
  585|      1|        let res: i32 = sbox.call("GetStatic", ()).unwrap();
  586|      1|        assert_eq!(res, 5);
  587|       |
  588|      0|        sbox.restore(&snapshot).unwrap();
  589|      0|        let res: i32 = sbox.call("GetStatic", ()).unwrap();
  590|      0|        assert_eq!(res, 0);
  591|      0|    }
  592|       |
  593|       |    #[test]
  594|       |    // TODO: Investigate why this test fails with an incorrect error when run alongside other tests
  595|       |    #[ignore]
  596|       |    #[cfg(target_os = "linux")]
  597|      0|    fn test_violate_seccomp_filters() -> Result<()> {
  598|      0|        fn make_get_pid_syscall() -> Result<u64> {
  599|      0|            let pid = unsafe { libc::syscall(libc::SYS_getpid) };
  600|      0|            Ok(pid as u64)
  601|      0|        }
  602|       |
  603|       |        // First, run  to make sure it fails.
  604|       |        {
  605|      0|            let mut usbox = UninitializedSandbox::new(
  606|      0|                GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  607|      0|                None,
  608|      0|            )
  609|      0|            .unwrap();
  610|      0|
  611|      0|            usbox.register("MakeGetpidSyscall", make_get_pid_syscall)?;
  612|       |
  613|      0|            let mut sbox: MultiUseSandbox = usbox.evolve()?;
  614|       |
  615|      0|            let res: Result<u64> = sbox.call("ViolateSeccompFilters", ());
  616|      0|
  617|      0|            #[cfg(feature = "seccomp")]
  618|      0|            match res {
  619|      0|                Ok(_) => panic!("Expected to fail due to seccomp violation"),
  620|      0|                Err(e) => match e {
  621|      0|                    HyperlightError::DisallowedSyscall => {}
  622|      0|                    _ => panic!("Expected DisallowedSyscall error: {}", e),
  623|       |                },
  624|       |            }
  625|       |
  626|       |            #[cfg(not(feature = "seccomp"))]
  627|       |            match res {
  628|       |                Ok(_) => (),
  629|       |                Err(e) => panic!("Expected to succeed without seccomp: {}", e),
  630|       |            }
  631|       |        }
  632|       |
  633|       |        // Second, run with allowing `SYS_getpid`
  634|       |        #[cfg(feature = "seccomp")]
  635|       |        {
  636|      0|            let mut usbox = UninitializedSandbox::new(
  637|      0|                GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  638|      0|                None,
  639|      0|            )
  640|      0|            .unwrap();
  641|      0|
  642|      0|            usbox.register_with_extra_allowed_syscalls(
  643|      0|                "MakeGetpidSyscall",
  644|      0|                make_get_pid_syscall,
  645|      0|                vec![libc::SYS_getpid],
  646|      0|            )?;
  647|       |            // ^^^ note, we are allowing SYS_getpid
  648|       |
  649|      0|            let mut sbox: MultiUseSandbox = usbox.evolve()?;
  650|       |
  651|      0|            let res: Result<u64> = sbox.call("ViolateSeccompFilters", ());
  652|      0|
  653|      0|            match res {
  654|      0|                Ok(_) => {}
  655|      0|                Err(e) => panic!("Expected to succeed due to seccomp violation: {}", e),
  656|       |            }
  657|       |        }
  658|       |
  659|      0|        Ok(())
  660|      0|    }
  661|       |
  662|       |    // We have a secomp specifically for `openat`, but we don't want to crash on `openat`, but rather make sure `openat` returns `EACCES`
  663|       |    #[test]
  664|       |    #[cfg(target_os = "linux")]
  665|      1|    fn violate_seccomp_filters_openat() -> Result<()> {
  666|       |        // Hostcall to call `openat`.
  667|      1|        fn make_openat_syscall() -> Result<i64> {
  668|       |            use std::ffi::CString;
  669|       |
  670|      1|            let path = CString::new("/proc/sys/vm/overcommit_memory").unwrap();
  671|      1|
  672|      1|            let fd_or_err = unsafe {
  673|      1|                libc::syscall(
  674|      1|                    libc::SYS_openat,
  675|      1|                    libc::AT_FDCWD,
  676|      1|                    path.as_ptr(),
  677|      1|                    libc::O_RDONLY,
  678|      1|                )
  679|      1|            };
  680|      1|
  681|      1|            if fd_or_err == -1 {
  682|      0|                Ok((-std::io::Error::last_os_error().raw_os_error().unwrap()).into())
  683|       |            } else {
  684|      1|                Ok(fd_or_err)
  685|       |            }
  686|      1|        }
  687|       |        {
  688|       |            // First make sure a regular call to `openat` on /proc/sys/vm/overcommit_memory succeeds
  689|      1|            let ret = make_openat_syscall()?;
                                                         ^0
  690|      1|            assert!(
  691|      1|                ret >= 0,
  692|      0|                "Expected openat syscall to succeed, got: {:?}",
  693|       |                ret
  694|       |            );
  695|       |
  696|      1|            let mut ubox = UninitializedSandbox::new(
  697|      1|                GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  698|      1|                None,
  699|      1|            )
  700|      1|            .unwrap();
  701|      1|            ubox.register("Openat_Hostfunc", make_openat_syscall)?;
                                                                               ^0
  702|       |
  703|      1|            let mut sbox = ubox.evolve().unwrap();
  704|      1|            let host_func_result = sbox
  705|      1|                .call::<i64>(
  706|      1|                    "CallGivenParamlessHostFuncThatReturnsI64",
  707|      1|                    "Openat_Hostfunc".to_string(),
  708|      1|                )
  709|      1|                .expect("Expected to call host function that returns i64");
  710|      1|
  711|      1|            if cfg!(feature = "seccomp") {
  712|       |                // If seccomp is enabled, we expect the syscall to return EACCES, as setup by our seccomp filter
  713|      1|                assert_eq!(host_func_result, -libc::EACCES as i64);
  714|       |            } else {
  715|       |                // If seccomp is not enabled, we expect the syscall to succeed
  716|      0|                assert!(host_func_result >= 0);
  717|       |            }
  718|       |        }
  719|       |
  720|       |        #[cfg(feature = "seccomp")]
  721|       |        {
  722|       |            // Now let's make sure if we register the `openat` syscall as an extra allowed syscall, it will succeed
  723|      0|            let mut ubox = UninitializedSandbox::new(
  724|      0|                GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  725|      0|                None,
  726|      0|            )
  727|      0|            .unwrap();
  728|      0|            ubox.register_with_extra_allowed_syscalls(
  729|      0|                "Openat_Hostfunc",
  730|      0|                make_openat_syscall,
  731|      0|                [libc::SYS_openat],
  732|      0|            )?;
  733|      0|            let mut sbox = ubox.evolve().unwrap();
  734|      0|            let host_func_result: i64 = sbox
  735|      0|                .call::<i64>(
  736|      0|                    "CallGivenParamlessHostFuncThatReturnsI64",
  737|      0|                    "Openat_Hostfunc".to_string(),
  738|      0|                )
  739|      0|                .expect("Expected to call host function that returns i64");
  740|      0|
  741|      0|            // should pass regardless of seccomp feature
  742|      0|            assert!(host_func_result >= 0);
  743|       |        }
  744|       |
  745|      0|        Ok(())
  746|      0|    }
  747|       |
  748|       |    #[test]
  749|      1|    fn test_trigger_exception_on_guest() {
  750|      1|        let usbox = UninitializedSandbox::new(
  751|      1|            GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  752|      1|            None,
  753|      1|        )
  754|      1|        .unwrap();
  755|      1|
  756|      1|        let mut multi_use_sandbox: MultiUseSandbox = usbox.evolve().unwrap();
  757|      1|
  758|      1|        let res: Result<()> = multi_use_sandbox.call("TriggerException", ());
  759|      1|
  760|      1|        assert!(res.is_err());
  761|       |
  762|      0|        match res.unwrap_err() {
  763|      0|            HyperlightError::GuestAborted(_, msg) => {
  764|      0|                // msg should indicate we got an invalid opcode exception
  765|      0|                assert!(msg.contains("InvalidOpcode"));
  766|       |            }
  767|      0|            e => panic!(
  768|      0|                "Expected HyperlightError::GuestExecutionError but got {:?}",
  769|      0|                e
  770|      0|            ),
  771|       |        }
  772|      0|    }
  773|       |
  774|       |    #[test]
  775|       |    #[ignore] // this test runs by itself because it uses a lot of system resources
  776|      0|    fn create_1000_sandboxes() {
  777|      0|        let barrier = Arc::new(Barrier::new(21));
  778|      0|
  779|      0|        let mut handles = vec![];
  780|       |
  781|      0|        for _ in 0..20 {
  782|      0|            let c = barrier.clone();
  783|      0|
  784|      0|            let handle = thread::spawn(move || {
  785|      0|                c.wait();
  786|       |
  787|      0|                for _ in 0..50 {
  788|      0|                    let usbox = UninitializedSandbox::new(
  789|      0|                        GuestBinary::FilePath(
  790|      0|                            simple_guest_as_string().expect("Guest Binary Missing"),
  791|      0|                        ),
  792|      0|                        None,
  793|      0|                    )
  794|      0|                    .unwrap();
  795|      0|
  796|      0|                    let mut multi_use_sandbox: MultiUseSandbox = usbox.evolve().unwrap();
  797|      0|
  798|      0|                    let res: i32 = multi_use_sandbox.call("GetStatic", ()).unwrap();
  799|      0|
  800|      0|                    assert_eq!(res, 0);
  801|       |                }
  802|      0|            });
  803|      0|
  804|      0|            handles.push(handle);
  805|      0|        }
  806|       |
  807|      0|        barrier.wait();
  808|       |
  809|      0|        for handle in handles {
  810|      0|            handle.join().unwrap();
  811|      0|        }
  812|      0|    }
  813|       |
  814|       |    #[cfg(target_os = "linux")]
  815|       |    #[test]
  816|      1|    fn test_mmap() {
  817|      1|        let mut sbox = UninitializedSandbox::new(
  818|      1|            GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  819|      1|            None,
  820|      1|        )
  821|      1|        .unwrap()
  822|      1|        .evolve()
  823|      1|        .unwrap();
  824|      1|
  825|      1|        let expected = b"hello world";
  826|      1|        let map_mem = page_aligned_memory(expected);
  827|      1|        let guest_base = 0x1_0000_0000; // Arbitrary guest base address
  828|      1|
  829|      1|        unsafe {
  830|      1|            sbox.map_region(&region_for_memory(
  831|      1|                &map_mem,
  832|      1|                guest_base,
  833|      1|                MemoryRegionFlags::READ,
  834|      1|            ))
  835|      1|            .unwrap();
  836|      1|        }
  837|      1|
  838|      1|        let _guard = map_mem.lock.try_read().unwrap();
  839|      1|        let actual: Vec<u8> = sbox
  840|      1|            .call(
  841|      1|                "ReadMappedBuffer",
  842|      1|                (guest_base as u64, expected.len() as u64),
  843|      1|            )
  844|      1|            .unwrap();
  845|      1|
  846|      1|        assert_eq!(actual, expected);
  847|      0|    }
  848|       |
  849|       |    // Makes sure MemoryRegionFlags::READ | MemoryRegionFlags::EXECUTE executable but not writable
  850|       |    #[cfg(target_os = "linux")]
  851|       |    #[test]
  852|      1|    fn test_mmap_write_exec() {
  853|      1|        let mut sbox = UninitializedSandbox::new(
  854|      1|            GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  855|      1|            None,
  856|      1|        )
  857|      1|        .unwrap()
  858|      1|        .evolve()
  859|      1|        .unwrap();
  860|      1|
  861|      1|        let expected = &[0x90, 0x90, 0x90, 0xC3]; // NOOP slide to RET
  862|      1|        let map_mem = page_aligned_memory(expected);
  863|      1|        let guest_base = 0x1_0000_0000; // Arbitrary guest base address
  864|      1|
  865|      1|        unsafe {
  866|      1|            sbox.map_region(&region_for_memory(
  867|      1|                &map_mem,
  868|      1|                guest_base,
  869|      1|                MemoryRegionFlags::READ | MemoryRegionFlags::EXECUTE,
  870|      1|            ))
  871|      1|            .unwrap();
  872|      1|        }
  873|      1|
  874|      1|        let _guard = map_mem.lock.try_read().unwrap();
  875|      1|
  876|      1|        // Execute should pass since memory is executable
  877|      1|        let succeed = sbox
  878|      1|            .call::<bool>(
  879|      1|                "ExecMappedBuffer",
  880|      1|                (guest_base as u64, expected.len() as u64),
  881|      1|            )
  882|      1|            .unwrap();
  883|      1|        assert!(succeed, "Expected execution of mapped buffer to succeed");
  884|       |
  885|       |        // write should fail because the memory is mapped as read-only
  886|      0|        let err = sbox
  887|      0|            .call::<bool>(
  888|      0|                "WriteMappedBuffer",
  889|      0|                (guest_base as u64, expected.len() as u64),
  890|      0|            )
  891|      0|            .unwrap_err();
  892|       |
  893|      0|        match err {
  894|      0|            HyperlightError::MemoryAccessViolation(addr, ..) if addr == guest_base as u64 => {}
  895|      0|            _ => panic!("Expected MemoryAccessViolation error"),
  896|       |        };
  897|      0|    }
  898|       |
  899|       |    #[cfg(target_os = "linux")]
  900|      0|    fn page_aligned_memory(src: &[u8]) -> GuestSharedMemory {
  901|       |        use hyperlight_common::mem::PAGE_SIZE_USIZE;
  902|       |
  903|      0|        let len = src.len().div_ceil(PAGE_SIZE_USIZE) * PAGE_SIZE_USIZE;
  904|      0|
  905|      0|        let mut mem = ExclusiveSharedMemory::new(len).unwrap();
  906|      0|        mem.copy_from_slice(src, 0).unwrap();
  907|      0|
  908|      0|        let (_, guest_mem) = mem.build();
  909|      0|
  910|      0|        guest_mem
  911|      0|    }
  912|       |
  913|       |    #[cfg(target_os = "linux")]
  914|      0|    fn region_for_memory(
  915|      0|        mem: &GuestSharedMemory,
  916|      0|        guest_base: usize,
  917|      0|        flags: MemoryRegionFlags,
  918|      0|    ) -> MemoryRegion {
  919|      0|        let ptr = mem.base_addr();
  920|      0|        let len = mem.mem_size();
  921|      0|        MemoryRegion {
  922|      0|            host_region: ptr..(ptr + len),
  923|      0|            guest_region: guest_base..(guest_base + len),
  924|      0|            flags,
  925|      0|            region_type: MemoryRegionType::Heap,
  926|      0|        }
  927|      0|    }
  928|       |
  929|       |    #[cfg(target_os = "linux")]
  930|      0|    fn allocate_guest_memory() -> GuestSharedMemory {
  931|      0|        page_aligned_memory(b"test data for snapshot")
  932|      0|    }
  933|       |
  934|       |    #[test]
  935|       |    #[cfg(target_os = "linux")]
  936|      1|    fn snapshot_restore_handles_remapping_correctly() {
  937|      1|        let mut sbox: MultiUseSandbox = {
  938|      1|            let path = simple_guest_as_string().unwrap();
  939|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), None).unwrap();
  940|      1|            u_sbox.evolve().unwrap()
  941|      1|        };
  942|      1|
  943|      1|        // 1. Take snapshot 1 with no additional regions mapped
  944|      1|        let snapshot1 = sbox.snapshot().unwrap();
  945|      1|        assert_eq!(sbox.vm.get_mapped_regions().len(), 0);
  946|       |
  947|       |        // 2. Map a memory region
  948|      0|        let map_mem = allocate_guest_memory();
  949|      0|        let guest_base = 0x200000000_usize;
  950|      0|        let region = region_for_memory(&map_mem, guest_base, MemoryRegionFlags::READ);
  951|      0|
  952|      0|        unsafe { sbox.map_region(&region).unwrap() };
  953|      0|        assert_eq!(sbox.vm.get_mapped_regions().len(), 1);
  954|       |
  955|       |        // 3. Take snapshot 2 with 1 region mapped
  956|      0|        let snapshot2 = sbox.snapshot().unwrap();
  957|      0|        assert_eq!(sbox.vm.get_mapped_regions().len(), 1);
  958|       |
  959|       |        // 4. Restore to snapshot 1 (should unmap the region)
  960|      0|        sbox.restore(&snapshot1).unwrap();
  961|      0|        assert_eq!(sbox.vm.get_mapped_regions().len(), 0);
  962|       |
  963|       |        // 5. Restore forward to snapshot 2 (should remap the region)
  964|      0|        sbox.restore(&snapshot2).unwrap();
  965|      0|        assert_eq!(sbox.vm.get_mapped_regions().len(), 1);
  966|       |
  967|       |        // Verify the region is the same
  968|      0|        let mut restored_regions = sbox.vm.get_mapped_regions();
  969|      0|        assert_eq!(*restored_regions.next().unwrap(), region);
  970|      0|        assert!(restored_regions.next().is_none());
  971|      0|        drop(restored_regions);
  972|      0|
  973|      0|        // 6. Try map the region again (should fail since already mapped)
  974|      0|        let err = unsafe { sbox.map_region(&region) };
  975|      0|        assert!(
  976|      0|            err.is_err(),
  977|      0|            "Expected error when remapping existing region: {:?}",
  978|       |            err
  979|       |        );
  980|      0|    }
  981|       |
  982|       |    #[test]
  983|      1|    fn snapshot_different_sandbox() {
  984|      1|        let mut sandbox = {
  985|      1|            let path = simple_guest_as_string().unwrap();
  986|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), None).unwrap();
  987|      1|            u_sbox.evolve().unwrap()
  988|      1|        };
  989|      1|
  990|      1|        let mut sandbox2 = {
  991|      1|            let path = simple_guest_as_string().unwrap();
  992|      1|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), None).unwrap();
  993|      1|            u_sbox.evolve().unwrap()
  994|      1|        };
  995|      1|        assert_ne!(sandbox.id, sandbox2.id);
  996|       |
  997|      0|        let snapshot = sandbox.snapshot().unwrap();
  998|      0|        let err = sandbox2.restore(&snapshot);
  999|      0|        assert!(matches!(err, Err(HyperlightError::SnapshotSandboxMismatch)));
 1000|       |
 1001|      0|        let sandbox_id = sandbox.id;
 1002|      0|        drop(sandbox);
 1003|      0|        drop(sandbox2);
 1004|      0|        drop(snapshot);
 1005|      0|
 1006|      0|        let sandbox3 = {
 1007|      0|            let path = simple_guest_as_string().unwrap();
 1008|      0|            let u_sbox = UninitializedSandbox::new(GuestBinary::FilePath(path), None).unwrap();
 1009|      0|            u_sbox.evolve().unwrap()
 1010|      0|        };
 1011|      0|        assert_ne!(sandbox3.id, sandbox_id);
 1012|      0|    }
 1013|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/mem_access.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(gdb)]
   18|       |use std::sync::{Arc, Mutex};
   19|       |
   20|       |use tracing::{Span, instrument};
   21|       |
   22|       |#[cfg(gdb)]
   23|       |use super::mem_mgr::MemMgrWrapper;
   24|       |use crate::error::HyperlightError::StackOverflow;
   25|       |use crate::hypervisor::Hypervisor;
   26|       |#[cfg(gdb)]
   27|       |use crate::hypervisor::handlers::{DbgMemAccessHandlerCaller, DbgMemAccessHandlerWrapper};
   28|       |#[cfg(gdb)]
   29|       |use crate::mem::shared_mem::HostSharedMemory;
   30|       |use crate::{Result, log_then_return};
   31|       |
   32|       |#[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   33|      0|pub(crate) fn handle_mem_access(hv: &dyn Hypervisor) -> Result<()> {
   34|       |    if !hv.check_stack_guard()? {
   35|       |        log_then_return!(StackOverflow());
   36|       |    }
   37|       |
   38|       |    Ok(())
   39|      0|}
   40|       |
   41|       |#[cfg(gdb)]
   42|       |struct DbgMemAccessContainer {
   43|       |    wrapper: MemMgrWrapper<HostSharedMemory>,
   44|       |}
   45|       |
   46|       |#[cfg(gdb)]
   47|       |impl DbgMemAccessHandlerCaller for DbgMemAccessContainer {
   48|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   49|       |    fn read(&mut self, addr: usize, data: &mut [u8]) -> Result<()> {
   50|       |        self.wrapper
   51|       |            .unwrap_mgr_mut()
   52|       |            .get_shared_mem_mut()
   53|       |            .copy_to_slice(data, addr)
   54|       |    }
   55|       |
   56|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   57|       |    fn write(&mut self, addr: usize, data: &[u8]) -> Result<()> {
   58|       |        self.wrapper
   59|       |            .unwrap_mgr_mut()
   60|       |            .get_shared_mem_mut()
   61|       |            .copy_from_slice(data, addr)
   62|       |    }
   63|       |
   64|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   65|       |    fn get_code_offset(&mut self) -> Result<usize> {
   66|       |        Ok(self.wrapper.unwrap_mgr().layout.get_guest_code_address())
   67|       |    }
   68|       |}
   69|       |
   70|       |#[cfg(gdb)]
   71|       |#[instrument(skip_all, parent = Span::current(), level= "Trace")]
   72|       |pub(crate) fn dbg_mem_access_handler_wrapper(
   73|       |    wrapper: MemMgrWrapper<HostSharedMemory>,
   74|       |) -> DbgMemAccessHandlerWrapper {
   75|       |    let container = DbgMemAccessContainer { wrapper };
   76|       |
   77|       |    Arc::new(Mutex::new(container))
   78|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/mem_mgr.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use tracing::{Span, instrument};
   18|       |
   19|       |use crate::Result;
   20|       |use crate::mem::layout::SandboxMemoryLayout;
   21|       |use crate::mem::mgr::{STACK_COOKIE_LEN, SandboxMemoryManager};
   22|       |use crate::mem::shared_mem::{
   23|       |    ExclusiveSharedMemory, GuestSharedMemory, HostSharedMemory, SharedMemory,
   24|       |};
   25|       |
   26|       |/// StackCookie
   27|       |pub type StackCookie = [u8; STACK_COOKIE_LEN];
   28|       |
   29|       |/// A container with methods for accessing `SandboxMemoryManager` and other
   30|       |/// related objects
   31|       |#[derive(Clone)]
   32|       |pub(crate) struct MemMgrWrapper<S> {
   33|       |    mgr: SandboxMemoryManager<S>,
   34|       |    stack_cookie: StackCookie,
   35|       |    abort_buffer: Vec<u8>,
   36|       |}
   37|       |
   38|       |impl<S: SharedMemory> MemMgrWrapper<S> {
   39|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   40|    123|    pub(super) fn new(mgr: SandboxMemoryManager<S>, stack_cookie: StackCookie) -> Self {
   41|    123|        Self {
   42|    123|            mgr,
   43|    123|            stack_cookie,
   44|    123|            abort_buffer: Vec::new(),
   45|    123|        }
   46|    123|    }
   47|       |
   48|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   49|      0|    pub(crate) fn unwrap_mgr(&self) -> &SandboxMemoryManager<S> {
   50|      0|        &self.mgr
   51|      0|    }
   52|       |
   53|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   54|    136|    pub(crate) fn unwrap_mgr_mut(&mut self) -> &mut SandboxMemoryManager<S> {
   55|    136|        &mut self.mgr
   56|    136|    }
   57|       |
   58|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   59|      0|    pub(super) fn get_stack_cookie(&self) -> &StackCookie {
   60|      0|        &self.stack_cookie
   61|      0|    }
   62|       |
   63|      0|    pub fn get_abort_buffer_mut(&mut self) -> &mut Vec<u8> {
   64|      0|        &mut self.abort_buffer
   65|      0|    }
   66|       |}
   67|       |
   68|       |impl<S: SharedMemory> AsMut<SandboxMemoryManager<S>> for MemMgrWrapper<S> {
   69|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   70|      0|    fn as_mut(&mut self) -> &mut SandboxMemoryManager<S> {
   71|      0|        self.unwrap_mgr_mut()
   72|      0|    }
   73|       |}
   74|       |
   75|       |impl<S: SharedMemory> AsRef<SandboxMemoryManager<S>> for MemMgrWrapper<S> {
   76|       |    #[instrument(skip_all, parent = Span::current(), level= "Trace")]
   77|      0|    fn as_ref(&self) -> &SandboxMemoryManager<S> {
   78|      0|        self.unwrap_mgr()
   79|      0|    }
   80|       |}
   81|       |
   82|       |impl MemMgrWrapper<ExclusiveSharedMemory> {
   83|     59|    pub(crate) fn build(
   84|     59|        self,
   85|     59|    ) -> (
   86|     59|        MemMgrWrapper<HostSharedMemory>,
   87|     59|        SandboxMemoryManager<GuestSharedMemory>,
   88|     59|    ) {
   89|     59|        let (hshm, gshm) = self.mgr.build();
   90|     59|        (MemMgrWrapper::new(hshm, self.stack_cookie), gshm)
   91|     59|    }
   92|       |
   93|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
   94|     64|    pub(super) fn write_memory_layout(&mut self) -> Result<()> {
   95|       |        let mgr = self.unwrap_mgr_mut();
   96|       |        let layout = mgr.layout;
   97|       |        let shared_mem = mgr.get_shared_mem_mut();
   98|       |        let mem_size = shared_mem.mem_size();
   99|       |        layout.write(shared_mem, SandboxMemoryLayout::BASE_ADDRESS, mem_size)
  100|     64|    }
  101|       |
  102|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  103|      1|    pub(super) fn write_init_data(&mut self, user_memory: &[u8]) -> Result<()> {
  104|       |        let mgr = self.unwrap_mgr_mut();
  105|       |        let layout = mgr.layout;
  106|       |        let shared_mem = mgr.get_shared_mem_mut();
  107|       |        layout.write_init_data(shared_mem, user_memory)?;
  108|       |        Ok(())
  109|      1|    }
  110|       |}
  111|       |
  112|       |impl MemMgrWrapper<HostSharedMemory> {
  113|       |    /// Check the stack guard against the given `stack_cookie`.
  114|       |    ///
  115|       |    /// Return `Ok(true)` if the given cookie matches the one in guest memory,
  116|       |    /// and `Ok(false)` otherwise. Return `Err` if it could not be found or
  117|       |    /// there was some other error.
  118|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  119|      0|    pub(crate) fn check_stack_guard(&self) -> Result<bool> {
  120|       |        self.unwrap_mgr()
  121|       |            .check_stack_guard(*self.get_stack_cookie())
  122|      0|    }
  123|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/mod.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |/// Configuration needed to establish a sandbox.
   18|       |pub mod config;
   19|       |/// Functionality for reading, but not modifying host functions
   20|       |pub(crate) mod host_funcs;
   21|       |/// Functionality for dealing with `Sandbox`es that contain Hypervisors
   22|       |pub(crate) mod hypervisor;
   23|       |/// Functionality for dealing with initialized sandboxes that can
   24|       |/// call 0 or more guest functions
   25|       |pub mod initialized_multi_use;
   26|       |/// Functionality for dealing with memory access from the VM guest
   27|       |/// executable
   28|       |pub(crate) mod mem_access;
   29|       |/// Functionality for interacting with a sandbox's internally-stored
   30|       |/// `SandboxMemoryManager`
   31|       |pub(crate) mod mem_mgr;
   32|       |pub(crate) mod outb;
   33|       |/// Functionality for creating uninitialized sandboxes, manipulating them,
   34|       |/// and converting them to initialized sandboxes.
   35|       |pub mod uninitialized;
   36|       |/// Functionality for properly converting `UninitializedSandbox`es to
   37|       |/// initialized `Sandbox`es.
   38|       |pub(crate) mod uninitialized_evolve;
   39|       |
   40|       |/// Representation of a snapshot of a `Sandbox`.
   41|       |pub mod snapshot;
   42|       |
   43|       |/// Trait used by the macros to paper over the differences between hyperlight and hyperlight-wasm
   44|       |mod callable;
   45|       |
   46|       |#[cfg(feature = "unwind_guest")]
   47|       |use std::io::Write;
   48|       |#[cfg(feature = "trace_guest")]
   49|       |use std::sync::{Arc, Mutex};
   50|       |
   51|       |/// Trait used by the macros to paper over the differences between hyperlight and hyperlight-wasm
   52|       |pub use callable::Callable;
   53|       |/// Re-export for `SandboxConfiguration` type
   54|       |pub use config::SandboxConfiguration;
   55|       |#[cfg(feature = "unwind_guest")]
   56|       |use framehop::Unwinder;
   57|       |/// Re-export for the `MultiUseSandbox` type
   58|       |pub use initialized_multi_use::MultiUseSandbox;
   59|       |use tracing::{Span, instrument};
   60|       |/// Re-export for `GuestBinary` type
   61|       |pub use uninitialized::GuestBinary;
   62|       |/// Re-export for `UninitializedSandbox` type
   63|       |pub use uninitialized::UninitializedSandbox;
   64|       |
   65|       |use self::mem_mgr::MemMgrWrapper;
   66|       |#[cfg(target_os = "windows")]
   67|       |use crate::hypervisor::windows_hypervisor_platform;
   68|       |use crate::mem::shared_mem::HostSharedMemory;
   69|       |
   70|       |// In case its not obvious why there are separate is_supported_platform and is_hypervisor_present functions its because
   71|       |// Hyperlight is designed to be able to run on a host that doesn't have a hypervisor.
   72|       |// In that case, the sandbox will be in process, we plan on making this a dev only feature and fixing up Linux support
   73|       |// so we should review the need for this function at that time.
   74|       |
   75|       |/// Determine if this is a supported platform for Hyperlight
   76|       |///
   77|       |/// Returns a boolean indicating whether this is a supported platform.
   78|       |#[instrument(skip_all, parent = Span::current())]
   79|      0|pub fn is_supported_platform() -> bool {
   80|       |    #[cfg(not(target_os = "linux"))]
   81|       |    #[cfg(not(target_os = "windows"))]
   82|       |    return false;
   83|       |
   84|      0|    true
   85|      0|}
   86|       |
   87|       |/// Alias for the type of extra allowed syscalls.
   88|       |pub type ExtraAllowedSyscall = i64;
   89|       |
   90|       |/// Determine whether a suitable hypervisor is available to run
   91|       |/// this sandbox.
   92|       |///
   93|       |///  Returns a boolean indicating whether a suitable hypervisor is present.
   94|       |#[instrument(skip_all, parent = Span::current())]
   95|      2|pub fn is_hypervisor_present() -> bool {
   96|      2|    hypervisor::get_available_hypervisor().is_some()
   97|      2|}
   98|       |
   99|       |#[cfg(feature = "trace_guest")]
  100|       |#[derive(Clone)]
  101|       |/// The information that trace collection requires in order to write
  102|       |/// an accurate trace.
  103|       |pub(crate) struct TraceInfo {
  104|       |    /// The epoch against which trace events are timed; at least as
  105|       |    /// early as the creation of the sandbox being traced.
  106|       |    pub epoch: std::time::Instant,
  107|       |    /// The frequency of the timestamp counter.
  108|       |    pub tsc_freq: Option<u64>,
  109|       |    /// The epoch at which the guest started, if it has started.
  110|       |    /// This is used to calculate the time spent in the guest relative to the
  111|       |    /// time when the host started.
  112|       |    pub guest_start_epoch: Option<std::time::Instant>,
  113|       |    /// The start guest time, in TSC cycles, for the current guest has a double purpose.
  114|       |    /// This field is used in two ways:
  115|       |    /// 1. It contains the TSC value recorded on the host when the guest started.
  116|       |    ///    This is used to calculate the TSC frequency which is the same on the host and guest.
  117|       |    ///    The TSC frequency is used to convert TSC values to timestamps in the trace.
  118|       |    ///    **NOTE**: This is only used until the TSC frequency is calculated, when the first
  119|       |    ///    records are received.
  120|       |    /// 2. To store the TSC value at recorded on the guest when the guest started (first record
  121|       |    ///    received)
  122|       |    ///    This is used to calculate the records timestamps relative to when guest started.
  123|       |    pub guest_start_tsc: Option<u64>,
  124|       |    /// The file to which the trace is being written
  125|       |    #[allow(dead_code)]
  126|       |    pub file: Arc<Mutex<std::fs::File>>,
  127|       |    /// The unwind information for the current guest
  128|       |    #[cfg(feature = "unwind_guest")]
  129|       |    #[allow(dead_code)]
  130|       |    pub unwind_module: Arc<dyn crate::mem::exe::UnwindInfo>,
  131|       |    /// The framehop unwinder for the current guest
  132|       |    #[cfg(feature = "unwind_guest")]
  133|       |    pub unwinder: framehop::x86_64::UnwinderX86_64<Vec<u8>>,
  134|       |    /// The framehop cache
  135|       |    #[cfg(feature = "unwind_guest")]
  136|       |    pub unwind_cache: Arc<Mutex<framehop::x86_64::CacheX86_64>>,
  137|       |}
  138|       |#[cfg(feature = "trace_guest")]
  139|       |impl TraceInfo {
  140|       |    /// Create a new TraceInfo by saving the current time as the epoch
  141|       |    /// and generating a random filename.
  142|       |    pub fn new(
  143|       |        #[cfg(feature = "unwind_guest")] unwind_module: Arc<dyn crate::mem::exe::UnwindInfo>,
  144|       |    ) -> crate::Result<Self> {
  145|       |        let mut path = std::env::current_dir()?;
  146|       |        path.push("trace");
  147|       |
  148|       |        // create directory if it does not exist
  149|       |        if !path.exists() {
  150|       |            std::fs::create_dir(&path)?;
  151|       |        }
  152|       |        path.push(uuid::Uuid::new_v4().to_string());
  153|       |        path.set_extension("trace");
  154|       |
  155|       |        log::info!("Creating trace file at: {}", path.display());
  156|       |        println!("Creating trace file at: {}", path.display());
  157|       |
  158|       |        #[cfg(feature = "unwind_guest")]
  159|       |        let hash = unwind_module.hash();
  160|       |        #[cfg(feature = "unwind_guest")]
  161|       |        let (unwinder, unwind_cache) = {
  162|       |            let mut unwinder = framehop::x86_64::UnwinderX86_64::new();
  163|       |            unwinder.add_module(unwind_module.clone().as_module());
  164|       |            let cache = framehop::x86_64::CacheX86_64::new();
  165|       |            (unwinder, Arc::new(Mutex::new(cache)))
  166|       |        };
  167|       |        if !hyperlight_guest_tracing::invariant_tsc::has_invariant_tsc() {
  168|       |            // If the platform does not support invariant TSC, warn the user.
  169|       |            // On Azure nested virtualization, the TSC invariant bit is not correctly reported, this is a known issue.
  170|       |            log::warn!(
  171|       |                "Invariant TSC is not supported on this platform, trace timestamps may be inaccurate"
  172|       |            );
  173|       |        }
  174|       |
  175|       |        let ret = Self {
  176|       |            epoch: std::time::Instant::now(),
  177|       |            tsc_freq: None,
  178|       |            guest_start_epoch: None,
  179|       |            guest_start_tsc: None,
  180|       |            file: Arc::new(Mutex::new(std::fs::File::create_new(path)?)),
  181|       |            #[cfg(feature = "unwind_guest")]
  182|       |            unwind_module,
  183|       |            #[cfg(feature = "unwind_guest")]
  184|       |            unwinder,
  185|       |            #[cfg(feature = "unwind_guest")]
  186|       |            unwind_cache,
  187|       |        };
  188|       |        /* write a frame identifying the binary */
  189|       |        #[cfg(feature = "unwind_guest")]
  190|       |        self::outb::record_trace_frame(&ret, 0, |f| {
  191|       |            let _ = f.write_all(hash.as_bytes());
  192|       |        })?;
  193|       |        Ok(ret)
  194|       |    }
  195|       |
  196|       |    /// Calculate the TSC frequency based on the RDTSC instruction on the host.
  197|       |    fn calculate_tsc_freq(&mut self) -> crate::Result<()> {
  198|       |        let (start, start_time) = match (
  199|       |            self.guest_start_tsc.as_ref(),
  200|       |            self.guest_start_epoch.as_ref(),
  201|       |        ) {
  202|       |            (Some(start), Some(start_time)) => (*start, *start_time),
  203|       |            _ => {
  204|       |                // If the guest start TSC and time are not set, we use the current time and TSC.
  205|       |                // This is not ideal, but it allows us to calculate the TSC frequency without
  206|       |                // failing.
  207|       |                // This is a fallback mechanism to ensure that we can still calculate, however it
  208|       |                // should be noted that this may lead to inaccuracies in the TSC frequency.
  209|       |                // The start time should be already set before running the guest for each sandbox.
  210|       |                log::error!(
  211|       |                    "Guest start TSC and time are not set. Calculating TSC frequency will use current time and TSC."
  212|       |                );
  213|       |                (
  214|       |                    hyperlight_guest_tracing::invariant_tsc::read_tsc(),
  215|       |                    std::time::Instant::now(),
  216|       |                )
  217|       |            }
  218|       |        };
  219|       |
  220|       |        let end_time = std::time::Instant::now();
  221|       |        let end = hyperlight_guest_tracing::invariant_tsc::read_tsc();
  222|       |
  223|       |        let elapsed = end_time.duration_since(start_time).as_secs_f64();
  224|       |        let tsc_freq = ((end - start) as f64 / elapsed) as u64;
  225|       |
  226|       |        log::info!("Calculated TSC frequency: {} Hz", tsc_freq);
  227|       |        self.tsc_freq = Some(tsc_freq);
  228|       |
  229|       |        Ok(())
  230|       |    }
  231|       |}
  232|       |
  233|       |pub(crate) trait WrapperGetter {
  234|       |    #[allow(dead_code)]
  235|       |    fn get_mgr_wrapper(&self) -> &MemMgrWrapper<HostSharedMemory>;
  236|       |    fn get_mgr_wrapper_mut(&mut self) -> &mut MemMgrWrapper<HostSharedMemory>;
  237|       |}
  238|       |
  239|       |#[cfg(test)]
  240|       |mod tests {
  241|       |    use std::sync::Arc;
  242|       |    use std::thread;
  243|       |
  244|       |    use crossbeam_queue::ArrayQueue;
  245|       |    use hyperlight_testing::simple_guest_as_string;
  246|       |
  247|       |    use crate::sandbox::uninitialized::GuestBinary;
  248|       |    use crate::{MultiUseSandbox, UninitializedSandbox, new_error};
  249|       |
  250|       |    #[test]
  251|       |    // TODO: add support for testing on WHP
  252|       |    #[cfg(target_os = "linux")]
  253|      1|    fn is_hypervisor_present() {
  254|       |        use std::path::Path;
  255|       |
  256|       |        cfg_if::cfg_if! {
  257|       |            if #[cfg(all(kvm, mshv))] {
  258|      1|                assert_eq!(Path::new("/dev/kvm").exists() || Path::new("/dev/mshv").exists(), super::is_hypervisor_present());
                                                                           ^0
  259|       |            } else if #[cfg(kvm)] {
  260|       |                assert_eq!(Path::new("/dev/kvm").exists(), super::is_hypervisor_present());
  261|       |            } else if #[cfg(mshv)] {
  262|       |                assert_eq!(Path::new("/dev/mshv").exists(), super::is_hypervisor_present());
  263|       |            } else {
  264|       |                assert!(!super::is_hypervisor_present());
  265|       |            }
  266|       |        }
  267|      0|    }
  268|       |
  269|       |    #[test]
  270|      1|    fn check_create_and_use_sandbox_on_different_threads() {
  271|      1|        let unintializedsandbox_queue = Arc::new(ArrayQueue::<UninitializedSandbox>::new(10));
  272|      1|        let sandbox_queue = Arc::new(ArrayQueue::<MultiUseSandbox>::new(10));
  273|       |
  274|     11|        for i in 0..10 {
                          ^10
  275|     10|            let simple_guest_path = simple_guest_as_string().expect("Guest Binary Missing");
  276|     10|            let unintializedsandbox =
  277|     10|                UninitializedSandbox::new(GuestBinary::FilePath(simple_guest_path), None)
  278|     10|                    .unwrap_or_else(|_| panic!("Failed to create UninitializedSandbox {}", i));
                                                      ^0
  279|     10|
  280|     10|            unintializedsandbox_queue
  281|     10|                .push(unintializedsandbox)
  282|     10|                .unwrap_or_else(|_| panic!("Failed to push UninitializedSandbox {}", i));
                                                  ^0
  283|     10|        }
  284|       |
  285|      1|        let thread_handles = (0..10)
  286|     10|            .map(|i| {
  287|     10|                let uq = unintializedsandbox_queue.clone();
  288|     10|                let sq = sandbox_queue.clone();
  289|     10|                thread::spawn(move || {
  290|     10|                    let uninitialized_sandbox = uq.pop().unwrap_or_else(|| {
  291|      0|                        panic!("Failed to pop UninitializedSandbox thread {}", i)
  292|     10|                    });
  293|     10|                    let host_funcs = uninitialized_sandbox
  294|     10|                        .host_funcs
  295|     10|                        .try_lock()
  296|     10|                        .map_err(|_| new_error!("Error locking"));
                                                              ^0
  297|     10|
  298|     10|                    assert!(host_funcs.is_ok());
  299|       |
  300|     10|                    host_funcs
  301|     10|                        .unwrap()
  302|     10|                        .host_print(format!(
  303|     10|                            "Printing from UninitializedSandbox on Thread {}\n",
  304|     10|                            i
  305|     10|                        ))
  306|     10|                        .unwrap();
  307|     10|
  308|     10|                    let sandbox = uninitialized_sandbox.evolve().unwrap_or_else(|_| {
  309|     10|                        panic!("Failed to initialize UninitializedSandbox thread {}", i)
  310|     10|                    });
  311|     10|
  312|     10|                    sq.push(sandbox).unwrap_or_else(|_| {
  313|      0|                        panic!("Failed to push UninitializedSandbox thread {}", i)
  314|     10|                    })
  315|     10|                })
  316|     10|            })
  317|      1|            .collect::<Vec<_>>();
  318|       |
  319|      1|        for handle in thread_handles {
                          ^0
  320|      0|            handle.join().unwrap();
  321|      0|        }
  322|       |
  323|      1|        let thread_handles = (0..10)
  324|      1|            .map(|i| {
  325|      0|                let sq = sandbox_queue.clone();
  326|      0|                thread::spawn(move || {
  327|      0|                    let sandbox = sq
  328|      0|                        .pop()
  329|      0|                        .unwrap_or_else(|| panic!("Failed to pop Sandbox thread {}", i));
  330|      0|                    let host_funcs = sandbox
  331|      0|                        ._host_funcs
  332|      0|                        .try_lock()
  333|      0|                        .map_err(|_| new_error!("Error locking"));
  334|      0|
  335|      0|                    assert!(host_funcs.is_ok());
  336|       |
  337|      0|                    host_funcs
  338|      0|                        .unwrap()
  339|      0|                        .host_print(format!("Print from Sandbox on Thread {}\n", i))
  340|      0|                        .unwrap();
  341|      0|                })
  342|      1|            })
  343|      1|            .collect::<Vec<_>>();
  344|       |
  345|  18.4E|        for handle in thread_handles {
                                    ^0
  346|  18.4E|            handle.join().unwrap();
  347|  18.4E|        }
  348|      1|    }
  349|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/outb.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(feature = "trace_guest")]
   18|       |use std::io::Write;
   19|       |use std::sync::{Arc, Mutex};
   20|       |
   21|       |#[cfg(feature = "unwind_guest")]
   22|       |use fallible_iterator::FallibleIterator;
   23|       |#[cfg(feature = "unwind_guest")]
   24|       |use framehop::Unwinder;
   25|       |use hyperlight_common::flatbuffer_wrappers::function_types::ParameterValue;
   26|       |use hyperlight_common::flatbuffer_wrappers::guest_error::ErrorCode;
   27|       |use hyperlight_common::flatbuffer_wrappers::guest_log_data::GuestLogData;
   28|       |use hyperlight_common::outb::{Exception, OutBAction};
   29|       |#[cfg(feature = "trace_guest")]
   30|       |use hyperlight_guest_tracing::TraceRecord;
   31|       |use log::{Level, Record};
   32|       |use tracing::{Span, instrument};
   33|       |use tracing_log::format_trace;
   34|       |
   35|       |use super::host_funcs::FunctionRegistry;
   36|       |use super::mem_mgr::MemMgrWrapper;
   37|       |#[cfg(feature = "trace_guest")]
   38|       |use crate::hypervisor::Hypervisor;
   39|       |#[cfg(feature = "trace_guest")]
   40|       |use crate::mem::layout::SandboxMemoryLayout;
   41|       |use crate::mem::mgr::SandboxMemoryManager;
   42|       |use crate::mem::shared_mem::HostSharedMemory;
   43|       |#[cfg(feature = "trace_guest")]
   44|       |use crate::sandbox::TraceInfo;
   45|       |use crate::{HyperlightError, Result, new_error};
   46|       |
   47|       |#[instrument(err(Debug), skip_all, parent = Span::current(), level="Trace")]
   48|      0|pub(super) fn outb_log(mgr: &mut SandboxMemoryManager<HostSharedMemory>) -> Result<()> {
   49|       |    // This code will create either a logging record or a tracing record for the GuestLogData depending on if the host has set up a tracing subscriber.
   50|       |    // In theory as we have enabled the log feature in the Cargo.toml for tracing this should happen
   51|       |    // automatically (based on if there is tracing subscriber present) but only works if the event created using macros. (see https://github.com/tokio-rs/tracing/blob/master/tracing/src/macros.rs#L2421 )
   52|       |    // The reason that we don't want to use the tracing macros is that we want to be able to explicitly
   53|       |    // set the file and line number for the log record which is not possible with macros.
   54|       |    // This is because the file and line number come from the  guest not the call site.
   55|       |
   56|       |    let log_data: GuestLogData = mgr.read_guest_log_data()?;
   57|       |
   58|       |    let record_level: Level = (&log_data.level).into();
   59|       |
   60|       |    // Work out if we need to log or trace
   61|       |    // this API is marked as follows but it is the easiest way to work out if we should trace or log
   62|       |
   63|       |    // Private API for internal use by tracing's macros.
   64|       |    //
   65|       |    // This function is *not* considered part of `tracing`'s public API, and has no
   66|       |    // stability guarantees. If you use it, and it breaks or disappears entirely,
   67|       |    // don't say we didn't warn you.
   68|       |
   69|       |    let should_trace = tracing_core::dispatcher::has_been_set();
   70|       |    let source_file = Some(log_data.source_file.as_str());
   71|       |    let line = Some(log_data.line);
   72|       |    let source = Some(log_data.source.as_str());
   73|       |
   74|       |    // See https://github.com/rust-lang/rust/issues/42253 for the reason this has to be done this way
   75|       |
   76|       |    if should_trace {
   77|       |        // Create a tracing event for the GuestLogData
   78|       |        // Ideally we would create tracing metadata based on the Guest Log Data
   79|       |        // but tracing derives the metadata at compile time
   80|       |        // see https://github.com/tokio-rs/tracing/issues/2419
   81|       |        // so we leave it up to the subscriber to figure out that there are logging fields present with this data
   82|       |        format_trace(
   83|       |            &Record::builder()
   84|       |                .args(format_args!("{}", log_data.message))
   85|       |                .level(record_level)
   86|       |                .target("hyperlight_guest")
   87|       |                .file(source_file)
   88|       |                .line(line)
   89|       |                .module_path(source)
   90|       |                .build(),
   91|       |        )?;
   92|       |    } else {
   93|       |        // Create a log record for the GuestLogData
   94|       |        log::logger().log(
   95|       |            &Record::builder()
   96|       |                .args(format_args!("{}", log_data.message))
   97|       |                .level(record_level)
   98|       |                .target("hyperlight_guest")
   99|       |                .file(Some(&log_data.source_file))
  100|       |                .line(Some(log_data.line))
  101|       |                .module_path(Some(&log_data.source))
  102|       |                .build(),
  103|       |        );
  104|       |    }
  105|       |
  106|       |    Ok(())
  107|      0|}
  108|       |
  109|       |const ABORT_TERMINATOR: u8 = 0xFF;
  110|       |const MAX_ABORT_BUFFER_LEN: usize = 1024;
  111|       |
  112|      0|fn outb_abort(mem_mgr: &mut MemMgrWrapper<HostSharedMemory>, data: u32) -> Result<()> {
  113|      0|    let buffer = mem_mgr.get_abort_buffer_mut();
  114|      0|
  115|      0|    let bytes = data.to_le_bytes(); // [len, b1, b2, b3]
  116|      0|    let len = bytes[0].min(3);
  117|       |
  118|      0|    for &b in &bytes[1..=len as usize] {
  119|      0|        if b == ABORT_TERMINATOR {
  120|      0|            let guest_error_code = *buffer.first().unwrap_or(&0);
  121|      0|            let guest_error = ErrorCode::from(guest_error_code as u64);
  122|       |
  123|      0|            let result = match guest_error {
  124|      0|                ErrorCode::StackOverflow => Err(HyperlightError::StackOverflow()),
  125|       |                _ => {
  126|      0|                    let message = if let Some(&maybe_exception_code) = buffer.get(1) {
  127|      0|                        match Exception::try_from(maybe_exception_code) {
  128|      0|                            Ok(exception) => {
  129|      0|                                let extra_msg = String::from_utf8_lossy(&buffer[2..]);
  130|      0|                                format!("Exception: {:?} | {}", exception, extra_msg)
  131|       |                            }
  132|      0|                            Err(_) => String::from_utf8_lossy(&buffer[1..]).into(),
  133|       |                        }
  134|       |                    } else {
  135|      0|                        String::new()
  136|       |                    };
  137|       |
  138|      0|                    Err(HyperlightError::GuestAborted(guest_error_code, message))
  139|       |                }
  140|       |            };
  141|       |
  142|      0|            buffer.clear();
  143|      0|            return result;
  144|      0|        }
  145|      0|
  146|      0|        if buffer.len() >= MAX_ABORT_BUFFER_LEN {
  147|      0|            buffer.clear();
  148|      0|            return Err(HyperlightError::GuestAborted(
  149|      0|                0,
  150|      0|                "Guest abort buffer overflowed".into(),
  151|      0|            ));
  152|      0|        }
  153|      0|
  154|      0|        buffer.push(b);
  155|       |    }
  156|      0|    Ok(())
  157|      0|}
  158|       |
  159|       |#[cfg(feature = "unwind_guest")]
  160|       |fn unwind(
  161|       |    hv: &dyn Hypervisor,
  162|       |    mem: &SandboxMemoryManager<HostSharedMemory>,
  163|       |    trace_info: &TraceInfo,
  164|       |) -> Result<Vec<u64>> {
  165|       |    let mut read_stack = |addr| {
  166|       |        mem.shared_mem
  167|       |            .read::<u64>((addr - SandboxMemoryLayout::BASE_ADDRESS as u64) as usize)
  168|       |            .map_err(|_| ())
  169|       |    };
  170|       |    let mut cache = trace_info
  171|       |        .unwind_cache
  172|       |        .try_lock()
  173|       |        .map_err(|e| new_error!("could not lock unwinder cache {}\n", e))?;
  174|       |    let iter = trace_info.unwinder.iter_frames(
  175|       |        hv.read_trace_reg(crate::hypervisor::TraceRegister::RIP)?,
  176|       |        framehop::x86_64::UnwindRegsX86_64::new(
  177|       |            hv.read_trace_reg(crate::hypervisor::TraceRegister::RIP)?,
  178|       |            hv.read_trace_reg(crate::hypervisor::TraceRegister::RSP)?,
  179|       |            hv.read_trace_reg(crate::hypervisor::TraceRegister::RBP)?,
  180|       |        ),
  181|       |        &mut *cache,
  182|       |        &mut read_stack,
  183|       |    );
  184|       |    iter.map(|f| Ok(f.address() - mem.layout.get_guest_code_address() as u64))
  185|       |        .collect()
  186|       |        .map_err(|e| new_error!("couldn't unwind: {}", e))
  187|       |}
  188|       |
  189|       |#[cfg(feature = "unwind_guest")]
  190|       |fn write_stack(out: &mut std::fs::File, stack: &[u64]) {
  191|       |    let _ = out.write_all(&stack.len().to_ne_bytes());
  192|       |    for frame in stack {
  193|       |        let _ = out.write_all(&frame.to_ne_bytes());
  194|       |    }
  195|       |}
  196|       |
  197|       |#[cfg(feature = "unwind_guest")]
  198|       |pub(super) fn record_trace_frame<F: FnOnce(&mut std::fs::File)>(
  199|       |    trace_info: &TraceInfo,
  200|       |    frame_id: u64,
  201|       |    write_frame: F,
  202|       |) -> Result<()> {
  203|       |    let Ok(mut out) = trace_info.file.lock() else {
  204|       |        return Ok(());
  205|       |    };
  206|       |    // frame structure:
  207|       |    // 16 bytes timestamp
  208|       |    let now = std::time::Instant::now().saturating_duration_since(trace_info.epoch);
  209|       |    let _ = out.write_all(&now.as_micros().to_ne_bytes());
  210|       |    // 8 bytes frame type id
  211|       |    let _ = out.write_all(&frame_id.to_ne_bytes());
  212|       |    // frame data
  213|       |    write_frame(&mut out);
  214|       |    Ok(())
  215|       |}
  216|       |
  217|       |#[cfg(feature = "trace_guest")]
  218|       |pub(super) fn record_guest_trace_frame<F: FnOnce(&mut std::fs::File)>(
  219|       |    trace_info: &TraceInfo,
  220|       |    frame_id: u64,
  221|       |    cycles: u64,
  222|       |    write_frame: F,
  223|       |) -> Result<()> {
  224|       |    let Ok(mut out) = trace_info.file.lock() else {
  225|       |        return Ok(());
  226|       |    };
  227|       |    // frame structure:
  228|       |    // 16 bytes timestamp
  229|       |
  230|       |    // The number of cycles spent in the guest relative to the first received trace record
  231|       |    let cycles_spent = cycles
  232|       |        - trace_info
  233|       |            .guest_start_tsc
  234|       |            .as_ref()
  235|       |            .map_or_else(|| 0, |c| *c);
  236|       |
  237|       |    // Convert cycles to microseconds based on the TSC frequency
  238|       |    let tsc_freq = trace_info
  239|       |        .tsc_freq
  240|       |        .as_ref()
  241|       |        .ok_or_else(|| new_error!("TSC frequency not set in TraceInfo"))?;
  242|       |    let micros = cycles_spent as f64 / *tsc_freq as f64 * 1_000_000f64;
  243|       |
  244|       |    // Convert to a Duration
  245|       |    let guest_duration = std::time::Duration::from_micros(micros as u64);
  246|       |
  247|       |    // Calculate the time when the guest started execution relative to the host epoch
  248|       |    // Note: This is relative to the time saved when the `TraceInfo` was created (before the
  249|       |    // Hypervisor is created).
  250|       |    let guest_start_time = trace_info
  251|       |        .guest_start_epoch
  252|       |        .as_ref()
  253|       |        .unwrap_or(&trace_info.epoch)
  254|       |        .saturating_duration_since(trace_info.epoch);
  255|       |
  256|       |    // Calculate the timestamp when the actual frame was recorded relative to the host epoch
  257|       |    let timestamp = guest_start_time
  258|       |        .checked_add(guest_duration)
  259|       |        .unwrap_or(guest_duration);
  260|       |
  261|       |    let _ = out.write_all(&timestamp.as_micros().to_ne_bytes());
  262|       |    // 8 bytes frame type id
  263|       |    let _ = out.write_all(&frame_id.to_ne_bytes());
  264|       |    // frame data
  265|       |    write_frame(&mut out);
  266|       |    Ok(())
  267|       |}
  268|       |
  269|       |/// Handles OutB operations from the guest.
  270|       |#[instrument(err(Debug), skip_all, parent = Span::current(), level= "Trace")]
  271|      0|pub(crate) fn handle_outb(
  272|      0|    mem_mgr: &mut MemMgrWrapper<HostSharedMemory>,
  273|      0|    host_funcs: Arc<Mutex<FunctionRegistry>>,
  274|      0|    #[cfg(feature = "trace_guest")] _hv: &mut dyn Hypervisor,
  275|      0|    port: u16,
  276|      0|    data: u32,
  277|      0|) -> Result<()> {
  278|       |    match port.try_into()? {
  279|       |        OutBAction::Log => outb_log(mem_mgr.as_mut()),
  280|       |        OutBAction::CallFunction => {
  281|       |            let call = mem_mgr.as_mut().get_host_function_call()?; // pop output buffer
  282|       |            let name = call.function_name.clone();
  283|       |            let args: Vec<ParameterValue> = call.parameters.unwrap_or(vec![]);
  284|       |            let res = host_funcs
  285|       |                .try_lock()
  286|      0|                .map_err(|e| new_error!("Error locking at {}:{}: {}", file!(), line!(), e))?
  287|       |                .call_host_function(&name, args)?;
  288|       |            mem_mgr
  289|       |                .as_mut()
  290|       |                .write_response_from_host_method_call(&res)?; // push input buffers
  291|       |
  292|       |            Ok(())
  293|       |        }
  294|       |        OutBAction::Abort => outb_abort(mem_mgr, data),
  295|       |        OutBAction::DebugPrint => {
  296|       |            let ch: char = match char::from_u32(data) {
  297|       |                Some(c) => c,
  298|       |                None => {
  299|       |                    return Err(new_error!("Invalid character for logging: {}", data));
  300|       |                }
  301|       |            };
  302|       |
  303|       |            eprint!("{}", ch);
  304|       |            Ok(())
  305|       |        }
  306|       |        #[cfg(feature = "unwind_guest")]
  307|       |        OutBAction::TraceRecordStack => {
  308|       |            let Ok(stack) = unwind(_hv, mem_mgr.as_ref(), _hv.trace_info_as_ref()) else {
  309|       |                return Ok(());
  310|       |            };
  311|       |            record_trace_frame(_hv.trace_info_as_ref(), 1u64, |f| {
  312|       |                write_stack(f, &stack);
  313|       |            })
  314|       |        }
  315|       |        #[cfg(feature = "mem_profile")]
  316|       |        OutBAction::TraceMemoryAlloc => {
  317|       |            let Ok(stack) = unwind(_hv, mem_mgr.as_ref(), _hv.trace_info_as_ref()) else {
  318|       |                return Ok(());
  319|       |            };
  320|       |            let Ok(amt) = _hv.read_trace_reg(crate::hypervisor::TraceRegister::RAX) else {
  321|       |                return Ok(());
  322|       |            };
  323|       |            let Ok(ptr) = _hv.read_trace_reg(crate::hypervisor::TraceRegister::RCX) else {
  324|       |                return Ok(());
  325|       |            };
  326|       |            record_trace_frame(_hv.trace_info_as_ref(), 2u64, |f| {
  327|       |                let _ = f.write_all(&ptr.to_ne_bytes());
  328|       |                let _ = f.write_all(&amt.to_ne_bytes());
  329|       |                write_stack(f, &stack);
  330|       |            })
  331|       |        }
  332|       |        #[cfg(feature = "mem_profile")]
  333|       |        OutBAction::TraceMemoryFree => {
  334|       |            let Ok(stack) = unwind(_hv, mem_mgr.as_ref(), _hv.trace_info_as_ref()) else {
  335|       |                return Ok(());
  336|       |            };
  337|       |            let Ok(ptr) = _hv.read_trace_reg(crate::hypervisor::TraceRegister::RCX) else {
  338|       |                return Ok(());
  339|       |            };
  340|       |            record_trace_frame(_hv.trace_info_as_ref(), 3u64, |f| {
  341|       |                let _ = f.write_all(&ptr.to_ne_bytes());
  342|       |                write_stack(f, &stack);
  343|       |            })
  344|       |        }
  345|       |        #[cfg(feature = "trace_guest")]
  346|       |        OutBAction::TraceRecord => {
  347|       |            let Ok(len) = _hv.read_trace_reg(crate::hypervisor::TraceRegister::RAX) else {
  348|       |                return Ok(());
  349|       |            };
  350|       |            let Ok(ptr) = _hv.read_trace_reg(crate::hypervisor::TraceRegister::RCX) else {
  351|       |                return Ok(());
  352|       |            };
  353|       |            let mut buffer = vec![0u8; len as usize * std::mem::size_of::<TraceRecord>()];
  354|       |            let buffer = &mut buffer[..];
  355|       |
  356|       |            // Read the trace records from the guest memory
  357|       |            mem_mgr
  358|       |                .as_ref()
  359|       |                .shared_mem
  360|       |                .copy_to_slice(buffer, ptr as usize - SandboxMemoryLayout::BASE_ADDRESS)
  361|       |                .map_err(|e| {
  362|       |                    new_error!(
  363|       |                        "Failed to copy trace records from guest memory to host: {:?}",
  364|       |                        e
  365|       |                    )
  366|       |                })?;
  367|       |
  368|       |            let traces = unsafe {
  369|       |                std::slice::from_raw_parts(buffer.as_ptr() as *const TraceRecord, len as usize)
  370|       |            };
  371|       |
  372|       |            {
  373|       |                let trace_info = _hv.trace_info_as_mut();
  374|       |
  375|       |                // Calculate the TSC frequency based on the current TSC reading
  376|       |                // This is done only once, when the first trace record is received
  377|       |                // Ideally, we should use a timer or a clock to measure the time elapsed,
  378|       |                // but that adds delays.
  379|       |                // To avoid that we store the TSC value and a timestamp right
  380|       |                // before starting the guest execution and then calculate the TSC frequency when
  381|       |                // the first trace record is received, based on the current TSC value and clock.
  382|       |                if trace_info.tsc_freq.is_none() {
  383|       |                    trace_info.calculate_tsc_freq()?;
  384|       |
  385|       |                    // After the TSC frequency is calculated, we no longer need the value of TSC
  386|       |                    // recorded on the host when the guest started, so we can set the guest_start_tsc field
  387|       |                    // to store the TSC value recorded on the guest when the guest started executing.
  388|       |                    // This is used to calculate the records timestamps relative to the first trace record.
  389|       |                    if !traces.is_empty() {
  390|       |                        trace_info.guest_start_tsc = Some(traces[0].cycles);
  391|       |                    }
  392|       |                }
  393|       |            }
  394|       |
  395|       |            for record in traces {
  396|       |                record_guest_trace_frame(_hv.trace_info_as_ref(), 4u64, record.cycles, |f| {
  397|       |                    let _ = f.write_all(&record.msg_len.to_ne_bytes());
  398|       |                    let _ = f.write_all(&record.msg[..record.msg_len]);
  399|       |                })?
  400|       |            }
  401|       |
  402|       |            Ok(())
  403|       |        }
  404|       |    }
  405|      0|}
  406|       |#[cfg(test)]
  407|       |mod tests {
  408|       |    use hyperlight_common::flatbuffer_wrappers::guest_log_level::LogLevel;
  409|       |    use hyperlight_testing::logger::{LOGGER, Logger};
  410|       |    use log::Level;
  411|       |    use tracing_core::callsite::rebuild_interest_cache;
  412|       |
  413|       |    use super::outb_log;
  414|       |    use crate::mem::layout::SandboxMemoryLayout;
  415|       |    use crate::mem::mgr::SandboxMemoryManager;
  416|       |    use crate::mem::shared_mem::SharedMemory;
  417|       |    use crate::sandbox::SandboxConfiguration;
  418|       |    use crate::sandbox::outb::GuestLogData;
  419|       |    use crate::testing::log_values::test_value_as_str;
  420|       |    use crate::testing::simple_guest_exe_info;
  421|       |
  422|      0|    fn new_guest_log_data(level: LogLevel) -> GuestLogData {
  423|      0|        GuestLogData::new(
  424|      0|            "test log".to_string(),
  425|      0|            "test source".to_string(),
  426|      0|            level,
  427|      0|            "test caller".to_string(),
  428|      0|            "test source file".to_string(),
  429|      0|            123,
  430|      0|        )
  431|      0|    }
  432|       |
  433|       |    #[test]
  434|       |    #[ignore]
  435|      0|    fn test_log_outb_log() {
  436|      0|        Logger::initialize_test_logger();
  437|      0|        LOGGER.set_max_level(log::LevelFilter::Off);
  438|      0|
  439|      0|        let sandbox_cfg = SandboxConfiguration::default();
  440|      0|
  441|      0|        let new_mgr = || {
  442|      0|            let exe_info = simple_guest_exe_info().unwrap();
  443|      0|            let (mut mgr, _) =
  444|      0|                SandboxMemoryManager::load_guest_binary_into_memory(sandbox_cfg, exe_info, None)
  445|      0|                    .unwrap();
  446|      0|            let mem_size = mgr.get_shared_mem_mut().mem_size();
  447|      0|            let layout = mgr.layout;
  448|      0|            let shared_mem = mgr.get_shared_mem_mut();
  449|      0|            layout
  450|      0|                .write(shared_mem, SandboxMemoryLayout::BASE_ADDRESS, mem_size)
  451|      0|                .unwrap();
  452|      0|            let (hmgr, _) = mgr.build();
  453|      0|            hmgr
  454|      0|        };
  455|       |        {
  456|       |            // We set a logger but there is no guest log data
  457|       |            // in memory, so expect a log operation to fail
  458|      0|            let mut mgr = new_mgr();
  459|      0|            assert!(outb_log(&mut mgr).is_err());
  460|       |        }
  461|       |        {
  462|       |            // Write a log message so outb_log will succeed.
  463|       |            // Since the logger level is set off, expect logs to be no-ops
  464|      0|            let mut mgr = new_mgr();
  465|      0|            let log_msg = new_guest_log_data(LogLevel::Information);
  466|      0|
  467|      0|            let guest_log_data_buffer: Vec<u8> = log_msg.try_into().unwrap();
  468|      0|            let offset = mgr.layout.get_output_data_offset();
  469|      0|            mgr.get_shared_mem_mut()
  470|      0|                .push_buffer(
  471|      0|                    offset,
  472|      0|                    sandbox_cfg.get_output_data_size(),
  473|      0|                    &guest_log_data_buffer,
  474|      0|                )
  475|      0|                .unwrap();
  476|      0|
  477|      0|            let res = outb_log(&mut mgr);
  478|      0|            assert!(res.is_ok());
  479|      0|            assert_eq!(0, LOGGER.num_log_calls());
  480|      0|            LOGGER.clear_log_calls();
  481|      0|        }
  482|      0|        {
  483|      0|            // now, test logging
  484|      0|            LOGGER.set_max_level(log::LevelFilter::Trace);
  485|      0|            let mut mgr = new_mgr();
  486|      0|            LOGGER.clear_log_calls();
  487|      0|
  488|      0|            // set up the logger and set the log level to the maximum
  489|      0|            // possible (Trace) to ensure we're able to test all
  490|      0|            // the possible branches of the match in outb_log
  491|      0|
  492|      0|            let levels = vec![
  493|      0|                LogLevel::Trace,
  494|      0|                LogLevel::Debug,
  495|      0|                LogLevel::Information,
  496|      0|                LogLevel::Warning,
  497|      0|                LogLevel::Error,
  498|      0|                LogLevel::Critical,
  499|      0|                LogLevel::None,
  500|      0|            ];
  501|      0|            for level in levels {
  502|      0|                let layout = mgr.layout;
  503|      0|                let log_data = new_guest_log_data(level);
  504|      0|
  505|      0|                let guest_log_data_buffer: Vec<u8> = log_data.clone().try_into().unwrap();
  506|      0|                mgr.get_shared_mem_mut()
  507|      0|                    .push_buffer(
  508|      0|                        layout.get_output_data_offset(),
  509|      0|                        sandbox_cfg.get_output_data_size(),
  510|      0|                        guest_log_data_buffer.as_slice(),
  511|      0|                    )
  512|      0|                    .unwrap();
  513|      0|
  514|      0|                outb_log(&mut mgr).unwrap();
  515|      0|
  516|      0|                LOGGER.test_log_records(|log_calls| {
  517|      0|                    let expected_level: Level = (&level).into();
  518|      0|
  519|      0|                    assert!(
  520|      0|                        log_calls
  521|      0|                            .iter()
  522|      0|                            .filter(|log_call| {
  523|      0|                                log_call.level == expected_level
  524|      0|                                    && log_call.line == Some(log_data.line)
  525|      0|                                    && log_call.args == log_data.message
  526|      0|                                    && log_call.module_path == Some(log_data.source.clone())
  527|      0|                                    && log_call.file == Some(log_data.source_file.clone())
  528|      0|                            })
  529|      0|                            .count()
  530|      0|                            == 1,
  531|      0|                        "log call did not occur for level {:?}",
  532|      0|                        level.clone()
  533|       |                    );
  534|      0|                });
  535|      0|            }
  536|       |        }
  537|      0|    }
  538|       |
  539|       |    // Tests that outb_log emits traces when a trace subscriber is set
  540|       |    // this test is ignored because it is incompatible with other tests , specifically those which require a logger for tracing
  541|       |    // marking  this test as ignored means that running `cargo test` will not run this test but will allow a developer who runs that command
  542|       |    // from their workstation to be successful without needed to know about test interdependencies
  543|       |    // this test will be run explicitly as a part of the CI pipeline
  544|       |    #[ignore]
  545|       |    #[test]
  546|      0|    fn test_trace_outb_log() {
  547|      0|        Logger::initialize_log_tracer();
  548|      0|        rebuild_interest_cache();
  549|      0|        let subscriber =
  550|      0|            hyperlight_testing::tracing_subscriber::TracingSubscriber::new(tracing::Level::TRACE);
  551|      0|        let sandbox_cfg = SandboxConfiguration::default();
  552|      0|        tracing::subscriber::with_default(subscriber.clone(), || {
  553|      0|            let new_mgr = || {
  554|      0|                let exe_info = simple_guest_exe_info().unwrap();
  555|      0|                let (mut mgr, _) = SandboxMemoryManager::load_guest_binary_into_memory(
  556|      0|                    sandbox_cfg,
  557|      0|                    exe_info,
  558|      0|                    None,
  559|      0|                )
  560|      0|                .unwrap();
  561|      0|                let mem_size = mgr.get_shared_mem_mut().mem_size();
  562|      0|                let layout = mgr.layout;
  563|      0|                let shared_mem = mgr.get_shared_mem_mut();
  564|      0|                layout
  565|      0|                    .write(shared_mem, SandboxMemoryLayout::BASE_ADDRESS, mem_size)
  566|      0|                    .unwrap();
  567|      0|                let (hmgr, _) = mgr.build();
  568|      0|                hmgr
  569|      0|            };
  570|       |
  571|       |            // as a span does not exist one will be automatically created
  572|       |            // after that there will be an event for each log message
  573|       |            // we are interested only in the events for the log messages that we created
  574|       |
  575|      0|            let levels = vec![
  576|      0|                LogLevel::Trace,
  577|      0|                LogLevel::Debug,
  578|      0|                LogLevel::Information,
  579|      0|                LogLevel::Warning,
  580|      0|                LogLevel::Error,
  581|      0|                LogLevel::Critical,
  582|      0|                LogLevel::None,
  583|      0|            ];
  584|      0|            for level in levels {
  585|      0|                let mut mgr = new_mgr();
  586|      0|                let layout = mgr.layout;
  587|      0|                let log_data: GuestLogData = new_guest_log_data(level);
  588|      0|                subscriber.clear();
  589|      0|
  590|      0|                let guest_log_data_buffer: Vec<u8> = log_data.try_into().unwrap();
  591|      0|                mgr.get_shared_mem_mut()
  592|      0|                    .push_buffer(
  593|      0|                        layout.get_output_data_offset(),
  594|      0|                        sandbox_cfg.get_output_data_size(),
  595|      0|                        guest_log_data_buffer.as_slice(),
  596|      0|                    )
  597|      0|                    .unwrap();
  598|      0|                subscriber.clear();
  599|      0|                outb_log(&mut mgr).unwrap();
  600|      0|
  601|      0|                subscriber.test_trace_records(|spans, events| {
  602|      0|                    let expected_level = match level {
  603|      0|                        LogLevel::Trace => "TRACE",
  604|      0|                        LogLevel::Debug => "DEBUG",
  605|      0|                        LogLevel::Information => "INFO",
  606|      0|                        LogLevel::Warning => "WARN",
  607|      0|                        LogLevel::Error => "ERROR",
  608|      0|                        LogLevel::Critical => "ERROR",
  609|      0|                        LogLevel::None => "TRACE",
  610|       |                    };
  611|       |
  612|       |                    // We cannot get the parent span using the `current_span()` method as by the time we get to this point that span has been exited so there is no current span
  613|       |                    // We need to make sure that the span that we created is in the spans map instead
  614|       |                    // We expect to have created 21 spans at this point. We are only interested in the first one that was created when calling outb_log.
  615|       |
  616|      0|                    assert!(
  617|      0|                        spans.len() == 21,
  618|      0|                        "expected 21 spans, found {}",
  619|      0|                        spans.len()
  620|       |                    );
  621|       |
  622|      0|                    let span_value = spans
  623|      0|                        .get(&1)
  624|      0|                        .unwrap()
  625|      0|                        .as_object()
  626|      0|                        .unwrap()
  627|      0|                        .get("span")
  628|      0|                        .unwrap()
  629|      0|                        .get("attributes")
  630|      0|                        .unwrap()
  631|      0|                        .as_object()
  632|      0|                        .unwrap()
  633|      0|                        .get("metadata")
  634|      0|                        .unwrap()
  635|      0|                        .as_object()
  636|      0|                        .unwrap();
  637|      0|
  638|      0|                    //test_value_as_str(span_value, "level", "INFO");
  639|      0|                    test_value_as_str(span_value, "module_path", "hyperlight_host::sandbox::outb");
  640|      0|                    let expected_file = if cfg!(windows) {
  641|      0|                        "src\\hyperlight_host\\src\\sandbox\\outb.rs"
  642|       |                    } else {
  643|      0|                        "src/hyperlight_host/src/sandbox/outb.rs"
  644|       |                    };
  645|      0|                    test_value_as_str(span_value, "file", expected_file);
  646|      0|                    test_value_as_str(span_value, "target", "hyperlight_host::sandbox::outb");
  647|      0|
  648|      0|                    let mut count_matching_events = 0;
  649|       |
  650|      0|                    for json_value in events {
  651|      0|                        let event_values = json_value.as_object().unwrap().get("event").unwrap();
  652|      0|                        let metadata_values_map =
  653|      0|                            event_values.get("metadata").unwrap().as_object().unwrap();
  654|      0|                        let event_values_map = event_values.as_object().unwrap();
  655|      0|                        test_value_as_str(metadata_values_map, "level", expected_level);
  656|      0|                        test_value_as_str(event_values_map, "log.file", "test source file");
  657|      0|                        test_value_as_str(event_values_map, "log.module_path", "test source");
  658|      0|                        test_value_as_str(event_values_map, "log.target", "hyperlight_guest");
  659|      0|                        count_matching_events += 1;
  660|      0|                    }
  661|      0|                    assert!(
  662|      0|                        count_matching_events == 1,
  663|      0|                        "trace log call did not occur for level {:?}",
  664|      0|                        level.clone()
  665|       |                    );
  666|      0|                });
  667|      0|            }
  668|      0|        });
  669|      0|    }
  670|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/uninitialized.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::fmt::Debug;
   18|       |use std::option::Option;
   19|       |use std::path::Path;
   20|       |use std::sync::{Arc, Mutex};
   21|       |
   22|       |use log::LevelFilter;
   23|       |use tracing::{Span, instrument};
   24|       |
   25|       |use super::host_funcs::{FunctionRegistry, default_writer_func};
   26|       |use super::mem_mgr::MemMgrWrapper;
   27|       |use super::uninitialized_evolve::evolve_impl_multi_use;
   28|       |use crate::func::host_functions::{HostFunction, register_host_function};
   29|       |use crate::func::{ParameterTuple, SupportedReturnType};
   30|       |#[cfg(feature = "build-metadata")]
   31|       |use crate::log_build_details;
   32|       |use crate::mem::exe::ExeInfo;
   33|       |use crate::mem::memory_region::{DEFAULT_GUEST_BLOB_MEM_FLAGS, MemoryRegionFlags};
   34|       |use crate::mem::mgr::{STACK_COOKIE_LEN, SandboxMemoryManager};
   35|       |use crate::mem::shared_mem::ExclusiveSharedMemory;
   36|       |use crate::sandbox::SandboxConfiguration;
   37|       |use crate::{MultiUseSandbox, Result, new_error};
   38|       |
   39|       |#[cfg(all(target_os = "linux", feature = "seccomp"))]
   40|       |const EXTRA_ALLOWED_SYSCALLS_FOR_WRITER_FUNC: &[super::ExtraAllowedSyscall] = &[
   41|       |    // Fuzzing fails without `mmap` being an allowed syscall on our seccomp filter.
   42|       |    // All fuzzing does is call `PrintOutput` (which calls `HostPrint` ). Thing is, `println!`
   43|       |    // is designed to be thread-safe in Rust and the std lib ensures this by using
   44|       |    // buffered I/O, which I think relies on `mmap`. This gets surfaced in fuzzing with an
   45|       |    // OOM error, which I think is happening because `println!` is not being able to allocate
   46|       |    // more memory for its buffers for the fuzzer's huge inputs.
   47|       |    libc::SYS_mmap,
   48|       |    libc::SYS_brk,
   49|       |    libc::SYS_mprotect,
   50|       |    #[cfg(mshv)]
   51|       |    libc::SYS_close,
   52|       |];
   53|       |
   54|       |#[cfg(any(crashdump, gdb))]
   55|       |#[derive(Clone, Debug, Default)]
   56|       |pub(crate) struct SandboxRuntimeConfig {
   57|       |    #[cfg(crashdump)]
   58|       |    pub(crate) binary_path: Option<String>,
   59|       |    #[cfg(gdb)]
   60|       |    pub(crate) debug_info: Option<super::config::DebugInfo>,
   61|       |    #[cfg(crashdump)]
   62|       |    pub(crate) guest_core_dump: bool,
   63|       |}
   64|       |
   65|       |/// A preliminary sandbox that represents allocated memory and registered host functions,
   66|       |/// but has not yet created the underlying virtual machine.
   67|       |///
   68|       |/// This struct holds the configuration and setup needed for a sandbox without actually
   69|       |/// creating the VM. It allows you to:
   70|       |/// - Set up memory layout and load guest binary data
   71|       |/// - Register host functions that will be available to the guest
   72|       |/// - Configure sandbox settings before VM creation
   73|       |///
   74|       |/// The virtual machine is not created until you call [`evolve`](Self::evolve) to transform
   75|       |/// this into an initialized [`MultiUseSandbox`].
   76|       |pub struct UninitializedSandbox {
   77|       |    /// Registered host functions
   78|       |    pub(crate) host_funcs: Arc<Mutex<FunctionRegistry>>,
   79|       |    /// The memory manager for the sandbox.
   80|       |    pub(crate) mgr: MemMgrWrapper<ExclusiveSharedMemory>,
   81|       |    pub(crate) max_guest_log_level: Option<LevelFilter>,
   82|       |    pub(crate) config: SandboxConfiguration,
   83|       |    #[cfg(any(crashdump, gdb))]
   84|       |    pub(crate) rt_cfg: SandboxRuntimeConfig,
   85|       |    pub(crate) load_info: crate::mem::exe::LoadInfo,
   86|       |}
   87|       |
   88|       |impl Debug for UninitializedSandbox {
   89|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   90|      0|        f.debug_struct("UninitializedSandbox")
   91|      0|            .field("memory_layout", &self.mgr.unwrap_mgr().layout)
   92|      0|            .finish()
   93|      0|    }
   94|       |}
   95|       |
   96|       |impl UninitializedSandbox {
   97|       |    /// Creates and initializes the virtual machine, transforming this into a ready-to-use sandbox.
   98|       |    ///
   99|       |    /// This method consumes the `UninitializedSandbox` and performs the final initialization
  100|       |    /// steps to create the underlying virtual machine. Once evolved, the resulting
  101|       |    /// [`MultiUseSandbox`] can execute guest code and handle function calls.
  102|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  103|     58|    pub fn evolve(self) -> Result<MultiUseSandbox> {
  104|       |        evolve_impl_multi_use(self)
  105|     58|    }
  106|       |}
  107|       |
  108|       |/// A `GuestBinary` is either a buffer or the file path to some data (e.g., a guest binary).
  109|       |#[derive(Debug)]
  110|       |pub enum GuestBinary<'a> {
  111|       |    /// A buffer containing the GuestBinary
  112|       |    Buffer(&'a [u8]),
  113|       |    /// A path to the GuestBinary
  114|       |    FilePath(String),
  115|       |}
  116|       |
  117|       |/// A `GuestBlob` containing data and the permissions for its use.
  118|       |#[derive(Debug)]
  119|       |pub struct GuestBlob<'a> {
  120|       |    /// The data contained in the blob.
  121|       |    pub data: &'a [u8],
  122|       |    /// The permissions for the blob in memory.
  123|       |    /// By default, it's READ
  124|       |    pub permissions: MemoryRegionFlags,
  125|       |}
  126|       |
  127|       |impl<'a> From<&'a [u8]> for GuestBlob<'a> {
  128|      1|    fn from(data: &'a [u8]) -> Self {
  129|      1|        GuestBlob {
  130|      1|            data,
  131|      1|            permissions: DEFAULT_GUEST_BLOB_MEM_FLAGS,
  132|      1|        }
  133|      1|    }
  134|       |}
  135|       |
  136|       |/// Container for a guest binary and optional initialization data.
  137|       |///
  138|       |/// This struct combines a guest binary (either from a file or memory buffer) with
  139|       |/// optional data that will be available to the guest during execution.
  140|       |#[derive(Debug)]
  141|       |pub struct GuestEnvironment<'a, 'b> {
  142|       |    /// The guest binary, which can be a file path or a buffer.
  143|       |    pub guest_binary: GuestBinary<'a>,
  144|       |    /// An optional guest blob, which can be used to provide additional data to the guest.
  145|       |    pub init_data: Option<GuestBlob<'b>>,
  146|       |}
  147|       |
  148|       |impl<'a, 'b> GuestEnvironment<'a, 'b> {
  149|       |    /// Creates a new `GuestEnvironment` with the given guest binary and an optional guest blob.
  150|      1|    pub fn new(guest_binary: GuestBinary<'a>, init_data: Option<&'b [u8]>) -> Self {
  151|      1|        GuestEnvironment {
  152|      1|            guest_binary,
  153|      1|            init_data: init_data.map(GuestBlob::from),
  154|      1|        }
  155|      1|    }
  156|       |}
  157|       |
  158|       |impl<'a> From<GuestBinary<'a>> for GuestEnvironment<'a, '_> {
  159|     65|    fn from(guest_binary: GuestBinary<'a>) -> Self {
  160|     65|        GuestEnvironment {
  161|     65|            guest_binary,
  162|     65|            init_data: None,
  163|     65|        }
  164|     65|    }
  165|       |}
  166|       |
  167|       |impl UninitializedSandbox {
  168|       |    /// Creates a new uninitialized sandbox for the given guest environment.
  169|       |    ///
  170|       |    /// The guest binary can be provided as either a file path or memory buffer.
  171|       |    /// An optional configuration can customize memory sizes and sandbox settings.
  172|       |    /// After creation, register host functions using [`register`](Self::register)
  173|       |    /// before calling [`evolve`](Self::evolve) to complete initialization and create the VM.
  174|       |    #[instrument(
  175|       |        err(Debug),
  176|       |        skip(env),
  177|       |        parent = Span::current()
  178|       |    )]
  179|     66|    pub fn new<'a, 'b>(
  180|     66|        env: impl Into<GuestEnvironment<'a, 'b>>,
  181|     66|        cfg: Option<SandboxConfiguration>,
  182|     66|    ) -> Result<Self> {
  183|       |        #[cfg(feature = "build-metadata")]
  184|       |        log_build_details();
  185|       |
  186|       |        // hyperlight is only supported on Windows 11 and Windows Server 2022 and later
  187|       |        #[cfg(target_os = "windows")]
  188|       |        check_windows_version()?;
  189|       |
  190|       |        let env: GuestEnvironment<'_, '_> = env.into();
  191|       |        let guest_binary = env.guest_binary;
  192|       |        let guest_blob = env.init_data;
  193|       |
  194|       |        // If the guest binary is a file make sure it exists
  195|       |        let guest_binary = match guest_binary {
  196|       |            GuestBinary::FilePath(binary_path) => {
  197|       |                let path = Path::new(&binary_path)
  198|       |                    .canonicalize()
  199|      2|                    .map_err(|e| new_error!("GuestBinary not found: '{}': {}", binary_path, e))?
  200|       |                    .into_os_string()
  201|       |                    .into_string()
  202|      0|                    .map_err(|e| new_error!("Error converting OsString to String: {:?}", e))?;
  203|       |
  204|       |                GuestBinary::FilePath(path)
  205|       |            }
  206|       |            buffer @ GuestBinary::Buffer(_) => buffer,
  207|       |        };
  208|       |
  209|       |        let sandbox_cfg = cfg.unwrap_or_default();
  210|       |
  211|       |        #[cfg(any(crashdump, gdb))]
  212|       |        let rt_cfg = {
  213|       |            #[cfg(crashdump)]
  214|       |            let guest_core_dump = sandbox_cfg.get_guest_core_dump();
  215|       |
  216|       |            #[cfg(gdb)]
  217|       |            let debug_info = sandbox_cfg.get_guest_debug_info();
  218|       |
  219|       |            #[cfg(crashdump)]
  220|       |            let binary_path = if let GuestBinary::FilePath(ref path) = guest_binary {
  221|       |                Some(path.clone())
  222|       |            } else {
  223|       |                None
  224|       |            };
  225|       |
  226|       |            SandboxRuntimeConfig {
  227|       |                #[cfg(crashdump)]
  228|       |                binary_path,
  229|       |                #[cfg(gdb)]
  230|       |                debug_info,
  231|       |                #[cfg(crashdump)]
  232|       |                guest_core_dump,
  233|       |            }
  234|       |        };
  235|       |
  236|       |        let (mut mem_mgr_wrapper, load_info) = {
  237|       |            let (mut mgr, load_info) = UninitializedSandbox::load_guest_binary(
  238|       |                sandbox_cfg,
  239|       |                &guest_binary,
  240|       |                guest_blob.as_ref(),
  241|       |            )?;
  242|       |
  243|       |            let stack_guard = Self::create_stack_guard();
  244|       |            mgr.set_stack_guard(&stack_guard)?;
  245|       |            (MemMgrWrapper::new(mgr, stack_guard), load_info)
  246|       |        };
  247|       |
  248|       |        mem_mgr_wrapper.write_memory_layout()?;
  249|       |
  250|       |        // if env has a guest blob, load it into shared mem
  251|       |        if let Some(blob) = guest_blob {
  252|       |            mem_mgr_wrapper.write_init_data(blob.data)?;
  253|       |        }
  254|       |
  255|       |        let host_funcs = Arc::new(Mutex::new(FunctionRegistry::default()));
  256|       |
  257|       |        let mut sandbox = Self {
  258|       |            host_funcs,
  259|       |            mgr: mem_mgr_wrapper,
  260|       |            max_guest_log_level: None,
  261|       |            config: sandbox_cfg,
  262|       |            #[cfg(any(crashdump, gdb))]
  263|       |            rt_cfg,
  264|       |            load_info,
  265|       |        };
  266|       |
  267|       |        // If we were passed a writer for host print register it otherwise use the default.
  268|       |        sandbox.register_print(default_writer_func)?;
  269|       |
  270|       |        crate::debug!("Sandbox created:  {:#?}", sandbox);
  271|       |
  272|       |        Ok(sandbox)
  273|     66|    }
  274|       |
  275|       |    #[instrument(skip_all, parent = Span::current(), level = "Trace")]
  276|     64|    fn create_stack_guard() -> [u8; STACK_COOKIE_LEN] {
  277|     64|        rand::random::<[u8; STACK_COOKIE_LEN]>()
  278|     64|    }
  279|       |
  280|       |    /// Load the file at `bin_path_str` into a PE file, then attempt to
  281|       |    /// load the PE file into a `SandboxMemoryManager` and return it.
  282|       |    ///
  283|       |    /// If `run_from_guest_binary` is passed as `true`, and this code is
  284|       |    /// running on windows, this function will call
  285|       |    /// `SandboxMemoryManager::load_guest_binary_using_load_library` to
  286|       |    /// create the new `SandboxMemoryManager`. If `run_from_guest_binary` is
  287|       |    /// passed as `true` and we're not running on windows, this function will
  288|       |    /// return an `Err`. Otherwise, if `run_from_guest_binary` is passed
  289|       |    /// as `false`, this function calls `SandboxMemoryManager::load_guest_binary_into_memory`.
  290|       |    #[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  291|     65|    pub(super) fn load_guest_binary(
  292|     65|        cfg: SandboxConfiguration,
  293|     65|        guest_binary: &GuestBinary,
  294|     65|        guest_blob: Option<&GuestBlob>,
  295|     65|    ) -> Result<(
  296|     65|        SandboxMemoryManager<ExclusiveSharedMemory>,
  297|     65|        crate::mem::exe::LoadInfo,
  298|     65|    )> {
  299|     65|        let exe_info = match guest_binary {
  300|       |            GuestBinary::FilePath(bin_path_str) => ExeInfo::from_file(bin_path_str)?,
  301|       |            GuestBinary::Buffer(buffer) => ExeInfo::from_buf(buffer)?,
  302|       |        };
  303|       |
  304|       |        SandboxMemoryManager::load_guest_binary_into_memory(cfg, exe_info, guest_blob)
  305|     65|    }
  306|       |
  307|       |    /// Sets the maximum log level for guest code execution.
  308|       |    ///
  309|       |    /// If not set, the log level is determined by the `RUST_LOG` environment variable,
  310|       |    /// defaulting to [`LevelFilter::Error`] if unset.
  311|      0|    pub fn set_max_guest_log_level(&mut self, log_level: LevelFilter) {
  312|      0|        self.max_guest_log_level = Some(log_level);
  313|      0|    }
  314|       |
  315|       |    /// Registers a host function that the guest can call.
  316|      3|    pub fn register<Args: ParameterTuple, Output: SupportedReturnType>(
  317|      3|        &mut self,
  318|      3|        name: impl AsRef<str>,
  319|      3|        host_func: impl Into<HostFunction<Output, Args>>,
  320|      3|    ) -> Result<()> {
  321|      3|        register_host_function(host_func, self, name.as_ref(), None)
  322|      3|    }
  323|       |
  324|       |    /// Registers a host function with additional allowed syscalls during execution.
  325|       |    ///
  326|       |    /// Unlike [`register`](Self::register), this variant allows specifying extra syscalls
  327|       |    /// that will be permitted when the function handler runs.
  328|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
  329|     68|    pub fn register_with_extra_allowed_syscalls<
  330|     68|        Args: ParameterTuple,
  331|     68|        Output: SupportedReturnType,
  332|     68|    >(
  333|     68|        &mut self,
  334|     68|        name: impl AsRef<str>,
  335|     68|        host_func: impl Into<HostFunction<Output, Args>>,
  336|     68|        extra_allowed_syscalls: impl IntoIterator<Item = crate::sandbox::ExtraAllowedSyscall>,
  337|     68|    ) -> Result<()> {
  338|     68|        let extra_allowed_syscalls: Vec<_> = extra_allowed_syscalls.into_iter().collect();
  339|     68|        register_host_function(host_func, self, name.as_ref(), Some(extra_allowed_syscalls))
  340|     68|    }
  341|       |
  342|       |    /// Registers the special "HostPrint" function for guest printing.
  343|       |    ///
  344|       |    /// This overrides the default behavior of writing to stdout.
  345|       |    /// The function expects the signature `FnMut(String) -> i32`
  346|       |    /// and will be called when the guest wants to print output.
  347|     67|    pub fn register_print(
  348|     67|        &mut self,
  349|     67|        print_func: impl Into<HostFunction<i32, (String,)>>,
  350|     67|    ) -> Result<()> {
  351|     67|        #[cfg(not(all(target_os = "linux", feature = "seccomp")))]
  352|     67|        self.register("HostPrint", print_func)?;
  353|     67|
  354|     67|        #[cfg(all(target_os = "linux", feature = "seccomp"))]
  355|     67|        self.register_with_extra_allowed_syscalls(
  356|     67|            "HostPrint",
  357|     67|            print_func,
  358|     67|            EXTRA_ALLOWED_SYSCALLS_FOR_WRITER_FUNC.iter().copied(),
  359|     67|        )?;
                       ^0
  360|       |
  361|     67|        Ok(())
  362|     67|    }
  363|       |
  364|       |    /// Registers the "HostPrint" function with additional allowed syscalls.
  365|       |    ///
  366|       |    /// Like [`register_print`](Self::register_print), but allows specifying extra syscalls
  367|       |    /// that will be permitted during function execution.
  368|       |    #[cfg(all(feature = "seccomp", target_os = "linux"))]
  369|      0|    pub fn register_print_with_extra_allowed_syscalls(
  370|      0|        &mut self,
  371|      0|        print_func: impl Into<HostFunction<i32, (String,)>>,
  372|      0|        extra_allowed_syscalls: impl IntoIterator<Item = crate::sandbox::ExtraAllowedSyscall>,
  373|      0|    ) -> Result<()> {
  374|      0|        #[cfg(all(target_os = "linux", feature = "seccomp"))]
  375|      0|        self.register_with_extra_allowed_syscalls(
  376|      0|            "HostPrint",
  377|      0|            print_func,
  378|      0|            EXTRA_ALLOWED_SYSCALLS_FOR_WRITER_FUNC
  379|      0|                .iter()
  380|      0|                .copied()
  381|      0|                .chain(extra_allowed_syscalls),
  382|      0|        )?;
  383|       |
  384|      0|        Ok(())
  385|      0|    }
  386|       |}
  387|       |// Check to see if the current version of Windows is supported
  388|       |// Hyperlight is only supported on Windows 11 and Windows Server 2022 and later
  389|       |#[cfg(target_os = "windows")]
  390|       |fn check_windows_version() -> Result<()> {
  391|       |    use windows_version::{OsVersion, is_server};
  392|       |    const WINDOWS_MAJOR: u32 = 10;
  393|       |    const WINDOWS_MINOR: u32 = 0;
  394|       |    const WINDOWS_PACK: u32 = 0;
  395|       |
  396|       |    // Windows Server 2022 has version numbers 10.0.20348 or greater
  397|       |    if is_server() {
  398|       |        if OsVersion::current() < OsVersion::new(WINDOWS_MAJOR, WINDOWS_MINOR, WINDOWS_PACK, 20348)
  399|       |        {
  400|       |            return Err(new_error!(
  401|       |                "Hyperlight Requires Windows Server 2022 or newer"
  402|       |            ));
  403|       |        }
  404|       |    } else if OsVersion::current()
  405|       |        < OsVersion::new(WINDOWS_MAJOR, WINDOWS_MINOR, WINDOWS_PACK, 22000)
  406|       |    {
  407|       |        return Err(new_error!("Hyperlight Requires Windows 11 or newer"));
  408|       |    }
  409|       |    Ok(())
  410|       |}
  411|       |
  412|       |#[cfg(test)]
  413|       |mod tests {
  414|       |    use std::sync::Arc;
  415|       |    use std::sync::mpsc::channel;
  416|       |    use std::{fs, thread};
  417|       |
  418|       |    use crossbeam_queue::ArrayQueue;
  419|       |    use hyperlight_common::flatbuffer_wrappers::function_types::{ParameterValue, ReturnValue};
  420|       |    use hyperlight_testing::simple_guest_as_string;
  421|       |
  422|       |    use crate::sandbox::SandboxConfiguration;
  423|       |    use crate::sandbox::uninitialized::{GuestBinary, GuestEnvironment};
  424|       |    use crate::{MultiUseSandbox, Result, UninitializedSandbox, new_error};
  425|       |
  426|       |    #[test]
  427|      1|    fn test_load_extra_blob() {
  428|      1|        let binary_path = simple_guest_as_string().unwrap();
  429|      1|        let buffer = [0xde, 0xad, 0xbe, 0xef];
  430|      1|        let guest_env =
  431|      1|            GuestEnvironment::new(GuestBinary::FilePath(binary_path.clone()), Some(&buffer));
  432|      1|
  433|      1|        let uninitialized_sandbox = UninitializedSandbox::new(guest_env, None).unwrap();
  434|      1|        let mut sandbox: MultiUseSandbox = uninitialized_sandbox.evolve().unwrap();
  435|      1|
  436|      1|        let res = sandbox
  437|      1|            .call::<Vec<u8>>("ReadFromUserMemory", (4u64, buffer.to_vec()))
  438|      1|            .expect("Failed to call ReadFromUserMemory");
  439|      1|
  440|      1|        assert_eq!(res, buffer.to_vec());
  441|      0|    }
  442|       |
  443|       |    #[test]
  444|      1|    fn test_new_sandbox() {
  445|      1|        // Guest Binary exists at path
  446|      1|
  447|      1|        let binary_path = simple_guest_as_string().unwrap();
  448|      1|        let sandbox = UninitializedSandbox::new(GuestBinary::FilePath(binary_path.clone()), None);
  449|      1|        assert!(sandbox.is_ok());
  450|       |
  451|       |        // Guest Binary does not exist at path
  452|       |
  453|      1|        let mut binary_path_does_not_exist = binary_path.clone();
  454|      1|        binary_path_does_not_exist.push_str(".nonexistent");
  455|      1|        let uninitialized_sandbox =
  456|      1|            UninitializedSandbox::new(GuestBinary::FilePath(binary_path_does_not_exist), None);
  457|      1|        assert!(uninitialized_sandbox.is_err());
  458|       |
  459|       |        // Non default memory configuration
  460|      1|        let cfg = {
  461|      1|            let mut cfg = SandboxConfiguration::default();
  462|      1|            cfg.set_input_data_size(0x1000);
  463|      1|            cfg.set_output_data_size(0x1000);
  464|      1|            cfg.set_stack_size(0x1000);
  465|      1|            cfg.set_heap_size(0x1000);
  466|      1|            Some(cfg)
  467|      1|        };
  468|      1|
  469|      1|        let uninitialized_sandbox =
  470|      1|            UninitializedSandbox::new(GuestBinary::FilePath(binary_path.clone()), cfg);
  471|      1|        assert!(uninitialized_sandbox.is_ok());
  472|       |
  473|      1|        let uninitialized_sandbox =
  474|      1|            UninitializedSandbox::new(GuestBinary::FilePath(binary_path), None).unwrap();
  475|      1|
  476|      1|        // Get a Sandbox from an uninitialized sandbox without a call back function
  477|      1|
  478|      1|        let _sandbox: MultiUseSandbox = uninitialized_sandbox.evolve().unwrap();
  479|      1|
  480|      1|        // Test with a valid guest binary buffer
  481|      1|
  482|      1|        let binary_path = simple_guest_as_string().unwrap();
  483|      1|        let sandbox =
  484|      1|            UninitializedSandbox::new(GuestBinary::Buffer(&fs::read(binary_path).unwrap()), None);
  485|      1|        assert!(sandbox.is_ok());
  486|       |
  487|       |        // Test with a invalid guest binary buffer
  488|       |
  489|      0|        let binary_path = simple_guest_as_string().unwrap();
  490|      0|        let mut bytes = fs::read(binary_path).unwrap();
  491|      0|        let _ = bytes.split_off(100);
  492|      0|        let sandbox = UninitializedSandbox::new(GuestBinary::Buffer(&bytes), None);
  493|      0|        assert!(sandbox.is_err());
  494|      0|    }
  495|       |
  496|       |    #[test]
  497|      1|    fn test_load_guest_binary_manual() {
  498|      1|        let cfg = SandboxConfiguration::default();
  499|      1|
  500|      1|        let simple_guest_path = simple_guest_as_string().unwrap();
  501|      1|
  502|      1|        UninitializedSandbox::load_guest_binary(
  503|      1|            cfg,
  504|      1|            &GuestBinary::FilePath(simple_guest_path),
  505|      1|            None.as_ref(),
  506|      1|        )
  507|      1|        .unwrap();
  508|      1|    }
  509|       |
  510|       |    #[test]
  511|      1|    fn test_host_functions() {
  512|      1|        let uninitialized_sandbox = || {
  513|      1|            UninitializedSandbox::new(
  514|      1|                GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  515|      1|                None,
  516|      1|            )
  517|      1|            .unwrap()
  518|      1|        };
  519|       |
  520|       |        // simple register + call
  521|       |        {
  522|      1|            let mut usbox = uninitialized_sandbox();
  523|      1|
  524|      1|            usbox.register("test0", |arg: i32| Ok(arg + 1)).unwrap();
                                                             ^0
  525|      1|
  526|      1|            let sandbox: Result<MultiUseSandbox> = usbox.evolve();
  527|      1|            assert!(sandbox.is_ok());
  528|      0|            let sandbox = sandbox.unwrap();
  529|      0|
  530|      0|            let host_funcs = sandbox
  531|      0|                ._host_funcs
  532|      0|                .try_lock()
  533|      0|                .map_err(|_| new_error!("Error locking"));
  534|      0|
  535|      0|            assert!(host_funcs.is_ok());
  536|       |
  537|      0|            let res = host_funcs
  538|      0|                .unwrap()
  539|      0|                .call_host_function("test0", vec![ParameterValue::Int(1)])
  540|      0|                .unwrap();
  541|      0|
  542|      0|            assert_eq!(res, ReturnValue::Int(2));
  543|       |        }
  544|       |
  545|       |        // multiple parameters register + call
  546|       |        {
  547|      0|            let mut usbox = uninitialized_sandbox();
  548|      0|
  549|      0|            usbox.register("test1", |a: i32, b: i32| Ok(a + b)).unwrap();
  550|      0|
  551|      0|            let sandbox: Result<MultiUseSandbox> = usbox.evolve();
  552|      0|            assert!(sandbox.is_ok());
  553|      0|            let sandbox = sandbox.unwrap();
  554|      0|
  555|      0|            let host_funcs = sandbox
  556|      0|                ._host_funcs
  557|      0|                .try_lock()
  558|      0|                .map_err(|_| new_error!("Error locking"));
  559|      0|
  560|      0|            assert!(host_funcs.is_ok());
  561|       |
  562|      0|            let res = host_funcs
  563|      0|                .unwrap()
  564|      0|                .call_host_function(
  565|      0|                    "test1",
  566|      0|                    vec![ParameterValue::Int(1), ParameterValue::Int(2)],
  567|      0|                )
  568|      0|                .unwrap();
  569|      0|
  570|      0|            assert_eq!(res, ReturnValue::Int(3));
  571|       |        }
  572|       |
  573|       |        // incorrect arguments register + call
  574|       |        {
  575|      0|            let mut usbox = uninitialized_sandbox();
  576|      0|
  577|      0|            usbox
  578|      0|                .register("test2", |msg: String| {
  579|      0|                    println!("test2 called: {}", msg);
  580|      0|                    Ok(())
  581|      0|                })
  582|      0|                .unwrap();
  583|      0|
  584|      0|            let sandbox: Result<MultiUseSandbox> = usbox.evolve();
  585|      0|            assert!(sandbox.is_ok());
  586|      0|            let sandbox = sandbox.unwrap();
  587|      0|
  588|      0|            let host_funcs = sandbox
  589|      0|                ._host_funcs
  590|      0|                .try_lock()
  591|      0|                .map_err(|_| new_error!("Error locking"));
  592|      0|
  593|      0|            assert!(host_funcs.is_ok());
  594|       |
  595|      0|            let res = host_funcs.unwrap().call_host_function("test2", vec![]);
  596|      0|            assert!(res.is_err());
  597|       |        }
  598|       |
  599|       |        // calling a function that doesn't exist
  600|       |        {
  601|      0|            let usbox = uninitialized_sandbox();
  602|      0|            let sandbox: Result<MultiUseSandbox> = usbox.evolve();
  603|      0|            assert!(sandbox.is_ok());
  604|      0|            let sandbox = sandbox.unwrap();
  605|      0|
  606|      0|            let host_funcs = sandbox
  607|      0|                ._host_funcs
  608|      0|                .try_lock()
  609|      0|                .map_err(|_| new_error!("Error locking"));
  610|      0|
  611|      0|            assert!(host_funcs.is_ok());
  612|       |
  613|      0|            let res = host_funcs.unwrap().call_host_function("test4", vec![]);
  614|      0|            assert!(res.is_err());
  615|       |        }
  616|      0|    }
  617|       |
  618|       |    #[test]
  619|      1|    fn test_host_print() {
  620|      1|        // writer as a FnMut closure mutating a captured variable and then trying to access the captured variable
  621|      1|        // after the Sandbox instance has been dropped
  622|      1|        // this example is fairly contrived but we should still support such an approach.
  623|      1|
  624|      1|        let (tx, rx) = channel();
  625|      1|
  626|      1|        let writer = move |msg| {
  627|      1|            let _ = tx.send(msg);
  628|      1|            Ok(0)
  629|      1|        };
  630|       |
  631|      1|        let mut sandbox = UninitializedSandbox::new(
  632|      1|            GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  633|      1|            None,
  634|      1|        )
  635|      1|        .expect("Failed to create sandbox");
  636|      1|
  637|      1|        sandbox
  638|      1|            .register_print(writer)
  639|      1|            .expect("Failed to register host print function");
  640|      1|
  641|      1|        let host_funcs = sandbox
  642|      1|            .host_funcs
  643|      1|            .try_lock()
  644|      1|            .map_err(|_| new_error!("Error locking"));
                                                  ^0
  645|      1|
  646|      1|        assert!(host_funcs.is_ok());
  647|       |
  648|      1|        host_funcs.unwrap().host_print("test".to_string()).unwrap();
  649|      1|
  650|      1|        drop(sandbox);
  651|      1|
  652|      1|        let received_msgs: Vec<_> = rx.into_iter().collect();
  653|      1|        assert_eq!(received_msgs, ["test"]);
  654|       |
  655|       |        // There may be cases where a mutable reference to the captured variable is not required to be used outside the closure
  656|       |        // e.g. if the function is writing to a file or a socket etc.
  657|       |
  658|       |        // writer as a FnMut closure mutating a captured variable but not trying to access the captured variable
  659|       |
  660|       |        // This seems more realistic as the client is creating a file to be written to in the closure
  661|       |        // and then accessing the file a different handle.
  662|       |        // The problem is that captured_file still needs static lifetime so even though we can access the data through the second file handle
  663|       |        // this still does not work as the captured_file is dropped at the end of the function
  664|       |
  665|       |        // TODO: Currently, we block any writes that are not to
  666|       |        // the stdout/stderr file handles, so this code is commented
  667|       |        // out until we can register writer functions like any other
  668|       |        // host functions with their own set of extra allowed syscalls.
  669|       |        // In particular, this code should be brought back once we have addressed the issue
  670|       |
  671|       |        // let captured_file = Arc::new(Mutex::new(NamedTempFile::new().unwrap()));
  672|       |        // let capture_file_clone = captured_file.clone();
  673|       |        //
  674|       |        // let capture_file_lock = captured_file
  675|       |        //     .try_lock()
  676|       |        //     .map_err(|_| new_error!("Error locking"))
  677|       |        //     .unwrap();
  678|       |        // let mut file = capture_file_lock.reopen().unwrap();
  679|       |        // drop(capture_file_lock);
  680|       |        //
  681|       |        // let writer = move |msg: String| -> Result<i32> {
  682|       |        //     let mut captured_file = capture_file_clone
  683|       |        //         .try_lock()
  684|       |        //         .map_err(|_| new_error!("Error locking"))
  685|       |        //         .unwrap();
  686|       |        //     captured_file.write_all(msg.as_bytes()).unwrap();
  687|       |        //     Ok(0)
  688|       |        // };
  689|       |        //
  690|       |        // let writer_func = Arc::new(Mutex::new(writer));
  691|       |        //
  692|       |        // let sandbox = UninitializedSandbox::new(
  693|       |        //     GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  694|       |        //     None,
  695|       |        //     None,
  696|       |        //     Some(&writer_func),
  697|       |        // )
  698|       |        // .expect("Failed to create sandbox");
  699|       |        //
  700|       |        // let host_funcs = sandbox
  701|       |        //     .host_funcs
  702|       |        //     .try_lock()
  703|       |        //     .map_err(|_| new_error!("Error locking"));
  704|       |        //
  705|       |        // assert!(host_funcs.is_ok());
  706|       |        //
  707|       |        // host_funcs.unwrap().host_print("test2".to_string()).unwrap();
  708|       |        //
  709|       |        // let mut buffer = String::new();
  710|       |        // file.read_to_string(&mut buffer).unwrap();
  711|       |        // assert_eq!(buffer, "test2");
  712|       |
  713|       |        // writer as a function
  714|       |
  715|      1|        fn fn_writer(msg: String) -> Result<i32> {
  716|      1|            assert_eq!(msg, "test2");
  717|      1|            Ok(0)
  718|      1|        }
  719|       |
  720|      1|        let mut sandbox = UninitializedSandbox::new(
  721|      1|            GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  722|      1|            None,
  723|      1|        )
  724|      1|        .expect("Failed to create sandbox");
  725|      1|
  726|      1|        sandbox
  727|      1|            .register_print(fn_writer)
  728|      1|            .expect("Failed to register host print function");
  729|      1|
  730|      1|        let host_funcs = sandbox
  731|      1|            .host_funcs
  732|      1|            .try_lock()
  733|      1|            .map_err(|_| new_error!("Error locking"));
                                                  ^0
  734|      1|
  735|      1|        assert!(host_funcs.is_ok());
  736|       |
  737|      1|        host_funcs.unwrap().host_print("test2".to_string()).unwrap();
  738|      1|
  739|      1|        // writer as a method
  740|      1|
  741|      1|        let mut test_host_print = TestHostPrint::new();
  742|      1|
  743|      1|        // create a closure over the struct method
  744|      1|
  745|      1|        let writer_closure = move |s| test_host_print.write(s);
  746|       |
  747|      1|        let mut sandbox = UninitializedSandbox::new(
  748|      1|            GuestBinary::FilePath(simple_guest_as_string().expect("Guest Binary Missing")),
  749|      1|            None,
  750|      1|        )
  751|      1|        .expect("Failed to create sandbox");
  752|      1|
  753|      1|        sandbox
  754|      1|            .register_print(writer_closure)
  755|      1|            .expect("Failed to register host print function");
  756|      1|
  757|      1|        let host_funcs = sandbox
  758|      1|            .host_funcs
  759|      1|            .try_lock()
  760|      1|            .map_err(|_| new_error!("Error locking"));
                                                  ^0
  761|      1|
  762|      1|        assert!(host_funcs.is_ok());
  763|       |
  764|      1|        host_funcs.unwrap().host_print("test3".to_string()).unwrap();
  765|      1|    }
  766|       |
  767|       |    struct TestHostPrint {}
  768|       |
  769|       |    impl TestHostPrint {
  770|      1|        fn new() -> Self {
  771|      1|            TestHostPrint {}
  772|      1|        }
  773|       |
  774|      1|        fn write(&mut self, msg: String) -> Result<i32> {
  775|      1|            assert_eq!(msg, "test3");
  776|      1|            Ok(0)
  777|      1|        }
  778|       |    }
  779|       |
  780|       |    #[test]
  781|      1|    fn check_create_and_use_sandbox_on_different_threads() {
  782|      1|        let unintializedsandbox_queue = Arc::new(ArrayQueue::<UninitializedSandbox>::new(10));
  783|      1|        let sandbox_queue = Arc::new(ArrayQueue::<MultiUseSandbox>::new(10));
  784|       |
  785|     11|        for i in 0..10 {
                          ^10
  786|     10|            let simple_guest_path = simple_guest_as_string().expect("Guest Binary Missing");
  787|     10|            let unintializedsandbox = {
  788|     10|                let err_string = format!("failed to create UninitializedSandbox {i}");
  789|     10|                let err_str = err_string.as_str();
  790|     10|                UninitializedSandbox::new(GuestBinary::FilePath(simple_guest_path), None)
  791|     10|                    .expect(err_str)
  792|     10|            };
  793|     10|
  794|     10|            {
  795|     10|                let err_string = format!("Failed to push UninitializedSandbox {i}");
  796|     10|                let err_str = err_string.as_str();
  797|     10|
  798|     10|                unintializedsandbox_queue
  799|     10|                    .push(unintializedsandbox)
  800|     10|                    .expect(err_str);
  801|     10|            }
  802|       |        }
  803|       |
  804|      1|        let thread_handles = (0..10)
  805|     10|            .map(|i| {
  806|     10|                let uq = unintializedsandbox_queue.clone();
  807|     10|                let sq = sandbox_queue.clone();
  808|     10|                thread::spawn(move || {
  809|     10|                    let uninitialized_sandbox = uq.pop().unwrap_or_else(|| {
  810|      0|                        panic!("Failed to pop UninitializedSandbox thread {}", i)
  811|     10|                    });
  812|     10|
  813|     10|                    let host_funcs = uninitialized_sandbox
  814|     10|                        .host_funcs
  815|     10|                        .try_lock()
  816|     10|                        .map_err(|_| new_error!("Error locking"));
                                                              ^0
  817|     10|
  818|     10|                    assert!(host_funcs.is_ok());
  819|       |
  820|     10|                    host_funcs
  821|     10|                        .unwrap()
  822|     10|                        .host_print(format!("Print from UninitializedSandbox on Thread {}\n", i))
  823|     10|                        .unwrap();
  824|     10|
  825|     10|                    let sandbox = uninitialized_sandbox.evolve().unwrap_or_else(|_| {
  826|     10|                        panic!("Failed to initialize UninitializedSandbox thread {}", i)
  827|     10|                    });
  828|     10|
  829|     10|                    sq.push(sandbox).unwrap_or_else(|_| {
  830|      0|                        panic!("Failed to push UninitializedSandbox thread {}", i)
  831|     10|                    })
  832|     10|                })
  833|     10|            })
  834|      1|            .collect::<Vec<_>>();
  835|       |
  836|      1|        for handle in thread_handles {
                          ^0
  837|      0|            handle.join().unwrap();
  838|      0|        }
  839|       |
  840|      1|        let thread_handles = (0..10)
  841|      1|            .map(|i| {
  842|      0|                let sq = sandbox_queue.clone();
  843|      0|                thread::spawn(move || {
  844|      0|                    let sandbox = sq
  845|      0|                        .pop()
  846|      0|                        .unwrap_or_else(|| panic!("Failed to pop Sandbox thread {}", i));
  847|      0|
  848|      0|                    let host_funcs = sandbox
  849|      0|                        ._host_funcs
  850|      0|                        .try_lock()
  851|      0|                        .map_err(|_| new_error!("Error locking"));
  852|      0|
  853|      0|                    assert!(host_funcs.is_ok());
  854|       |
  855|      0|                    host_funcs
  856|      0|                        .unwrap()
  857|      0|                        .host_print(format!("Print from Sandbox on Thread {}\n", i))
  858|      0|                        .unwrap();
  859|      0|                })
  860|      1|            })
  861|      1|            .collect::<Vec<_>>();
  862|       |
  863|  18.4E|        for handle in thread_handles {
                                    ^0
  864|  18.4E|            handle.join().unwrap();
  865|  18.4E|        }
  866|      1|    }
  867|       |
  868|       |    #[test]
  869|       |    // Tests that trace data are emitted when a trace subscriber is set
  870|       |    // this test is ignored because it is incompatible with other tests , specifically those which require a logger for tracing
  871|       |    // marking  this test as ignored means that running `cargo test` will not run this test but will allow a developer who runs that command
  872|       |    // from their workstation to be successful without needed to know about test interdependencies
  873|       |    // this test will be run explicitly as a part of the CI pipeline
  874|       |    #[ignore]
  875|       |    #[cfg(feature = "build-metadata")]
  876|      0|    fn test_trace_trace() {
  877|       |        use hyperlight_testing::logger::Logger as TestLogger;
  878|       |        use hyperlight_testing::tracing_subscriber::TracingSubscriber as TestSubscriber;
  879|       |        use serde_json::{Map, Value};
  880|       |        use tracing::Level as tracing_level;
  881|       |        use tracing_core::Subscriber;
  882|       |        use tracing_core::callsite::rebuild_interest_cache;
  883|       |        use uuid::Uuid;
  884|       |
  885|       |        use crate::testing::log_values::build_metadata_testing::try_to_strings;
  886|       |        use crate::testing::log_values::test_value_as_str;
  887|       |
  888|      0|        TestLogger::initialize_log_tracer();
  889|      0|        rebuild_interest_cache();
  890|      0|        let subscriber = TestSubscriber::new(tracing_level::TRACE);
  891|      0|        tracing::subscriber::with_default(subscriber.clone(), || {
  892|      0|            let correlation_id = Uuid::new_v4().as_hyphenated().to_string();
  893|      0|            let span = tracing::error_span!("test_trace_logs", correlation_id).entered();
  894|      0|
  895|      0|            // We should be in span 1
  896|      0|
  897|      0|            let current_span = subscriber.current_span();
  898|      0|            assert!(current_span.is_known(), "Current span is unknown");
  899|      0|            let current_span_metadata = current_span.into_inner().unwrap();
  900|      0|            assert_eq!(
  901|      0|                current_span_metadata.0.into_u64(),
  902|       |                1,
  903|      0|                "Current span is not span 1"
  904|       |            );
  905|      0|            assert_eq!(current_span_metadata.1.name(), "test_trace_logs");
  906|       |
  907|       |            // Get the span data and check the correlation id
  908|       |
  909|      0|            let span_data = subscriber.get_span(1);
  910|      0|            let span_attributes: &Map<String, Value> = span_data
  911|      0|                .get("span")
  912|      0|                .unwrap()
  913|      0|                .get("attributes")
  914|      0|                .unwrap()
  915|      0|                .as_object()
  916|      0|                .unwrap();
  917|      0|
  918|      0|            test_value_as_str(span_attributes, "correlation_id", correlation_id.as_str());
  919|      0|
  920|      0|            let mut binary_path = simple_guest_as_string().unwrap();
  921|      0|            binary_path.push_str("does_not_exist");
  922|      0|
  923|      0|            let sbox = UninitializedSandbox::new(GuestBinary::FilePath(binary_path), None);
  924|      0|            assert!(sbox.is_err());
  925|       |
  926|       |            // Now we should still be in span 1 but span 2 should be created (we created entered and exited span 2 when we called UninitializedSandbox::new)
  927|       |
  928|      0|            let current_span = subscriber.current_span();
  929|      0|            assert!(current_span.is_known(), "Current span is unknown");
  930|      0|            let current_span_metadata = current_span.into_inner().unwrap();
  931|      0|            assert_eq!(
  932|      0|                current_span_metadata.0.into_u64(),
  933|       |                1,
  934|      0|                "Current span is not span 1"
  935|       |            );
  936|       |
  937|      0|            let span_metadata = subscriber.get_span_metadata(2);
  938|      0|            assert_eq!(span_metadata.name(), "new");
  939|       |
  940|       |            // There should be one event for the error that the binary path does not exist plus 14 info events for the logging of the crate info
  941|       |
  942|      0|            let events = subscriber.get_events();
  943|      0|            assert_eq!(events.len(), 15);
  944|       |
  945|      0|            let mut count_matching_events = 0;
  946|       |
  947|      0|            for json_value in events {
  948|      0|                let event_values = json_value.as_object().unwrap().get("event").unwrap();
  949|      0|                let metadata_values_map =
  950|      0|                    event_values.get("metadata").unwrap().as_object().unwrap();
  951|      0|                let event_values_map = event_values.as_object().unwrap();
  952|      0|
  953|      0|                let expected_error_start = "Error(\"GuestBinary not found:";
  954|      0|
  955|      0|                let err_vals_res = try_to_strings([
  956|      0|                    (metadata_values_map, "level"),
  957|      0|                    (event_values_map, "error"),
  958|      0|                    (metadata_values_map, "module_path"),
  959|      0|                    (metadata_values_map, "target"),
  960|      0|                ]);
  961|      0|                if let Ok(err_vals) = err_vals_res {
  962|      0|                    if err_vals[0] == "ERROR"
  963|      0|                        && err_vals[1].starts_with(expected_error_start)
  964|      0|                        && err_vals[2] == "hyperlight_host::sandbox::uninitialized"
  965|      0|                        && err_vals[3] == "hyperlight_host::sandbox::uninitialized"
  966|      0|                    {
  967|      0|                        count_matching_events += 1;
  968|      0|                    }
  969|      0|                }
  970|       |            }
  971|      0|            assert!(
  972|      0|                count_matching_events == 1,
  973|      0|                "Unexpected number of matching events {}",
  974|       |                count_matching_events
  975|       |            );
  976|      0|            span.exit();
  977|      0|            subscriber.clear();
  978|      0|        });
  979|      0|    }
  980|       |
  981|       |    #[test]
  982|       |    #[ignore]
  983|       |    // Tests that traces are emitted as log records when there is no trace
  984|       |    // subscriber configured.
  985|       |    #[cfg(feature = "build-metadata")]
  986|      0|    fn test_log_trace() {
  987|       |        use std::path::PathBuf;
  988|       |
  989|       |        use hyperlight_testing::logger::{LOGGER as TEST_LOGGER, Logger as TestLogger};
  990|       |        use log::Level;
  991|       |        use tracing_core::callsite::rebuild_interest_cache;
  992|       |
  993|       |        {
  994|      0|            TestLogger::initialize_test_logger();
  995|      0|            TEST_LOGGER.set_max_level(log::LevelFilter::Trace);
  996|      0|
  997|      0|            // This makes sure that the metadata interest cache is rebuilt so that
  998|      0|            // the log records are emitted for the trace records
  999|      0|
 1000|      0|            rebuild_interest_cache();
 1001|      0|
 1002|      0|            let mut invalid_binary_path = simple_guest_as_string().unwrap();
 1003|      0|            invalid_binary_path.push_str("does_not_exist");
 1004|      0|
 1005|      0|            let sbox = UninitializedSandbox::new(GuestBinary::FilePath(invalid_binary_path), None);
 1006|      0|            assert!(sbox.is_err());
 1007|       |
 1008|       |            // When tracing is creating log records it will create a log
 1009|       |            // record for the creation of the span (from the instrument
 1010|       |            // attribute), and will then create a log record for the entry to
 1011|       |            // and exit from the span.
 1012|       |            //
 1013|       |            // It also creates a log record for the span being dropped.
 1014|       |            //
 1015|       |            // In addition there are 14 info log records created for build information
 1016|       |            //
 1017|       |            // So we expect 19 log records for this test, four for the span and
 1018|       |            // then one for the error as the file that we are attempting to
 1019|       |            // load into the sandbox does not exist, plus the 14 info log records
 1020|       |
 1021|      0|            let num_calls = TEST_LOGGER.num_log_calls();
 1022|      0|            assert_eq!(19, num_calls);
 1023|       |
 1024|       |            // Log record 1
 1025|       |
 1026|      0|            let logcall = TEST_LOGGER.get_log_call(0).unwrap();
 1027|      0|            assert_eq!(Level::Info, logcall.level);
 1028|       |
 1029|      0|            assert!(logcall.args.starts_with("new; cfg"));
 1030|      0|            assert_eq!("hyperlight_host::sandbox::uninitialized", logcall.target);
 1031|       |
 1032|       |            // Log record 2
 1033|       |
 1034|      0|            let logcall = TEST_LOGGER.get_log_call(1).unwrap();
 1035|      0|            assert_eq!(Level::Trace, logcall.level);
 1036|      0|            assert_eq!(logcall.args, "-> new;");
 1037|      0|            assert_eq!("tracing::span::active", logcall.target);
 1038|       |
 1039|       |            // Log record 17
 1040|       |
 1041|      0|            let logcall = TEST_LOGGER.get_log_call(16).unwrap();
 1042|      0|            assert_eq!(Level::Error, logcall.level);
 1043|      0|            assert!(
 1044|      0|                logcall
 1045|      0|                    .args
 1046|      0|                    .starts_with("error=Error(\"GuestBinary not found:")
 1047|      0|            );
 1048|      0|            assert_eq!("hyperlight_host::sandbox::uninitialized", logcall.target);
 1049|       |
 1050|       |            // Log record 18
 1051|       |
 1052|      0|            let logcall = TEST_LOGGER.get_log_call(17).unwrap();
 1053|      0|            assert_eq!(Level::Trace, logcall.level);
 1054|      0|            assert_eq!(logcall.args, "<- new;");
 1055|      0|            assert_eq!("tracing::span::active", logcall.target);
 1056|       |
 1057|       |            // Log record 19
 1058|       |
 1059|      0|            let logcall = TEST_LOGGER.get_log_call(18).unwrap();
 1060|      0|            assert_eq!(Level::Trace, logcall.level);
 1061|      0|            assert_eq!(logcall.args, "-- new;");
 1062|      0|            assert_eq!("tracing::span", logcall.target);
 1063|       |        }
 1064|       |        {
 1065|       |            // test to ensure an invalid binary logs & traces properly
 1066|      0|            TEST_LOGGER.clear_log_calls();
 1067|      0|            TEST_LOGGER.set_max_level(log::LevelFilter::Info);
 1068|      0|
 1069|      0|            let mut valid_binary_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
 1070|      0|            valid_binary_path.push("src");
 1071|      0|            valid_binary_path.push("sandbox");
 1072|      0|            valid_binary_path.push("initialized.rs");
 1073|      0|
 1074|      0|            let sbox = UninitializedSandbox::new(
 1075|      0|                GuestBinary::FilePath(valid_binary_path.into_os_string().into_string().unwrap()),
 1076|      0|                None,
 1077|      0|            );
 1078|      0|            assert!(sbox.is_err());
 1079|       |
 1080|       |            // There should be 2 calls this time when we change to the log
 1081|       |            // LevelFilter to Info.
 1082|      0|            let num_calls = TEST_LOGGER.num_log_calls();
 1083|      0|            assert_eq!(2, num_calls);
 1084|       |
 1085|       |            // Log record 1
 1086|       |
 1087|      0|            let logcall = TEST_LOGGER.get_log_call(0).unwrap();
 1088|      0|            assert_eq!(Level::Info, logcall.level);
 1089|       |
 1090|      0|            assert!(logcall.args.starts_with("new; cfg"));
 1091|      0|            assert_eq!("hyperlight_host::sandbox::uninitialized", logcall.target);
 1092|       |
 1093|       |            // Log record 2
 1094|       |
 1095|      0|            let logcall = TEST_LOGGER.get_log_call(1).unwrap();
 1096|      0|            assert_eq!(Level::Error, logcall.level);
 1097|      0|            assert!(
 1098|      0|                logcall
 1099|      0|                    .args
 1100|      0|                    .starts_with("error=Error(\"GuestBinary not found:")
 1101|      0|            );
 1102|      0|            assert_eq!("hyperlight_host::sandbox::uninitialized", logcall.target);
 1103|       |        }
 1104|       |        {
 1105|      0|            TEST_LOGGER.clear_log_calls();
 1106|      0|            TEST_LOGGER.set_max_level(log::LevelFilter::Error);
 1107|      0|
 1108|      0|            let sbox = {
 1109|      0|                let res = UninitializedSandbox::new(
 1110|      0|                    GuestBinary::FilePath(simple_guest_as_string().unwrap()),
 1111|      0|                    None,
 1112|      0|                );
 1113|      0|                res.unwrap()
 1114|      0|            };
 1115|      0|            let _: Result<MultiUseSandbox> = sbox.evolve();
 1116|      0|
 1117|      0|            let num_calls = TEST_LOGGER.num_log_calls();
 1118|      0|
 1119|      0|            assert_eq!(0, num_calls);
 1120|       |        }
 1121|      0|    }
 1122|       |
 1123|       |    #[test]
 1124|      1|    fn test_invalid_path() {
 1125|      1|        let invalid_path = "some/path/that/does/not/exist";
 1126|      1|        let sbox = UninitializedSandbox::new(GuestBinary::FilePath(invalid_path.to_string()), None);
 1127|      1|        println!("{:?}", sbox);
 1128|      1|        #[cfg(target_os = "windows")]
 1129|      1|        assert!(
 1130|      1|            matches!(sbox, Err(e) if e.to_string().contains("GuestBinary not found: 'some/path/that/does/not/exist': The system cannot find the path specified. (os error 3)"))
 1131|      1|        );
 1132|      1|        #[cfg(target_os = "linux")]
 1133|      1|        assert!(
 1134|      1|            matches!(sbox, Err(e) if e.to_string().contains("GuestBinary not found: 'some/path/that/does/not/exist': No such file or directory (os error 2)"))
 1135|       |        );
 1136|      1|    }
 1137|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/sandbox/uninitialized_evolve.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::sync::{Arc, Mutex};
   18|       |
   19|       |use rand::Rng;
   20|       |use tracing::{Span, instrument};
   21|       |
   22|       |use super::SandboxConfiguration;
   23|       |use super::hypervisor::{HypervisorType, get_available_hypervisor};
   24|       |#[cfg(gdb)]
   25|       |use super::mem_access::dbg_mem_access_handler_wrapper;
   26|       |#[cfg(any(crashdump, gdb))]
   27|       |use super::uninitialized::SandboxRuntimeConfig;
   28|       |use crate::HyperlightError::NoHypervisorFound;
   29|       |use crate::hypervisor::Hypervisor;
   30|       |use crate::mem::exe::LoadInfo;
   31|       |use crate::mem::layout::SandboxMemoryLayout;
   32|       |use crate::mem::mgr::SandboxMemoryManager;
   33|       |use crate::mem::ptr::{GuestPtr, RawPtr};
   34|       |use crate::mem::ptr_offset::Offset;
   35|       |use crate::mem::shared_mem::GuestSharedMemory;
   36|       |#[cfg(any(feature = "init-paging", target_os = "windows"))]
   37|       |use crate::mem::shared_mem::SharedMemory;
   38|       |#[cfg(feature = "trace_guest")]
   39|       |use crate::sandbox::TraceInfo;
   40|       |#[cfg(gdb)]
   41|       |use crate::sandbox::config::DebugInfo;
   42|       |use crate::sandbox::host_funcs::FunctionRegistry;
   43|       |use crate::sandbox::{HostSharedMemory, MemMgrWrapper};
   44|       |#[cfg(target_os = "linux")]
   45|       |use crate::signal_handlers::setup_signal_handlers;
   46|       |use crate::{MultiUseSandbox, Result, UninitializedSandbox, log_then_return, new_error};
   47|       |
   48|       |/// The implementation for evolving `UninitializedSandbox`es to
   49|       |/// `Sandbox`es.
   50|       |///
   51|       |/// Note that `cb_opt`'s type has been carefully considered.
   52|       |/// Particularly, it's not using a constrained generic to define
   53|       |/// the type of the callback because if it did, you'd have to provide
   54|       |/// type hints to the compiler if you want to pass `None` to the function.
   55|       |/// With this type signature, you can pass `None` without having to do that.
   56|       |///
   57|       |/// If this doesn't make sense, and you want to change this type,
   58|       |/// please reach out to a Hyperlight developer before making the change.
   59|       |#[instrument(err(Debug), skip_all, , parent = Span::current(), level = "Trace")]
   60|     59|fn evolve_impl<TransformFunc, ResSandbox>(
   61|     59|    u_sbox: UninitializedSandbox,
   62|     59|    transform: TransformFunc,
   63|     59|) -> Result<ResSandbox>
   64|     59|where
   65|     59|    TransformFunc: Fn(
   66|     59|        Arc<Mutex<FunctionRegistry>>,
   67|     59|        MemMgrWrapper<HostSharedMemory>,
   68|     59|        Box<dyn Hypervisor>,
   69|     59|        RawPtr,
   70|     59|    ) -> Result<ResSandbox>,
   71|     59|{
   72|       |    let (hshm, mut gshm) = u_sbox.mgr.build();
   73|       |    let mut vm = set_up_hypervisor_partition(
   74|       |        &mut gshm,
   75|       |        &u_sbox.config,
   76|       |        #[cfg(any(crashdump, gdb))]
   77|       |        &u_sbox.rt_cfg,
   78|       |        u_sbox.load_info,
   79|       |    )?;
   80|       |
   81|       |    let seed = {
   82|       |        let mut rng = rand::rng();
   83|       |        rng.random::<u64>()
   84|       |    };
   85|       |    let peb_addr = {
   86|       |        let peb_u64 = u64::try_from(gshm.layout.peb_address)?;
   87|       |        RawPtr::from(peb_u64)
   88|       |    };
   89|       |
   90|       |    let page_size = u32::try_from(page_size::get())?;
   91|       |
   92|       |    #[cfg(gdb)]
   93|       |    let dbg_mem_access_hdl = dbg_mem_access_handler_wrapper(hshm.clone());
   94|       |
   95|       |    #[cfg(target_os = "linux")]
   96|       |    setup_signal_handlers(&u_sbox.config)?;
   97|       |
   98|       |    vm.initialise(
   99|       |        peb_addr,
  100|       |        seed,
  101|       |        page_size,
  102|       |        hshm.clone(),
  103|       |        u_sbox.host_funcs.clone(),
  104|       |        u_sbox.max_guest_log_level,
  105|       |        #[cfg(gdb)]
  106|       |        dbg_mem_access_hdl,
  107|       |    )?;
  108|       |
  109|       |    let dispatch_function_addr = hshm.as_ref().get_pointer_to_dispatch_function()?;
  110|       |    if dispatch_function_addr == 0 {
  111|       |        return Err(new_error!("Dispatch function address is null"));
  112|       |    }
  113|       |
  114|       |    transform(
  115|       |        u_sbox.host_funcs,
  116|       |        hshm,
  117|       |        vm,
  118|       |        RawPtr::from(dispatch_function_addr),
  119|       |    )
  120|     59|}
  121|       |
  122|       |#[instrument(err(Debug), skip_all, parent = Span::current(), level = "Trace")]
  123|     59|pub(super) fn evolve_impl_multi_use(u_sbox: UninitializedSandbox) -> Result<MultiUseSandbox> {
  124|      0|    evolve_impl(u_sbox, |hf, hshm, vm, dispatch_ptr| {
  125|      0|        #[cfg(gdb)]
  126|      0|        let dbg_mem_wrapper = dbg_mem_access_handler_wrapper(hshm.clone());
  127|      0|        Ok(MultiUseSandbox::from_uninit(
  128|      0|            hf,
  129|      0|            hshm,
  130|      0|            vm,
  131|      0|            dispatch_ptr,
  132|      0|            #[cfg(gdb)]
  133|      0|            dbg_mem_wrapper,
  134|      0|        ))
  135|      0|    })
  136|     59|}
  137|       |
  138|     59|pub(crate) fn set_up_hypervisor_partition(
  139|     59|    mgr: &mut SandboxMemoryManager<GuestSharedMemory>,
  140|     59|    #[cfg_attr(target_os = "windows", allow(unused_variables))] config: &SandboxConfiguration,
  141|     59|    #[cfg(any(crashdump, gdb))] rt_cfg: &SandboxRuntimeConfig,
  142|     59|    _load_info: LoadInfo,
  143|     59|) -> Result<Box<dyn Hypervisor>> {
  144|       |    #[cfg(feature = "init-paging")]
  145|     59|    let rsp_ptr = {
  146|     59|        let mut regions = mgr.layout.get_memory_regions(&mgr.shared_mem)?;
                                                                                      ^0
  147|     59|        let mem_size = u64::try_from(mgr.shared_mem.mem_size())?;
                                                                             ^0
  148|     59|        let rsp_u64 = mgr.set_up_shared_memory(mem_size, &mut regions)?;
                                                                                    ^0
  149|     59|        let rsp_raw = RawPtr::from(rsp_u64);
  150|     59|        GuestPtr::try_from(rsp_raw)
  151|      0|    }?;
  152|       |    #[cfg(not(feature = "init-paging"))]
  153|       |    let rsp_ptr = GuestPtr::try_from(Offset::from(0))?;
  154|     59|    let regions = mgr.layout.get_memory_regions(&mgr.shared_mem)?;
                                                                              ^0
  155|     59|    let base_ptr = GuestPtr::try_from(Offset::from(0))?;
                                                                    ^0
  156|     59|    let pml4_ptr = {
  157|     59|        let pml4_offset_u64 = u64::try_from(SandboxMemoryLayout::PML4_OFFSET)?;
                                                                                           ^0
  158|     59|        base_ptr + Offset::from(pml4_offset_u64)
  159|       |    };
  160|     59|    let entrypoint_ptr = {
  161|     59|        let entrypoint_total_offset = mgr.load_addr.clone() + mgr.entrypoint_offset;
  162|     59|        GuestPtr::try_from(entrypoint_total_offset)
  163|      0|    }?;
  164|       |
  165|     59|    if base_ptr != pml4_ptr {
  166|      0|        log_then_return!(
  167|      0|            "Error: base_ptr ({:#?}) does not equal pml4_ptr ({:#?})",
  168|      0|            base_ptr,
  169|      0|            pml4_ptr
  170|      0|        );
  171|     59|    }
  172|     59|    if entrypoint_ptr <= pml4_ptr {
  173|      0|        log_then_return!(
  174|      0|            "Error: entrypoint_ptr ({:#?}) is not greater than pml4_ptr ({:#?})",
  175|      0|            entrypoint_ptr,
  176|      0|            pml4_ptr
  177|      0|        );
  178|     59|    }
  179|     59|
  180|     59|    // Create gdb thread if gdb is enabled and the configuration is provided
  181|     59|    #[cfg(gdb)]
  182|     59|    let gdb_conn = if let Some(DebugInfo { port }) = rt_cfg.debug_info {
  183|     59|        use crate::hypervisor::gdb::create_gdb_thread;
  184|     59|
  185|     59|        let gdb_conn = create_gdb_thread(port);
  186|     59|
  187|     59|        // in case the gdb thread creation fails, we still want to continue
  188|     59|        // without gdb
  189|     59|        match gdb_conn {
  190|     59|            Ok(gdb_conn) => Some(gdb_conn),
  191|     59|            Err(e) => {
  192|     59|                log::error!("Could not create gdb connection: {:#}", e);
  193|     59|
  194|     59|                None
  195|     59|            }
  196|     59|        }
  197|     59|    } else {
  198|     59|        None
  199|     59|    };
  200|     59|
  201|     59|    #[cfg(feature = "trace_guest")]
  202|     59|    let trace_info = TraceInfo::new(
  203|     59|        #[cfg(feature = "unwind_guest")]
  204|     59|        _load_info,
  205|     59|    )?;
  206|     59|
  207|     59|    match *get_available_hypervisor() {
  208|       |        #[cfg(mshv)]
  209|       |        Some(HypervisorType::Mshv) => {
  210|      0|            let hv = crate::hypervisor::hyperv_linux::HypervLinuxDriver::new(
  211|      0|                regions,
  212|      0|                entrypoint_ptr,
  213|      0|                rsp_ptr,
  214|      0|                pml4_ptr,
  215|      0|                config,
  216|      0|                #[cfg(gdb)]
  217|      0|                gdb_conn,
  218|      0|                #[cfg(crashdump)]
  219|      0|                rt_cfg.clone(),
  220|      0|                #[cfg(feature = "trace_guest")]
  221|      0|                trace_info,
  222|      0|            )?;
  223|      0|            Ok(Box::new(hv))
  224|       |        }
  225|       |
  226|       |        #[cfg(kvm)]
  227|       |        Some(HypervisorType::Kvm) => {
  228|      0|            let hv = crate::hypervisor::kvm::KVMDriver::new(
  229|      0|                regions,
  230|      0|                pml4_ptr.absolute()?,
  231|      0|                entrypoint_ptr.absolute()?,
  232|      0|                rsp_ptr.absolute()?,
  233|      0|                config,
  234|       |                #[cfg(gdb)]
  235|       |                gdb_conn,
  236|       |                #[cfg(crashdump)]
  237|       |                rt_cfg.clone(),
  238|       |                #[cfg(feature = "trace_guest")]
  239|       |                trace_info,
  240|      0|            )?;
  241|      0|            Ok(Box::new(hv))
  242|       |        }
  243|       |
  244|       |        #[cfg(target_os = "windows")]
  245|       |        Some(HypervisorType::Whp) => {
  246|       |            use crate::hypervisor::wrappers::HandleWrapper;
  247|       |
  248|       |            let mmap_file_handle = mgr
  249|       |                .shared_mem
  250|       |                .with_exclusivity(|e| e.get_mmap_file_handle())?;
  251|       |            let hv = crate::hypervisor::hyperv_windows::HypervWindowsDriver::new(
  252|       |                regions,
  253|       |                mgr.shared_mem.raw_mem_size(), // we use raw_* here because windows driver requires 64K aligned addresses,
  254|       |                pml4_ptr.absolute()?,
  255|       |                entrypoint_ptr.absolute()?,
  256|       |                rsp_ptr.absolute()?,
  257|       |                HandleWrapper::from(mmap_file_handle),
  258|       |                #[cfg(gdb)]
  259|       |                gdb_conn,
  260|       |                #[cfg(crashdump)]
  261|       |                rt_cfg.clone(),
  262|       |                #[cfg(feature = "trace_guest")]
  263|       |                trace_info,
  264|       |            )?;
  265|       |            Ok(Box::new(hv))
  266|       |        }
  267|       |
  268|       |        _ => {
  269|     59|            log_then_return!(NoHypervisorFound());
  270|       |        }
  271|       |    }
  272|     59|}
  273|       |
  274|       |#[cfg(test)]
  275|       |mod tests {
  276|       |    use hyperlight_testing::{callback_guest_as_string, simple_guest_as_string};
  277|       |
  278|       |    use super::evolve_impl_multi_use;
  279|       |    use crate::UninitializedSandbox;
  280|       |    use crate::sandbox::uninitialized::GuestBinary;
  281|       |
  282|       |    #[test]
  283|      1|    fn test_evolve() {
  284|      1|        let guest_bin_paths = vec![
  285|      1|            simple_guest_as_string().unwrap(),
  286|      1|            callback_guest_as_string().unwrap(),
  287|      1|        ];
  288|      1|        for guest_bin_path in guest_bin_paths {
                          ^0
  289|      0|            let u_sbox =
  290|      0|                UninitializedSandbox::new(GuestBinary::FilePath(guest_bin_path.clone()), None)
  291|      0|                    .unwrap();
  292|      0|            evolve_impl_multi_use(u_sbox).unwrap();
  293|      0|        }
  294|      1|    }
  295|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/seccomp/guest.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use seccompiler::SeccompCmpOp::Eq;
   18|       |use seccompiler::{
   19|       |    BpfProgram, SeccompAction, SeccompCmpArgLen as ArgLen, SeccompCondition as Cond, SeccompFilter,
   20|       |    SeccompRule, TargetArch,
   21|       |};
   22|       |
   23|       |use crate::sandbox::ExtraAllowedSyscall;
   24|       |use crate::{Result, and, or};
   25|       |
   26|     23|fn syscalls_allowlist() -> Result<Vec<(i64, Vec<SeccompRule>)>> {
   27|     23|    Ok(vec![
   28|     23|        // SYS_signalstack, SYS_munmap, SYS_rt_sigprocmask, SYS_madvise, and SYS_exit
   29|     23|        // are minimally required syscalls to be able to setup our seccomp filter.
   30|     23|        (libc::SYS_sigaltstack, vec![]),
   31|     23|        (libc::SYS_munmap, vec![]),
   32|     23|        (libc::SYS_rt_sigprocmask, vec![]),
   33|     23|        (libc::SYS_madvise, vec![]),
   34|     23|        (libc::SYS_exit, vec![]),
   35|     23|        // SYS_rt_sigaction, SYS_write, and SYS_rt_sigreturn are required for the
   36|     23|        // signal handler inside the host function worker thread.
   37|     23|        (libc::SYS_rt_sigaction, vec![]),
   38|     23|        (
   39|     23|            libc::SYS_write,
   40|     23|            or![
   41|     23|                and![Cond::new(0, ArgLen::Dword, Eq, 1)?], // stdout
                                                                     ^0
   42|     23|                and![Cond::new(0, ArgLen::Dword, Eq, 2)?], // stderr
                                                                     ^0
   43|       |            ],
   44|       |        ),
   45|     23|        (libc::SYS_rt_sigreturn, vec![]),
   46|     23|        // Note: This `ioctl` is used to get information about the terminal.
   47|     23|        // I believe it is used to get terminal information by our default writer function.
   48|     23|        // That said, I am registering it here instead of in the function specifically
   49|     23|        // because we don't currently support registering parameterized syscalls.
   50|     23|        (
   51|     23|            libc::SYS_ioctl,
   52|     23|            or![and![Cond::new(
   53|     23|                1,
   54|     23|                ArgLen::Dword,
   55|     23|                Eq,
   56|     23|                #[cfg(all(
   57|     23|                    target_arch = "x86_64",
   58|     23|                    target_vendor = "unknown",
   59|     23|                    target_os = "linux",
   60|     23|                    target_env = "musl"
   61|     23|                ))]
   62|     23|                libc::TCGETS.try_into()?,
   63|     23|                #[cfg(not(all(
   64|     23|                    target_arch = "x86_64",
   65|     23|                    target_vendor = "unknown",
   66|     23|                    target_os = "linux",
   67|     23|                    target_env = "musl"
   68|     23|                )))]
   69|     23|                libc::TCGETS,
   70|     23|            )?]],
                           ^0
   71|       |        ),
   72|       |        // `futex` is needed for some tests that run in parallel (`simple_test_parallel`,
   73|       |        // and `callback_test_parallel`).
   74|     23|        (libc::SYS_futex, vec![]),
   75|     23|        // `sched_yield` is needed for many synchronization primitives that may be invoked
   76|     23|        // on the host function worker thread
   77|     23|        (libc::SYS_sched_yield, vec![]),
   78|     23|        // `mprotect` is needed by malloc during memory allocation
   79|     23|        (libc::SYS_mprotect, vec![]),
   80|     23|        // `openat` is marked allowed here because it may be called by `libc::free()`
   81|     23|        // since it will try to open /proc/sys/vm/overcommit_memory (https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/malloc-sysdep.h;h=778d8971d53e284397c3a5dcdd923e93be5e4731;hb=HEAD)
   82|     23|        // We have another more restrictive filter for it below so it will return EACCES instead of trap, in which case libc will use the default value
   83|     23|        (libc::SYS_openat, vec![]),
   84|       |    ])
   85|     23|}
   86|       |
   87|       |/// Creates two `BpfProgram`s for a `SeccompFilter` over specific syscalls/`SeccompRule`s
   88|       |/// intended to be applied on host function threads.
   89|       |///
   90|       |/// Note: This does not provide coverage over the Hyperlight host, which is why we don't need
   91|       |/// `SeccompRules` for operations we definitely perform but are outside the handler thread
   92|       |/// (e.g., `KVM_SET_USER_MEMORY_REGION`, `KVM_GET_API_VERSION`, `KVM_CREATE_VM`,
   93|       |/// or `KVM_CREATE_VCPU`).
   94|     23|pub(crate) fn get_seccomp_filter_for_host_function_worker_thread(
   95|     23|    extra_allowed_syscalls: Option<&[ExtraAllowedSyscall]>,
   96|     23|) -> Result<Vec<BpfProgram>> {
   97|     23|    let mut allowed_syscalls = syscalls_allowlist()?;
                                                                 ^0
   98|       |
   99|     23|    if let Some(extra_allowed_syscalls) = extra_allowed_syscalls {
  100|     23|        allowed_syscalls.extend(
  101|     23|            extra_allowed_syscalls
  102|     23|                .iter()
  103|     23|                .copied()
  104|     92|                .map(|syscall| (syscall, vec![])),
  105|     23|        );
  106|     23|
  107|     23|        // Remove duplicates
  108|  2.23k|        allowed_syscalls.sort_by(|a, b| a.0.cmp(&b.0));
  109|     23|        allowed_syscalls.dedup();
  110|     23|    }
                  ^0
  111|       |
  112|     23|    let arch: TargetArch = std::env::consts::ARCH.try_into()?;
                                                                          ^0
  113|       |
  114|       |    // Allowlist filter that traps on unknown syscalls
  115|     23|    let allowlist = SeccompFilter::new(
  116|     23|        allowed_syscalls.into_iter().collect(),
  117|     23|        SeccompAction::Trap,
  118|     23|        SeccompAction::Allow,
  119|     23|        arch,
  120|     23|    )?
                   ^0
  121|     23|    .try_into()?;
                             ^0
  122|       |
  123|       |    // If `openat` is an explicitly allowed syscall, we shouldn't return the filter that forces it to return EACCES.
  124|     23|    if let Some(extra_syscalls) = extra_allowed_syscalls {
  125|     23|        if extra_syscalls.contains(&libc::SYS_openat) {
  126|      0|            return Ok(vec![allowlist]);
  127|     23|        }
  128|      0|    }
  129|       |    // Otherwise, we return both filters.
  130|       |
  131|       |    // Filter that forces `openat` to return EACCES
  132|     23|    let errno_on_openat = SeccompFilter::new(
  133|     23|        [(libc::SYS_openat, vec![])].into_iter().collect(),
  134|     23|        SeccompAction::Allow,
  135|     23|        SeccompAction::Errno(libc::EACCES.try_into()?),
                                                                  ^0
  136|     23|        arch,
  137|      0|    )?
  138|     23|    .try_into()?;
                             ^0
  139|       |
  140|       |    // Note: the order of the 2 filters are important. If we applied the strict filter first,
  141|       |    // we wouldn't be allowed to setup the second filter (would be trapped since the syscalls to setup seccomp are not allowed).
  142|       |    // However, from an seccomp filter perspective, the order of the filters is not important:
  143|       |    //
  144|       |    //    If multiple filters exist, they are all executed, in reverse order
  145|       |    //    of their addition to the filter treethat is, the most recently
  146|       |    //    installed filter is executed first.  (Note that all filters will
  147|       |    //    be called even if one of the earlier filters returns
  148|       |    //    SECCOMP_RET_KILL.  This is done to simplify the kernel code and to
  149|       |    //    provide a tiny speed-up in the execution of sets of filters by
  150|       |    //    avoiding a check for this uncommon case.)  The return value for
  151|       |    //    the evaluation of a given system call is the first-seen action
  152|       |    //    value of highest precedence (along with its accompanying data)
  153|       |    //    returned by execution of all of the filters.
  154|       |    //
  155|       |    //  (https://man7.org/linux/man-pages/man2/seccomp.2.html).
  156|       |    //
  157|     23|    Ok(vec![errno_on_openat, allowlist])
  158|     23|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/signal_handlers/mod.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use libc::c_int;
   18|       |
   19|       |use crate::sandbox::SandboxConfiguration;
   20|       |
   21|       |#[cfg(feature = "seccomp")]
   22|       |pub mod sigsys_signal_handler;
   23|       |
   24|      0|pub(crate) fn setup_signal_handlers(config: &SandboxConfiguration) -> crate::Result<()> {
   25|      0|    // This is unsafe because signal handlers only allow a very restrictive set of
   26|      0|    // functions (i.e., async-signal-safe functions) to be executed inside them.
   27|      0|    // Anything that performs memory allocations, locks, and others are non-async-signal-safe.
   28|      0|    // Hyperlight signal handlers are all designed to be async-signal-safe, so this function
   29|      0|    // should be safe to call.
   30|      0|    #[cfg(feature = "seccomp")]
   31|      0|    {
   32|      0|        vmm_sys_util::signal::register_signal_handler(
   33|      0|            libc::SIGSYS,
   34|      0|            sigsys_signal_handler::handle_sigsys,
   35|      0|        )
   36|      0|        .map_err(crate::HyperlightError::VmmSysError)?;
   37|       |
   38|      0|        let original_hook = std::panic::take_hook();
   39|      0|        // Set a custom panic hook that checks for "DisallowedSyscall"
   40|      0|        std::panic::set_hook(Box::new(move |panic_info| {
   41|      0|            // Check if the panic payload matches "DisallowedSyscall"
   42|      0|            if let Some(crate::HyperlightError::DisallowedSyscall) = panic_info
   43|      0|                .payload()
   44|      0|                .downcast_ref::<crate::HyperlightError>(
   45|      0|            ) {
   46|       |                // Do nothing to avoid superfluous syscalls
   47|      0|                return;
   48|      0|            }
   49|      0|            // If not "DisallowedSyscall", use the original hook
   50|      0|            original_hook(panic_info);
   51|      0|        }));
   52|      0|    }
   53|      0|    vmm_sys_util::signal::register_signal_handler(
   54|      0|        libc::SIGRTMIN() + config.get_interrupt_vcpu_sigrtmin_offset() as c_int,
   55|      0|        vm_kill_signal,
   56|      0|    )
   57|      0|    .map_err(crate::HyperlightError::VmmSysError)?;
   58|       |
   59|       |    // Note: For libraries registering signal handlers, it's important to keep in mind that
   60|       |    // the user of the library could have their own signal handlers that we don't want to
   61|       |    // overwrite. The common practice there is to provide signal handling chaining, which
   62|       |    // means that the signal is handled by all registered handlers from the last registered
   63|       |    // to the first. **Hyperlight does not provide signal chaining**. For SIGSYS, this is because,
   64|       |    // currently, Hyperlight handles SIGSYS signals by directly altering the instruction pointer at
   65|       |    // the time the syscall occurred to call a function that will panic the host function execution.
   66|       |    // For SIGRTMIN, this is because Hyperlight issues potentially 200 signals back-to-back and its
   67|       |    // likely that the embedder will not want to handle this.
   68|       |
   69|      0|    Ok(())
   70|      0|}
   71|       |
   72|      0|extern "C" fn vm_kill_signal(_: libc::c_int, _: *mut libc::siginfo_t, _: *mut libc::c_void) {
   73|      0|    // Do nothing. SIGRTMIN is just used to issue a VM exit to the underlying VM.
   74|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/signal_handlers/sigsys_signal_handler.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |#[cfg(feature = "seccomp")]
   18|      0|pub(super) extern "C" fn handle_sigsys(
   19|      0|    signal: i32,
   20|      0|    info: *mut libc::siginfo_t,
   21|      0|    context: *mut libc::c_void,
   22|      0|) {
   23|       |    #[cfg(target_arch = "x86_64")]
   24|       |    {
   25|      0|        unsafe {
   26|      0|            // si_code contains the reason for the SIGSYS signal.
   27|      0|            // SYS_SECCOMP is 1 as per:
   28|      0|            // https://github.com/torvalds/linux/blob/81983758430957d9a5cb3333fe324fd70cf63e7e/include/uapi/asm-generic/siginfo.h#L301C9-L301C21
   29|      0|            const SYS_SECCOMP: libc::c_int = 1;
   30|       |            // Sanity checks to make sure SIGSYS was triggered by a BPF filter.
   31|       |            // If something else triggered a SIGSYS (i.e., kill()), we do nothing.
   32|       |            // Inspired by Chromium's sandbox:
   33|       |            // https://chromium.googlesource.com/chromium/chromium/+/master/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#572
   34|      0|            if signal != libc::SIGSYS
   35|      0|                || (*info).si_code != SYS_SECCOMP
   36|      0|                || context.is_null()
   37|      0|                || (*info).si_errno < 0
   38|       |            {
   39|      0|                let err_msg =
   40|      0|                    b"[ERROR][HYPERLIGHT] SIGSYS triggered by something other than a BPF filter\n";
   41|      0|                libc::write(
   42|      0|                    libc::STDERR_FILENO,
   43|      0|                    err_msg.as_ptr() as *const _,
   44|      0|                    err_msg.len(),
   45|      0|                );
   46|      0|                return;
   47|      0|            }
   48|      0|
   49|      0|            let err_msg = b"[ERROR][HYPERLIGHT] Handling disallowed syscall\n";
   50|      0|            libc::write(
   51|      0|                libc::STDERR_FILENO,
   52|      0|                err_msg.as_ptr() as *const _,
   53|      0|                err_msg.len(),
   54|      0|            );
   55|       |
   56|       |            // We get the syscall number by accessing a particular offset in the `siginfo_t` struct.
   57|       |            // This only works because this is handling a SIGSYS signal (i.e., the `siginfo_t` struct
   58|       |            // is implemented as a union in the kernel:
   59|       |            // https://github.com/torvalds/linux/blob/master/include/uapi/asm-generic/siginfo.h).
   60|       |            // Note: This is not necessarily platform-agnostic, so we might want to be more careful here
   61|       |            // in the future.
   62|       |            const SI_OFF_SYSCALL: isize = 6;
   63|      0|            let syscall = *(info as *const i32).offset(SI_OFF_SYSCALL) as usize;
   64|      0|            let syscall_bytes = raw_format(b"[ERROR][HYPERLIGHT] Disallowed Syscall: ", syscall);
   65|      0|
   66|      0|            // `write` as per https://man7.org/linux/man-pages/man7/signal-safety.7.html
   67|      0|            // is async-signal-safe.
   68|      0|            libc::write(
   69|      0|                libc::STDERR_FILENO,
   70|      0|                syscall_bytes.as_ptr() as *const _,
   71|      0|                syscall_bytes.len(),
   72|      0|            );
   73|      0|
   74|      0|            // Note: This is not necessarily platform-agnostic, so we might want to be more careful here
   75|      0|            // in the future.
   76|      0|            let ucontext = context as *mut libc::ucontext_t;
   77|      0|            let mcontext = &mut (*ucontext).uc_mcontext;
   78|      0|
   79|      0|            if syscall == libc::SYS_ioctl as usize {
   80|      0|                let ioctl_param = mcontext.gregs[libc::REG_EBRACE as usize] as usize;
   81|      0|                let ioctl_param_bytes =
   82|      0|                    raw_format(b"[ERROR][HYPERLIGHT] IOCTL Param: ", ioctl_param);
   83|      0|                libc::write(
   84|      0|                    libc::STDERR_FILENO,
   85|      0|                    ioctl_param_bytes.as_ptr() as *const _,
   86|      0|                    ioctl_param_bytes.len(),
   87|      0|                );
   88|      0|            }
   89|       |
   90|       |            // We don't want to return execution to the offending host function, so
   91|       |            // we alter the RIP register to point to a function that will panic out of
   92|       |            // the host function call.
   93|      0|            mcontext.gregs[libc::REG_RIP as usize] =
   94|      0|                after_syscall_violation as usize as libc::greg_t;
   95|       |        }
   96|       |    }
   97|       |
   98|       |    #[cfg(not(target_arch = "x86_64"))]
   99|       |    {
  100|       |        compile_error!("Unsupported architecture for seccomp feature");
  101|       |    }
  102|      0|}
  103|       |
  104|      0|extern "C-unwind" fn after_syscall_violation() {
  105|      0|    #[allow(clippy::panic)]
  106|      0|    std::panic::panic_any(crate::HyperlightError::DisallowedSyscall);
  107|       |}
  108|       |
  109|      0|fn raw_format(prefix: &[u8], raw: usize) -> [u8; 64] {
  110|       |    const PREFIX_BUF_LEN: usize = 64;
  111|       |    const DIGITS_BUF_LEN: usize = 20;
  112|       |
  113|      0|    let mut buffer = [0u8; PREFIX_BUF_LEN];
  114|      0|    let mut i = prefix.len();
  115|      0|
  116|      0|    // Copy the prefix message into the buffer.
  117|      0|    buffer[..i].copy_from_slice(prefix);
  118|      0|
  119|      0|    // Format the number at the end of the buffer.
  120|      0|    let mut num = raw;
  121|      0|    let mut digits = [0u8; DIGITS_BUF_LEN];
  122|      0|    let mut j = 19;
  123|      0|    if num == 0 {
  124|      0|        digits[j] = b'0';
  125|      0|        j -= 1;
  126|      0|    } else {
  127|      0|        while num > 0 {
  128|      0|            digits[j] = b'0' + (num % 10) as u8;
  129|      0|            num /= 10;
  130|      0|            j -= 1;
  131|      0|        }
  132|       |    }
  133|       |
  134|       |    // Copy the number digits to the buffer after the prefix.
  135|      0|    let num_len = 19 - j;
  136|      0|    buffer[i..i + num_len].copy_from_slice(&digits[j + 1..20]);
  137|      0|    i += num_len;
  138|      0|
  139|      0|    // Add a newline at the end.
  140|      0|    buffer[i] = b'\n';
  141|      0|
  142|      0|    buffer
  143|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/testing/log_values.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use serde_json::{Map, Value};
   18|       |
   19|       |use crate::{Result, new_error};
   20|       |
   21|       |/// Call `check_value_as_str` and panic if it returned an `Err`. Otherwise,
   22|       |/// do nothing.
   23|       |#[track_caller]
   24|      0|pub(crate) fn test_value_as_str(values: &Map<String, Value>, key: &str, expected_value: &str) {
   25|      0|    if let Err(e) = check_value_as_str(values, key, expected_value) {
   26|      0|        panic!("{e:?}");
   27|      0|    }
   28|      0|}
   29|       |
   30|       |/// Check to see if the value in `values` for key `key` matches
   31|       |/// `expected_value`. If so, return `Ok(())`. Otherwise, return an `Err`
   32|       |/// indicating the mismatch.
   33|      0|pub(crate) fn check_value_as_str(
   34|      0|    values: &Map<String, Value>,
   35|      0|    key: &str,
   36|      0|    expected_value: &str,
   37|      0|) -> Result<()> {
   38|      0|    let value = try_to_string(values, key)?;
   39|      0|    if expected_value != value {
   40|      0|        return Err(new_error!(
   41|      0|            "expected value {} != value {}",
   42|      0|            expected_value,
   43|      0|            value
   44|      0|        ));
   45|      0|    }
   46|      0|    Ok(())
   47|      0|}
   48|       |
   49|       |/// Fetch the value in `values` with key `key` and, if it existed, convert
   50|       |/// it to a string. If all those steps succeeded, return an `Ok` with the
   51|       |/// string value inside. Otherwise, return an `Err`.
   52|      0|fn try_to_string<'a>(values: &'a Map<String, Value>, key: &'a str) -> Result<&'a str> {
   53|      0|    if let Some(value) = values.get(key) {
   54|      0|        if let Some(value_str) = value.as_str() {
   55|      0|            Ok(value_str)
   56|       |        } else {
   57|      0|            Err(new_error!("value with key {} was not a string", key))
   58|       |        }
   59|       |    } else {
   60|      0|        Err(new_error!("value for key {} was not found", key))
   61|       |    }
   62|      0|}
   63|       |
   64|       |#[cfg(feature = "build-metadata")]
   65|       |pub(crate) mod build_metadata_testing {
   66|       |    use super::*;
   67|       |
   68|       |    /// A single value in the parameter list for the `try_to_strings`
   69|       |    /// function.
   70|       |    pub(crate) type MapLookup<'a> = (&'a Map<String, Value>, &'a str);
   71|       |
   72|       |    /// Given a constant-size slice of `MapLookup`s, attempt to look up the
   73|       |    /// string value in each `MapLookup`'s map (the first tuple element) for
   74|       |    /// that `MapLookup`'s key (the second tuple element). If the lookup
   75|       |    /// succeeded, attempt to convert the resulting value to a string. Return
   76|       |    /// `Ok` with all the successfully looked-up string values, or `Err`
   77|       |    /// if any one or more lookups or string conversions failed.
   78|      0|    pub(crate) fn try_to_strings<'a, const NUM: usize>(
   79|      0|        lookups: [MapLookup<'a>; NUM],
   80|      0|    ) -> Result<[&'a str; NUM]> {
   81|      0|        // Note (from arschles) about this code:
   82|      0|        //
   83|      0|        // In theory, there's a way to write this function in the functional
   84|      0|        // programming (FP) style -- e.g. with a fold, map, flat_map, or
   85|      0|        // something similar -- and without any mutability.
   86|      0|        //
   87|      0|        // In practice, however, since we're taking in a statically-sized slice,
   88|      0|        // and we are expected to return a statically-sized slice of the same
   89|      0|        // size, we are more limited in what we can do. There is a way to design
   90|      0|        // a fold or flat_map to iterate over the lookups parameter and attempt to
   91|      0|        // transform each MapLookup into the string value at that key.
   92|      0|        //
   93|      0|        // I wrote that code, which I'll called the "FP code" hereafter, and
   94|      0|        // noticed two things:
   95|      0|        //
   96|      0|        // - It required several places where I had to explicitly deal with long
   97|      0|        // and complex (in my opinion) types
   98|      0|        // - It wasn't much more succinct or shorter than the code herein
   99|      0|        //
  100|      0|        // The FP code is functionally "pure" and maybe fun to write (if you like
  101|      0|        // Rust or you love FP), but not fun to read. In fact, because of all the
  102|      0|        // explicit type ceremony, I bet it'd make even the most hardcore Haskell
  103|      0|        // programmer blush.
  104|      0|        //
  105|      0|        // So, I've decided to use a little bit of mutability to implement this
  106|      0|        // function in a way I think most programmers would agree is easier to
  107|      0|        // reason about and understand quickly.
  108|      0|        //
  109|      0|        // Final performance note:
  110|      0|        //
  111|      0|        // It's likely, but not certain, that the FP code is probably not
  112|      0|        // significantly more memory efficient than this, since the compiler knows
  113|      0|        // the size of both the input and output slices. Plus, this is test code,
  114|      0|        // so even if this were 2x slower, I'd still argue the ease of
  115|      0|        // understanding is more valuable than the (relatively small) memory
  116|      0|        // savings.
  117|      0|        let mut ret_slc: [&'a str; NUM] = [""; NUM];
  118|      0|        for (idx, lookup) in lookups.iter().enumerate() {
  119|      0|            let map = lookup.0;
  120|      0|            let key = lookup.1;
  121|      0|            let val = try_to_string(map, key)?;
  122|      0|            ret_slc[idx] = val
  123|       |        }
  124|      0|        Ok(ret_slc)
  125|      0|    }
  126|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_host/src/testing/mod.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::fs;
   18|       |use std::path::PathBuf;
   19|       |
   20|       |use hyperlight_testing::rust_guest_as_pathbuf;
   21|       |
   22|       |use crate::mem::exe::ExeInfo;
   23|       |use crate::{Result, new_error};
   24|       |pub(crate) mod log_values;
   25|       |
   26|       |/// Get an `ExeInfo` representing `simpleguest.exe`
   27|      1|pub(crate) fn simple_guest_exe_info() -> Result<ExeInfo> {
   28|      1|    let bytes = bytes_for_path(rust_guest_as_pathbuf("simpleguest"))?;
                                                                                  ^0
   29|      1|    ExeInfo::from_buf(bytes.as_slice())
   30|      1|}
   31|       |
   32|       |/// Read the file at `path_buf` into a `Vec<u8>` and return it,
   33|       |/// or return `Err` if that went wrong
   34|      1|pub(crate) fn bytes_for_path(path_buf: PathBuf) -> Result<Vec<u8>> {
   35|      1|    let guest_path = path_buf
   36|      1|        .as_path()
   37|      1|        .to_str()
   38|      1|        .ok_or_else(|| new_error!("couldn't convert guest {:?} to a path", path_buf))?;
                                     ^0                                                            ^0
   39|      1|    let guest_bytes = fs::read(guest_path)
   40|      1|        .map_err(|e| new_error!("failed to open guest at path {} ({})", guest_path, e))?;
                                   ^0                                                                ^0
   41|      1|    Ok(guest_bytes)
   42|      1|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_testing/src/lib.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |// This crate contains testing utilities which need to be shared across multiple
   18|       |// crates in this project.
   19|       |use std::env;
   20|       |use std::path::PathBuf;
   21|       |
   22|       |use anyhow::{Result, anyhow};
   23|       |
   24|       |pub const MANIFEST_DIR: &str = env!("CARGO_MANIFEST_DIR");
   25|       |pub mod logger;
   26|       |pub mod simplelogger;
   27|       |pub mod tracing_subscriber;
   28|       |
   29|       |/// Join all the `&str`s in the `v` parameter as a path with appropriate
   30|       |/// path separators, then prefix it with `start`, again with the appropriate
   31|       |/// path separator
   32|     65|fn join_to_path(start: &str, v: Vec<&str>) -> PathBuf {
   33|     65|    let fold_start: PathBuf = {
   34|     65|        let mut pb = PathBuf::new();
   35|     65|        pb.push(start);
   36|     65|        pb
   37|     65|    };
   38|    390|    let fold_closure = |mut agg: PathBuf, cur: &&str| {
   39|    390|        agg.push(cur);
   40|    390|        agg
   41|    390|    };
   42|     65|    v.iter().fold(fold_start, fold_closure)
   43|     65|}
   44|       |
   45|       |/// Get a new `PathBuf` to a specified Rust guest
   46|       |/// $REPO_ROOT/src/tests/rust_guests/bin/${profile}/net6.0
   47|     62|pub fn rust_guest_as_pathbuf(guest: &str) -> PathBuf {
   48|     62|    let build_dir_selector = if cfg!(debug_assertions) {
   49|     62|        "debug"
   50|       |    } else {
   51|      0|        "release"
   52|       |    };
   53|       |
   54|     62|    join_to_path(
   55|     62|        MANIFEST_DIR,
   56|     62|        vec![
   57|     62|            "..",
   58|     62|            "tests",
   59|     62|            "rust_guests",
   60|     62|            "bin",
   61|     62|            build_dir_selector,
   62|     62|            guest,
   63|     62|        ],
   64|     62|    )
   65|     62|}
   66|       |
   67|       |/// Get a fully qualified OS-specific path to the simpleguest elf binary
   68|     58|pub fn simple_guest_as_string() -> Result<String> {
   69|     58|    let buf = rust_guest_as_pathbuf("simpleguest");
   70|     58|    buf.to_str()
   71|     58|        .map(|s| s.to_string())
   72|     58|        .ok_or_else(|| anyhow!("couldn't convert simple guest PathBuf to string"))
                                     ^0
   73|     58|}
   74|       |
   75|       |/// Get a fully qualified OS-specific path to the callbackguest elf binary
   76|      3|pub fn callback_guest_as_string() -> Result<String> {
   77|      3|    let buf = rust_guest_as_pathbuf("callbackguest");
   78|      3|    buf.to_str()
   79|      3|        .map(|s| s.to_string())
   80|      3|        .ok_or_else(|| anyhow!("couldn't convert callback guest PathBuf to string"))
                                     ^0
   81|      3|}
   82|       |
   83|       |/// Get a fully-qualified OS-specific path to the witguest elf binary
   84|      0|pub fn wit_guest_as_string() -> Result<String> {
   85|      0|    let buf = rust_guest_as_pathbuf("witguest");
   86|      0|    buf.to_str()
   87|      0|        .map(|s| s.to_string())
   88|      0|        .ok_or_else(|| anyhow!("couldn't convert callback guest PathBuf to string"))
   89|      0|}
   90|       |
   91|       |/// Get a fully qualified OS-specific path to the dummyguest elf binary
   92|      0|pub fn dummy_guest_as_string() -> Result<String> {
   93|      0|    let buf = rust_guest_as_pathbuf("dummyguest");
   94|      0|    buf.to_str()
   95|      0|        .map(|s| s.to_string())
   96|      0|        .ok_or_else(|| anyhow!("couldn't convert dummy guest PathBuf to string"))
   97|      0|}
   98|       |
   99|      3|pub fn c_guest_as_pathbuf(guest: &str) -> PathBuf {
  100|      3|    let build_dir_selector = if cfg!(debug_assertions) {
  101|      3|        "debug"
  102|       |    } else {
  103|      0|        "release"
  104|       |    };
  105|       |
  106|      3|    join_to_path(
  107|      3|        MANIFEST_DIR,
  108|      3|        vec!["..", "tests", "c_guests", "bin", build_dir_selector, guest],
  109|      3|    )
  110|      3|}
  111|       |
  112|      3|pub fn c_simple_guest_as_string() -> Result<String> {
  113|      3|    let buf = c_guest_as_pathbuf("simpleguest");
  114|      3|    buf.to_str()
  115|      3|        .map(|s| s.to_string())
  116|      3|        .ok_or_else(|| anyhow!("couldn't convert simple guest PathBuf to string"))
                                     ^0
  117|      3|}
  118|       |
  119|      0|pub fn c_callback_guest_as_string() -> Result<String> {
  120|      0|    let buf = c_guest_as_pathbuf("callbackguest");
  121|      0|    buf.to_str()
  122|      0|        .map(|s| s.to_string())
  123|      0|        .ok_or_else(|| anyhow!("couldn't convert callback guest PathBuf to string"))
  124|      0|}
  125|       |
  126|       |/// Get a fully qualified path to a simple guest binary preferring a binary
  127|       |/// in the same directory as the parent executable. This will be used in
  128|       |/// fuzzing scenarios where pre-built binaries will be built and submitted to
  129|       |/// a fuzzing framework.
  130|      0|pub fn simple_guest_for_fuzzing_as_string() -> Result<String> {
  131|      0|    let exe_dir = env::current_exe()
  132|      0|        .ok()
  133|      0|        .and_then(|path| path.parent().map(|p| p.to_path_buf()));
  134|       |
  135|      0|    if let Some(exe_dir) = exe_dir {
  136|      0|        let guest_path = exe_dir.join("simpleguest");
  137|      0|
  138|      0|        if guest_path.exists() {
  139|      0|            return Ok(guest_path
  140|      0|                .to_str()
  141|      0|                .ok_or(anyhow!("Invalid path string"))?
  142|      0|                .to_string());
  143|      0|        }
  144|      0|    }
  145|       |
  146|      0|    simple_guest_as_string()
  147|      0|}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_testing/src/logger.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::cell::RefCell;
   18|       |use std::sync::Once;
   19|       |use std::thread::current;
   20|       |
   21|       |use log::{Level, LevelFilter, Log, Metadata, Record, set_logger, set_max_level};
   22|       |use once_cell::sync::Lazy;
   23|       |use tracing_log::LogTracer;
   24|       |
   25|       |pub static LOGGER: Logger = Logger {};
   26|       |static LOG_TRACER: Lazy<LogTracer> = Lazy::new(LogTracer::new);
   27|       |static INITLOGGER: Once = Once::new();
   28|       |#[derive(Clone, Eq, PartialEq)]
   29|       |pub struct LogCall {
   30|       |    pub level: Level,
   31|       |    pub args: String,
   32|       |    pub target: String,
   33|       |    pub line: Option<u32>,
   34|       |    pub file: Option<String>,
   35|       |    pub module_path: Option<String>,
   36|       |}
   37|       |
   38|       |thread_local!(
   39|       |    static LOGCALLS: RefCell<Vec<LogCall>> = const { RefCell::new(Vec::<LogCall>::new()) };
   40|       |    static LOGGER_MAX_LEVEL: RefCell<LevelFilter> = const { RefCell::new(LevelFilter::Off) };
   41|       |);
   42|       |
   43|       |pub struct Logger {}
   44|       |
   45|       |impl Logger {
   46|      0|    pub fn initialize_test_logger() {
   47|      0|        INITLOGGER.call_once(|| {
   48|      0|            set_logger(&LOGGER).unwrap();
   49|      0|            set_max_level(log::LevelFilter::Trace);
   50|      0|        });
   51|      0|    }
   52|       |
   53|      0|    pub fn initialize_log_tracer() {
   54|      0|        INITLOGGER.call_once(|| {
   55|      0|            set_logger(&*LOG_TRACER).unwrap();
   56|      0|            set_max_level(log::LevelFilter::Trace);
   57|      0|        });
   58|      0|    }
   59|       |
   60|      0|    pub fn num_log_calls(&self) -> usize {
   61|      0|        LOGCALLS.with(|log_calls| log_calls.borrow().len())
   62|      0|    }
   63|      0|    pub fn get_log_call(&self, idx: usize) -> Option<LogCall> {
   64|      0|        LOGCALLS.with(|log_calls| log_calls.borrow().get(idx).cloned())
   65|      0|    }
   66|       |
   67|      0|    pub fn clear_log_calls(&self) {
   68|      0|        LOGCALLS.with(|log_calls| log_calls.borrow_mut().clear());
   69|      0|    }
   70|       |
   71|      0|    pub fn test_log_records<F: Fn(&Vec<LogCall>)>(&self, f: F) {
   72|      0|        LOGCALLS.with(|log_calls| f(&log_calls.borrow()));
   73|      0|        self.clear_log_calls();
   74|      0|    }
   75|       |
   76|      0|    pub fn set_max_level(&self, level: LevelFilter) {
   77|      0|        LOGGER_MAX_LEVEL.with(|max_level| {
   78|      0|            *max_level.borrow_mut() = level;
   79|      0|        });
   80|      0|    }
   81|       |}
   82|       |
   83|       |impl Log for Logger {
   84|      0|    fn enabled(&self, metadata: &Metadata) -> bool {
   85|      0|        LOGGER_MAX_LEVEL.with(|max_level| metadata.level() <= *max_level.borrow())
   86|      0|    }
   87|      0|    fn log(&self, record: &Record) {
   88|      0|        if !self.enabled(record.metadata()) {
   89|      0|            return;
   90|      0|        }
   91|      0|
   92|      0|        LOGCALLS.with(|log_calls| {
   93|      0|            if record.target().contains("hyperlight_guest") {
   94|      0|                println!("Thread {:?} {:?}", current().id(), record);
   95|      0|                println!("Thread {:?} {:?}", current().id(), record.metadata());
   96|      0|            }
   97|      0|            log_calls.borrow_mut().push(LogCall {
   98|      0|                level: record.level(),
   99|      0|                args: format!("{}", record.args()),
  100|      0|                target: record.target().to_string(),
  101|      0|                line: record.line(),
  102|      0|                file: match record.file() {
  103|      0|                    None => record.file_static().map(|file| file.to_string()),
  104|      0|                    Some(file) => Some(file.to_string()),
  105|       |                },
  106|      0|                module_path: match record.module_path() {
  107|      0|                    None => record
  108|      0|                        .module_path_static()
  109|      0|                        .map(|module_path| module_path.to_string()),
  110|      0|                    Some(module_path) => Some(module_path.to_string()),
  111|       |                },
  112|       |            })
  113|      0|        });
  114|      0|
  115|      0|        println!("Thread {:?} {:?}", current().id(), record);
  116|      0|    }
  117|       |
  118|      0|    fn flush(&self) {}
  119|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_testing/src/simplelogger.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |#![allow(static_mut_refs)]
   17|       |// this is a non threadsafe logger for testing purposes, to test the log messages emitted by the guest.
   18|       |// it will only log messages from the hyperlight_guest target. It will not log messages from other targets.
   19|       |// this target is only used when handling an outb log request from the guest, so this logger will only capture those messages.
   20|       |
   21|       |use std::sync::Once;
   22|       |use std::thread::current;
   23|       |
   24|       |use log::{Level, Log, Metadata, Record, set_logger, set_max_level};
   25|       |
   26|       |pub static LOGGER: SimpleLogger = SimpleLogger {};
   27|       |static INITLOGGER: Once = Once::new();
   28|       |#[derive(Clone, Eq, PartialEq, Debug)]
   29|       |pub struct LogCall {
   30|       |    pub level: Level,
   31|       |    pub args: String,
   32|       |    pub target: String,
   33|       |    pub line: Option<u32>,
   34|       |    pub file: Option<String>,
   35|       |    pub module_path: Option<String>,
   36|       |}
   37|       |
   38|       |static mut LOGCALLS: Vec<LogCall> = Vec::<LogCall>::new();
   39|       |static mut NUMBER_OF_ENABLED_CALLS: usize = 0;
   40|       |
   41|       |pub struct SimpleLogger {}
   42|       |
   43|       |impl SimpleLogger {
   44|      0|    pub fn initialize_test_logger() {
   45|      0|        INITLOGGER.call_once(|| {
   46|      0|            set_logger(&LOGGER).unwrap();
   47|      0|            set_max_level(log::LevelFilter::Trace);
   48|      0|        });
   49|      0|    }
   50|       |
   51|      0|    pub fn num_enabled_calls(&self) -> usize {
   52|      0|        unsafe { NUMBER_OF_ENABLED_CALLS }
   53|      0|    }
   54|       |
   55|      0|    pub fn num_log_calls(&self) -> usize {
   56|      0|        unsafe { LOGCALLS.len() }
   57|      0|    }
   58|      0|    pub fn get_log_call(&self, idx: usize) -> Option<LogCall> {
   59|      0|        unsafe { LOGCALLS.get(idx).cloned() }
   60|      0|    }
   61|       |
   62|      0|    pub fn clear_log_calls(&self) {
   63|      0|        unsafe {
   64|      0|            LOGCALLS.clear();
   65|      0|            NUMBER_OF_ENABLED_CALLS = 0;
   66|      0|        }
   67|      0|    }
   68|       |
   69|      0|    pub fn test_log_records<F: Fn(&Vec<LogCall>)>(&self, f: F) {
   70|      0|        unsafe {
   71|      0|            // this logger is only used for testing so unsafe is fine here
   72|      0|            #[allow(static_mut_refs)]
   73|      0|            f(&LOGCALLS);
   74|      0|        };
   75|      0|        self.clear_log_calls();
   76|      0|    }
   77|       |}
   78|       |
   79|       |impl Log for SimpleLogger {
   80|      0|    fn enabled(&self, metadata: &Metadata) -> bool {
   81|      0|        // This allows us to count the actual number of messages that have been logged by the guest
   82|      0|        // because the guest derives its log level from the host log level then the number times that enabled is called for
   83|      0|        // the "hyperlight_guest" target will be the same as the number of messages logged by the guest.
   84|      0|        // In other words this function should always return true for the "hyperlight_guest" target.
   85|      0|        unsafe {
   86|      0|            if metadata.target() == "hyperlight_guest" {
   87|      0|                NUMBER_OF_ENABLED_CALLS += 1;
   88|      0|            }
   89|      0|            metadata.target() == "hyperlight_guest" && metadata.level() <= log::max_level()
   90|       |        }
   91|      0|    }
   92|      0|    fn log(&self, record: &Record) {
   93|      0|        if !self.enabled(record.metadata()) {
   94|      0|            return;
   95|      0|        }
   96|      0|
   97|      0|        unsafe {
   98|      0|            LOGCALLS.push(LogCall {
   99|      0|                level: record.level(),
  100|      0|                args: format!("{}", record.args()),
  101|      0|                target: record.target().to_string(),
  102|      0|                line: record.line(),
  103|      0|                file: match record.file() {
  104|      0|                    None => record.file_static().map(|file| file.to_string()),
  105|      0|                    Some(file) => Some(file.to_string()),
  106|       |                },
  107|      0|                module_path: match record.module_path() {
  108|      0|                    None => record
  109|      0|                        .module_path_static()
  110|      0|                        .map(|module_path| module_path.to_string()),
  111|      0|                    Some(module_path) => Some(module_path.to_string()),
  112|       |                },
  113|       |            });
  114|       |        };
  115|       |
  116|      0|        println!("Thread {:?} {:?}", current().id(), record);
  117|      0|    }
  118|       |
  119|      0|    fn flush(&self) {}
  120|       |}

/home/runner/work/hyperlight/hyperlight/src/hyperlight_testing/src/tracing_subscriber.rs:
    1|       |/*
    2|       |Copyright 2025  The Hyperlight Authors.
    3|       |
    4|       |Licensed under the Apache License, Version 2.0 (the "License");
    5|       |you may not use this file except in compliance with the License.
    6|       |You may obtain a copy of the License at
    7|       |
    8|       |    http://www.apache.org/licenses/LICENSE-2.0
    9|       |
   10|       |Unless required by applicable law or agreed to in writing, software
   11|       |distributed under the License is distributed on an "AS IS" BASIS,
   12|       |WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |See the License for the specific language governing permissions and
   14|       |limitations under the License.
   15|       |*/
   16|       |
   17|       |use std::cell::RefCell;
   18|       |use std::collections::HashMap;
   19|       |
   20|       |use serde_json::{Value, json, to_string_pretty};
   21|       |use tracing::Subscriber;
   22|       |use tracing_core::event::Event;
   23|       |use tracing_core::metadata::Metadata;
   24|       |use tracing_core::span::{Attributes, Current, Id, Record};
   25|       |use tracing_core::{Level, LevelFilter};
   26|       |use tracing_serde::AsSerde;
   27|       |
   28|       |#[derive(Debug, Clone)]
   29|       |pub struct TracingSubscriber {}
   30|       |
   31|       |thread_local!(
   32|       |    static SPAN_METADATA: RefCell<HashMap<u64, &'static Metadata<'static>>> =
   33|       |        RefCell::new(HashMap::new());
   34|       |    static SPANS: RefCell<HashMap<u64, Value>> = RefCell::new(HashMap::new());
   35|       |    static EVENTS: RefCell<Vec<Value>> = const { RefCell::new(Vec::new()) };
   36|       |    static LEVEL_FILTER: RefCell<LevelFilter> = const { RefCell::new(LevelFilter::OFF) };
   37|       |    static NEXT_ID: RefCell<u64> = const { RefCell::new(1) };
   38|       |    static SPAN_STACK: RefCell<Vec<Id>> = const { RefCell::new(Vec::new()) };
   39|       |);
   40|       |
   41|       |impl TracingSubscriber {
   42|      0|    pub fn new(trace_level: Level) -> Self {
   43|      0|        LEVEL_FILTER.with(|level_filter| *level_filter.borrow_mut() = trace_level.into());
   44|      0|        Self {}
   45|      0|    }
   46|       |
   47|      0|    pub fn get_span_metadata(&self, id: u64) -> &'static Metadata<'static> {
   48|      0|        SPAN_METADATA.with(
   49|      0|            |span_metadata: &RefCell<HashMap<u64, &Metadata<'static>>>| -> &Metadata<'static> {
   50|      0|                span_metadata
   51|      0|                    .borrow()
   52|      0|                    .get(&id)
   53|      0|                    .unwrap_or_else(|| panic!("Failed to get span metadata ID {}", id))
   54|      0|            },
   55|      0|        )
   56|      0|    }
   57|       |
   58|      0|    pub fn get_span(&self, id: u64) -> Value {
   59|      0|        SPANS.with(|spans| {
   60|      0|            spans
   61|      0|                .borrow()
   62|      0|                .get(&id)
   63|      0|                .unwrap_or_else(|| panic!("Failed to get span ID {}", id))
   64|      0|                .clone()
   65|      0|        })
   66|      0|    }
   67|       |
   68|      0|    pub fn get_events(&self) -> Vec<Value> {
   69|      0|        EVENTS.with(|events| events.borrow().clone())
   70|      0|    }
   71|       |
   72|      0|    pub fn test_trace_records<F: Fn(&HashMap<u64, Value>, &Vec<Value>)>(&self, f: F) {
   73|      0|        SPANS.with(|spans| {
   74|      0|            EVENTS.with(|events| {
   75|      0|                f(&spans.borrow().clone(), &events.borrow().clone());
   76|      0|                events.borrow_mut().clear();
   77|      0|            });
   78|      0|        });
   79|      0|    }
   80|       |
   81|      0|    pub fn clear(&self) {
   82|      0|        SPANS.with(|spans| spans.borrow_mut().clear());
   83|      0|        EVENTS.with(|events| events.borrow_mut().clear());
   84|      0|        SPAN_STACK.with(|span_stack| span_stack.borrow_mut().clear());
   85|      0|        SPAN_METADATA.with(|span_metadata| span_metadata.borrow_mut().clear());
   86|      0|        NEXT_ID.with(|next_id| *next_id.borrow_mut() = 1);
   87|      0|    }
   88|       |}
   89|       |
   90|       |impl Subscriber for TracingSubscriber {
   91|      0|    fn enabled(&self, metadata: &Metadata<'_>) -> bool {
   92|      0|        LEVEL_FILTER.with(|level_filter| metadata.level() <= &*level_filter.borrow())
   93|      0|    }
   94|       |
   95|      0|    fn new_span(&self, span_attributes: &Attributes<'_>) -> Id {
   96|      0|        let span_id = NEXT_ID.with(|next_id| {
   97|      0|            let id = *next_id.borrow();
   98|      0|            *next_id.borrow_mut() += 1;
   99|      0|            id
  100|      0|        });
  101|      0|        let id = Id::from_u64(span_id);
  102|      0|        let json = json!({
  103|      0|        "span": {
  104|      0|            "id": id.as_serde(),
  105|      0|            "attributes": span_attributes.as_serde(),
  106|      0|
  107|      0|        }});
  108|      0|        println!(
  109|      0|            "Thread {:?} {}",
  110|      0|            std::thread::current().id(),
  111|      0|            to_string_pretty(&json).expect("Failed to pretty print json")
  112|      0|        );
  113|      0|        SPANS.with(|spans| {
  114|      0|            spans.borrow_mut().insert(span_id, json);
  115|      0|        });
  116|      0|        let metadata = span_attributes.metadata();
  117|      0|        SPAN_METADATA.with(|span_metadata| {
  118|      0|            span_metadata.borrow_mut().insert(span_id, metadata);
  119|      0|        });
  120|      0|        id
  121|      0|    }
  122|       |
  123|      0|    fn record(&self, id: &Id, values: &Record<'_>) {
  124|      0|        let span_id = id.into_u64();
  125|      0|        SPANS.with(|spans| {
  126|      0|            let mut map = spans.borrow_mut();
  127|      0|            let entry = &mut *map
  128|      0|                .get_mut(&span_id)
  129|      0|                .unwrap_or_else(|| panic!("Failed to get span with ID {}", id.into_u64()));
  130|      0|            let json_object = entry
  131|      0|                .as_object_mut()
  132|      0|                .unwrap_or_else(|| panic!("Span entry is not an object {}", id.into_u64()));
  133|      0|            let mut json_values = json!(values.as_serde());
  134|      0|            println!(
  135|      0|                "Thread {:?} span {} values: {}",
  136|      0|                std::thread::current().id(),
  137|      0|                &span_id,
  138|      0|                to_string_pretty(&json_values).expect("Failed to pretty print json")
  139|      0|            );
  140|      0|            let json_values = json_values
  141|      0|                .as_object_mut()
  142|      0|                .expect("Record is not an object");
  143|      0|            json_object
  144|      0|                .get_mut("span")
  145|      0|                .expect("span not found in json")
  146|      0|                .as_object_mut()
  147|      0|                .expect("span was not an object")
  148|      0|                .get_mut("attributes")
  149|      0|                .expect("attributes not found in json")
  150|      0|                .as_object_mut()
  151|      0|                .expect("attributes was not an object")
  152|      0|                .append(json_values);
  153|      0|            println!(
  154|      0|                "Thread {:?} Updated Span {} values: {}",
  155|      0|                std::thread::current().id(),
  156|      0|                &span_id,
  157|      0|                to_string_pretty(&json_object).expect("Failed to pretty print json")
  158|      0|            );
  159|      0|        });
  160|      0|    }
  161|       |
  162|      0|    fn event(&self, event: &Event<'_>) {
  163|      0|        let json = json!({
  164|      0|            "event": event.as_serde(),
  165|      0|        });
  166|      0|        println!(
  167|      0|            "Thread {:?} {}",
  168|      0|            std::thread::current().id(),
  169|      0|            to_string_pretty(&json).expect("Failed to pretty print json")
  170|      0|        );
  171|      0|        EVENTS.with(|events| {
  172|      0|            events.borrow_mut().push(json);
  173|      0|        });
  174|      0|    }
  175|       |
  176|      0|    fn current_span(&self) -> Current {
  177|      0|        SPAN_STACK.with(|span_stack| {
  178|      0|            let stack = span_stack.borrow();
  179|      0|            if stack.is_empty() {
  180|      0|                return Current::none();
  181|      0|            }
  182|      0|            let id = stack.last().expect("Failed to get last span from stack");
  183|      0|            let map = SPAN_METADATA.with(|span_metadata| span_metadata.borrow().clone());
  184|      0|            let metadata = *map
  185|      0|                .get(&id.into_u64())
  186|      0|                .unwrap_or_else(|| panic!("Failed to get span metadata ID {}", id.into_u64()));
  187|      0|            Current::new(id.clone(), metadata)
  188|      0|        })
  189|      0|    }
  190|       |
  191|      0|    fn enter(&self, span: &Id) {
  192|      0|        println!(
  193|      0|            "Thread {:?} Entered Span {}",
  194|      0|            std::thread::current().id(),
  195|      0|            span.into_u64()
  196|      0|        );
  197|      0|        SPAN_STACK.with(|span_stack| {
  198|      0|            let mut stack = span_stack.borrow_mut();
  199|      0|            stack.push(span.clone());
  200|      0|        });
  201|      0|    }
  202|       |
  203|      0|    fn exit(&self, span: &Id) {
  204|      0|        println!(
  205|      0|            "Thread {:?} Exited Span {}",
  206|      0|            std::thread::current().id(),
  207|      0|            span.into_u64()
  208|      0|        );
  209|      0|        SPAN_STACK.with(|span_stack| {
  210|      0|            let mut stack = span_stack.borrow_mut();
  211|      0|            let popped = stack.pop();
  212|      0|            assert_eq!(popped, Some(span.clone()));
  213|      0|        });
  214|      0|    }
  215|       |
  216|       |    // We are not interested in this method for testing
  217|       |
  218|      0|    fn record_follows_from(&self, _span: &Id, _follows: &Id) {}
  219|       |}

